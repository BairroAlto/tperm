<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>Jogo Pol√≠tico Avan√ßado</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(to bottom, #1a1a1a, #2a2a2a);
            color: #fff;
            font-family: 'Segoe UI', sans-serif;
            margin: 0;
            padding: 15px;
            font-size: 14px;
        }

        .container {
            max-width: 1200px; /* Increased width */
            margin: auto;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); /* Grid layout */
            gap: 15px;
        }

        h1, h2 {
            text-align: center;
            grid-column: 1 / -1; /* Span full width */
            margin-bottom: 15px;
        }

         h2 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.2em;
            border-bottom: 1px solid #555;
            padding-bottom: 5px;
        }

        .card {
            background-color: #333;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 10px;
            box-shadow: 0 0 8px #00000060;
            display: flex;
            flex-direction: column;
        }

        /* Spanning cards */
        .span-2 { grid-column: span 2; }
        .span-all { grid-column: 1 / -1; }

        .botao {
            padding: 10px 15px;
            margin: 5px 3px;
            background-color: #3a86ff;
            border: none;
            color: white;
            font-weight: bold;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.3s;
            font-size: 0.9em;
        }

        .botao:hover:not(:disabled) {
            background-color: #265ecf;
        }
         .botao:disabled {
            background-color: #555;
            cursor: not-allowed;
         }

        .botao.perigo { background-color: #dc3545; }
        .botao.perigo:hover:not(:disabled) { background-color: #a71d2a; }
        .botao.sucesso { background-color: #28a745; }
        .botao.sucesso:hover:not(:disabled) { background-color: #1c7430; }
        .botao.info { background-color: #17a2b8; }
        .botao.info:hover:not(:disabled) { background-color: #10707f; }


        .barra {
            height: 20px;
            background-color: #555;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 8px;
            position: relative;
        }

        .preenchimento {
            height: 100%;
            text-align: center;
            line-height: 20px;
            color: #000;
            font-weight: bold;
            font-size: 0.8em;
            transition: width 0.5s ease-in-out;
            position: relative; /* Needed for z-index if text is outside */
            z-index: 1;
        }
         .barra-label {
            position: absolute;
            left: 5px;
            top: 0;
            line-height: 20px;
            color: #fff;
             font-size: 0.8em;
            z-index: 2; /* Above preenchimento */
            text-shadow: 1px 1px 1px #000;
         }

        #congresso .preenchimento { background-color: gold; }
        /* Add more specific colors if needed */

        .painel-escolhas, .painel-acoes {
            text-align: center;
            margin-top: 10px;
            display: flex; /* Use flexbox for button alignment */
            flex-wrap: wrap; /* Allow buttons to wrap */
            justify-content: center; /* Center buttons */
        }

        .indicador-item, .apoio-item, .midia-item, .gabinete-item, .partido-item {
            margin-bottom: 5px;
            font-size: 0.9em;
            display: flex;
            justify-content: space-between; /* Align label and value */
            border-bottom: 1px solid #444;
            padding-bottom: 3px;
        }
        .indicador-label, .apoio-label { font-weight: bold; }
        .indicador-valor, .apoio-valor { text-align: right; }

        .valor-positivo { color: #90ee90; } /* Light green */
        .valor-negativo { color: #f08080; } /* Light coral */
        .valor-neutro { color: #d3d3d3; } /* Light gray */

        #lista-manchetes {
            list-style: none;
            padding: 0;
            max-height: 150px; /* Limit height */
            overflow-y: auto; /* Add scroll */
            font-size: 0.85em;
        }
         #lista-manchetes li {
            border-bottom: 1px dotted #555;
            padding: 4px 0;
            margin-bottom: 4px;
         }
         #lista-manchetes li:last-child {
            border-bottom: none;
         }

         #evolucaoChart {
             max-height: 300px; /* Limit chart height */
             margin-top: 15px;
         }

        /* Modal Styles */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 100; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.6); /* Black w/ opacity */
        }

        .modal-content {
            background-color: #333;
            margin: 10% auto; /* 10% from the top and centered */
            padding: 20px;
            border: 1px solid #888;
            width: 80%; /* Could be more or less, depending on screen size */
            max-width: 600px;
            border-radius: 10px;
            color: #fff;
        }

        .modal-content h2 { color: #fff; text-align: center; }

        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close-button:hover,
        .close-button:focus {
            color: #fff;
            text-decoration: none;
        }

        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr; /* Stack cards on smaller screens */
            }
            .span-2 { grid-column: span 1; } /* Reset span */
            .modal-content { width: 90%; margin: 15% auto; }
        }
         @media (max-width: 600px) {
            .botao { width: calc(50% - 10px); } /* Two buttons per row */
            .painel-acoes .botao { width: calc(33% - 10px); } /* Three buttons per row */
         }

    </style>





</head>
<body>
    <!-- Achievement Notification Area -->
    <div id="notificacao-conquista">
        <span id="achievement-icon">üèÜ</span>
        <div>
            <strong>Conquista Desbloqueada!</strong><br>
            <span id="achievement-name">Nome da Conquista</span>
        </div>
    </div>

    <div class="container">
        <h1>Jogo Pol√≠tico Total</h1>

        <!-- Initial Setup Screens -->
        <div id="tela-inicial-botoes" class="card span-all" style="text-align: center;">
             <h3>Bem-vindo!</h3>
             <button id="btn-continuar-jogo" class="botao sucesso" style="display: none;">Continuar Jogo Salvo</button>
             <button id="btn-novo-jogo" class="botao info">Iniciar Novo Jogo</button>
             <button class="botao" onclick="mostrarModalHighScores()">High Scores</button> <!-- Added HS button here too -->
        </div>

        <div id="tela-modo-jogo" class="card span-all" style="display:none;">
            <h3>Escolha o Modo de Jogo</h3>
            <div class="painel-escolhas">
                <button class="botao">Simula√ß√£o Padr√£o</button>
                <button class="botao">Campanha Narrativa</button>
                <button class="botao">Modo S√°tira</button>
            </div>
        </div>

        <div id="inicio" class="card span-all" style="display:none;">
            <h3>Escolha seu l√≠der (Define o partido inicial):</h3>
            <div class="painel-escolhas">
                <button class="botao">Centro-Esquerda</button>
                <button class="botao">Liberal</button>
                <button class="botao">Conservador</button>
                <button class="botao">Populista</button>
            </div>
        </div>

        <div id="ministros-inicial" class="card span-all" style="display:none;">
            <h3>Monte seu Gabinete Inicial</h3>
            <p>Escolha 1 ministro para cada √°rea chave:</p>
            <div id="escolha-ministros-container"> <!-- JS will populate this --> </div>
            <div class="painel-acoes">
                <button class="botao sucesso">Iniciar Mandato</button>
            </div>
        </div>

        <!-- Main Game Screen -->
        <div id="jogo" style="display:none;" class="span-all">
             <div class="container"> <!-- Nested container for grid layout -->

                <!-- Header Info -->
                <div class="card span-all" style="padding: 10px 15px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;">
                         <strong id="tipoLider">L√≠der: -</strong>
                         <strong id="mandatoInfo">Mandato: 1 / Rodada: 0</strong>
                         <div> <!-- Action Buttons Header -->
                             <button id="btn-salvar-jogo" class="botao info botao-pequeno">Salvar Jogo</button>
                             <button id="btn-mostrar-conquistas" class="botao aviso botao-pequeno">Conquistas</button>
                         </div>
                    </div>
                </div>

                <!-- Leader Profile -->
                <div id="painel-lider" class="card">
                    <h3>Seu Perfil</h3>
                    <div id="lider-atributos"></div>
                    <p style="font-size:0.9em"><strong>Tra√ßos:</strong> <span id="lider-tracos"></span></p>
                    <p style="font-size:0.9em"><strong>N√≠vel:</strong> <span id="lider-nivel">1</span> | <strong>XP:</strong> <span id="lider-xp">0</span>/<span id="lider-xp-max">15</span></p>
                    <p style="font-size:0.9em"><strong>Habilidades:</strong> <span id="lider-habilidades">Nenhuma</span></p>
                    <p style="font-size:0.9em"><strong>Pontos:</strong> <span id="lider-pontos">0</span> <button id="botao-levelup" class="botao sucesso botao-pequeno" style="display:none;">Melhorar</button></p>
                </div>

                <!-- Main Indicators -->
                <div id="painel-indicadores" class="card">
                    <h3>Indicadores Chave</h3>
                    <div id="lista-indicadores"> <!-- JS will populate --> </div>
                </div>
                <div id="painel-orcamento" class="card">
                    <h3>Or√ßamento Federal</h3>
                    <div id="lista-orcamento"> <!-- JS will populate --> </div>
                </div>
                <div id="painel-apoio-grupos" class="card">
                    <h3>Apoio Popular (Grupos)</h3>
                    <div id="lista-apoio-grupos"> <!-- JS will populate --> </div>
                </div>
                <div id="painel-apoio-regional" class="card">
                    <h3>Apoio por Regi√£o</h3>
                     <div id="lista-apoio-regional"> <!-- JS will populate --> </div>
                </div>
                <div id="painel-congresso" class="card">
                    <h3>Apoio no Congresso</h3>
                    <div id="congresso" class="barra">
                         <div class="barra-label">Congresso:</div>
                         <div class="preenchimento" style="width: 50%;">50%</div>
                    </div>
                    <small id="congresso-detalhes">Coaliz√£o: -</small>
                </div>

                 <!-- Opposition Panel -->
                 <div id="painel-oposicao" class="card">
                    <h3>Principal Opositor</h3>
                    <p><strong>Nome:</strong> <span id="op-nome">Ningu√©m</span></p>
                    <p><strong>Partido:</strong> <span id="op-partido">-</span></p>
                    <p><strong>Popularidade:</strong> <span id="op-popularidade">?</span>%</p>
                 </div>

                 <!-- World Panel -->
                 <div id="painel-mundo" class="card">
                    <h3>Cen√°rio Internacional</h3>
                    <div id="lista-paises" style="font-size: 0.9em; max-height: 60px; overflow-y: auto; margin-bottom: 5px;"> <!-- JS Populates --> </div>
                    <p style="font-size:0.9em"><strong>Blocos/Alian√ßas:</strong> <span id="blocos-ativos-lista">Nenhum</span></p>
                    <p style="font-size:0.9em"><strong>Tratados:</strong> <span id="tratados-ativos-lista">Nenhum</span></p>
                    <div class="painel-acoes" style="margin-top: 5px;">
                        <button id="btn-mostrar-diplomacia" class="botao info botao-pequeno">Diplomacia</button>
                    </div>
                 </div>

                <!-- Dilemma / Action -->
                <div id="painel-dilema" class="card span-all"> <!-- Span full width -->
                    <h3 id="titulo-dilema">Pr√≥xima A√ß√£o</h3>
                    <p id="dilema-texto">Aguardando o in√≠cio do mandato...</p>
                    <div id="painel-opcoes" class="painel-escolhas"> <!-- JS populates options --> </div>
                    <hr style="border-color: #555; margin: 10px 0;">
                    <div class="painel-acoes">
                        <button id="botao-emendar" class="botao info" style="display: none;">Sugerir Emenda</button>
                        <button id="botao-viagem" class="botao info">Viagem Presidencial</button>
                        <button id="botao-orcamento" class="botao aviso" style="display: none;">Definir Or√ßamento Anual</button>
                        <button id="botao-gabinete" class="botao">Ver Gabinete</button>
                        <button id="botao-partidos" class="botao">Ver Partidos</button>
                    </div>
                </div>

                 <!-- Media Feed -->
                 <div id="painel-midia" class="card span-2"> <!-- Span 2 columns -->
                    <h3>√öltimas Not√≠cias</h3>
                    <ul id="lista-manchetes"> <li>Aguardando not√≠cias...</li> </ul>
                </div>

                 <!-- Chart -->
                 <div class="card span-2"> <!-- Span 2 columns -->
                    <h3>Evolu√ß√£o do Mandato</h3>
                    <canvas id="evolucaoChart"></canvas>
                 </div>

                 <!-- End Game Area -->
                 <div id="fim-jogo" class="card span-all" style="display: none;">
                    <h2 id="fim-titulo">Fim do Jogo</h2>
                    <p id="fim-mensagem" style="white-space: pre-wrap;"></p>
                    <div class="painel-acoes">
                         <button id="btn-reiniciar-jogo" class="botao sucesso">Jogar Novamente</button>
                         <button id="btn-exportar-pdf" class="botao info">Exportar Relat√≥rio PDF</button>
                         <button id="btn-ver-highscores-fim" class="botao">High Scores</button>
                    </div>
                 </div>

            </div><!-- End Nested container -->
        </div> <!-- End #jogo -->

        <!-- Modals -->
        <div id="modal-gabinete" class="modal">
            <div class="modal-content">
                <span class="close-button">√ó</span>
                <h3>Gabinete Atual</h3>
                <div id="lista-gabinete" class="modal-scrollable"></div>
                <div class="painel-acoes">
                     <button id="btn-iniciar-nomeacao" class="botao info">Nomear Ministro (se vago)</button>
                     <button class="botao btn-fechar-modal">Fechar</button>
                </div>
            </div>
        </div>
        <div id="modal-partidos" class="modal">
             <div class="modal-content">
                 <span class="close-button">√ó</span>
                 <h3>Partidos e Coaliz√£o</h3>
                 <p><strong>Sua Coaliz√£o Atual:</strong> <span id="coalizao-atual"></span></p>
                 <div id="lista-partidos" class="modal-scrollable"></div>
                 <div class="painel-acoes"> <button class="botao btn-fechar-modal">Fechar</button> </div>
             </div>
        </div>
        <div id="modal-nomeacao" class="modal">
             <div class="modal-content">
                 <span class="close-button">√ó</span>
                 <h3 id="nomeacao-titulo">Nomear Ministro</h3>
                 <p>Selecione um candidato para a pasta de <strong id="nomeacao-pasta"></strong>:</p>
                 <div id="lista-candidatos" class="modal-scrollable"></div>
                 <div class="painel-acoes"> <button class="botao btn-fechar-modal">Cancelar</button> </div>
             </div>
        </div>
         <div id="modal-viagem" class="modal">
             <div class="modal-content">
                 <span class="close-button">√ó</span>
                 <h3>Viagem Presidencial</h3>
                 <p>Escolha a regi√£o para visitar (Custo: <span id="viagem-custo"></span>):</p>
                 <div id="lista-regioes-viagem" class="painel-escolhas"></div>
                 <div class="painel-acoes"> <button class="botao btn-fechar-modal">Cancelar</button> </div>
             </div>
        </div>
        <div id="modal-narrativa" class="modal">
             <div class="modal-content">
                 <span class="close-button">√ó</span> <!-- Allow closing narrative modal -->
                 <h3 id="narrativa-titulo">Mensagem</h3>
                 <p id="narrativa-texto" style="white-space: pre-wrap;"></p>
                 <div class="painel-acoes"> <button class="botao btn-fechar-modal-narrativa">Ok</button> </div>
             </div>
        </div>
         <div id="modal-levelup" class="modal">
             <div class="modal-content">
                 <span class="close-button">√ó</span>
                 <h3>N√≠vel Aumentado!</h3>
                 <p>Voc√™ tem <strong id="levelup-pontos">X</strong> ponto(s) para gastar.</p>
                 <div class="modal-section">
                     <h4>Melhorar Atributos (Custo: 1 Ponto)</h4>
                     <div id="levelup-atributos"></div>
                 </div>
                 <div class="modal-section">
                     <h4>Aprender Habilidades (Custo: 1-2 Pontos)</h4>
                     <div id="levelup-habilidades" class="modal-scrollable"></div>
                 </div>
                 <div class="painel-acoes"> <button class="botao btn-fechar-modal">Fechar</button> </div>
             </div>
        </div>
         <div id="modal-orcamento" class="modal">
            <div class="modal-content">
                <span class="close-button" id="btn-cancelar-orcamento">√ó</span> <!-- Use button class/id -->
                <h3>Or√ßamento Anual - Proposta</h3>
                <p>Ajuste os gastos para o pr√≥ximo ano. Seu apoio atual no congresso √©: <strong id="orc-congresso-atual">?</strong>%</p>
                 <p>Tesouro Atual: <strong id="orc-tesouro-atual">R$ ? M</strong></p>
                 <div id="orcamento-categorias" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;" class="modal-scrollable">
                    <!-- JS populates sliders/inputs -->
                </div>
                <hr>
                <div style="display: flex; justify-content: space-around; font-weight: bold;">
                    <span>Total Proposto: <span id="orc-total-proposto">R$ 0 M</span></span>
                    <span>Saldo Projetado: <span id="orc-saldo-projetado">R$ 0 M</span></span>
                    <span>Apoio Necess√°rio: <span id="orc-suporte-necessario">~50%</span></span>
                </div>
                <div class="painel-acoes" style="margin-top: 20px;">
                    <button id="btn-submeter-orcamento" class="botao sucesso">Submeter ao Congresso</button>
                    <button id="btn-cancelar-orcamento-2" class="botao perigo">Cancelar (Manter Atual)</button> <!-- Alt ID for button -->
                </div>
            </div>
         </div>
         <div id="modal-diplomacia" class="modal">
             <div class="modal-content">
                 <span class="close-button">√ó</span>
                 <h3>Pol√≠tica Externa</h3>
                 <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                     <div class="modal-section">
                         <h4>Pa√≠ses</h4>
                         <div id="diplomacia-paises" class="modal-scrollable"></div>
                     </div>
                     <div >
                         <div class="modal-section">
                             <h4>Blocos e Alian√ßas</h4>
                             <div id="diplomacia-blocos" class="modal-scrollable" style="max-height: 120px;"></div>
                         </div>
                          <div class="modal-section">
                              <h4>Tratados Ativos</h4>
                              <div id="diplomacia-tratados" class="modal-scrollable" style="max-height: 120px;"></div>
                          </div>
                     </div>
                 </div>
                 <div class="painel-acoes"> <button class="botao btn-fechar-modal">Fechar</button> </div>
             </div>
        </div>
        <div id="modal-conquistas" class="modal">
            <div class="modal-content">
                 <span class="close-button">√ó</span>
                 <h3>Conquistas</h3>
                 <div id="lista-conquistas" class="modal-scrollable"></div>
                 <div class="painel-acoes"> <button class="botao btn-fechar-modal">Fechar</button> </div>
            </div>
        </div>
         <div id="modal-highscores" class="modal">
            <div class="modal-content">
                 <span class="close-button">√ó</span>
                 <h3>Melhores Pontua√ß√µes (Local)</h3>
                 <ol id="lista-highscores" style="padding-left: 20px;"></ol>
                 <div class="painel-acoes"> <button class="botao btn-fechar-modal">Fechar</button> </div>
            </div>
        </div>

        <!-- Debate Modal -->
         <div id="modal-debate" class="modal">
             <div class="modal-content">
                 <!-- No close button during debate -->
                 <h3 id="debate-titulo">Debate Presidencial</h3>
                 <div class="modal-section">
                     <p><strong>Oponente:</strong> <span id="debate-oponente-nome"></span></p>
                     <p><strong>Pergunta <span id="debate-questao-num">1</span>/<span id="debate-questao-total">3</span>:</strong></p>
                     <p id="debate-pergunta-texto" style="font-style: italic;"></p>
                 </div>
                 <div class="modal-section">
                     <h4>Sua Resposta:</h4>
                     <div id="debate-opcoes-resposta" class="painel-escolhas">
                         <!-- JS Populates Response Buttons -->
                     </div>
                 </div>
                 <div class="modal-section">
                     <p><strong>Pontua√ß√£o:</strong> Voc√™: <span id="debate-pontos-jogador">0</span> | Oponente: <span id="debate-pontos-oponente">0</span></p>
                     <div id="debate-feedback" style="min-height: 40px; font-size: 0.9em; color: #ccc;"></div>
                 </div>
             </div>
         </div>

    </div>












    <script>

    // --- Constants & Config ---
    const RODADAS_POR_MANDATO = 10;
    const MAX_MANDATOS = 3;
    const ORCAMENTO_INICIAL = 1000;
    const DESPESAS_FIXAS_POR_RODADA = 20;
    const COOLDOWN_VIAGEM = 4;
    const CUSTO_VIAGEM = 30;
    const BENEFICIO_VIAGEM_REGIONAL = 8;
    const BENEFICIO_VIAGEM_NACIONAL = 1;
    const CHANCE_EVENTO_ALEATORIO = 0.15;
    const CHANCE_DESASTRE_REGIONAL = 0.08;
    const CHANCE_CRISE_DIPLOMATICA = 0.05;
    const CHANCE_EVENTO_FAMILIAR = 0.04;
    const RODADAS_ANO_ORCAMENTO = Math.floor(RODADAS_POR_MANDATO / 4) || 3;
    const XP_POR_RODADA = 1;
    const XP_POR_MANDATO = 10;
    const XP_POR_CRISE_RESOLVIDA = 5;
    const XP_POR_LEI_APROVADA = 2;
    const MAX_HIGH_SCORES = 10;
    const SAVE_KEY = 'politicoTotalSave_v2';
    const HIGHSCORE_KEY = 'politicoTotalHighScores_v1';
    const NUM_DEBATE_QUESTIONS = 3;
    const AI_TURN_FREQUENCY = 2;
    const BASE_RECEITA_POR_RODADA = 95; // Receita base antes de modificadores (AJUSTE PARA BALANCEAMENTO)
    const FATOR_RECEITA_PIB = 0.8;     // Quanto cada ponto de PIB afeta a receita (AJUSTE)
    const FATOR_CUSTO_INFLACAO = 1.0;  // Sensibilidade do custo alocado √† infla√ß√£o (1.0 = 1% de infla√ß√£o aumenta custo em 1%) (AJUSTE)
    const LIMIAR_CUSTO_DESEMPREGO = 5; // % de desemprego acima do qual come√ßa a gerar custo extra (AJUSTE)
    const CUSTO_POR_PONTO_DESEMPREGO = 1.5; // Custo em Milh√µes por ponto percentual de desemprego acima do limiar (AJUSTE)
    const MAX_RECEITA_EXTRA_PIB = 25;  // Limite m√°ximo de receita extra vinda do PIB por rodada
    const MAX_CUSTO_EXTRA_DESEMPREGO = 30; // Limite m√°ximo de custo extra vindo do desemprego por rodada









    // --- Game State Variables ---
    let congresso, tesouro, popularidadeGrupos, apoioRegional, indicadoresSociaisEconomicos;
    let orcamentoAlocado, despesasFixasPorRodada, propostaOrcamento, eventoOrcamentoAtivo;
    let liderAtual, lider, gabinete, ministrosAtivos;
    let partidos, relacoesPartidos, coalizao;
    let oponentePrincipal, popularidadeOponente;
    let relacoesPaises, blocosAtivos, tratadosAtivos;
    let rodada, mandatoAtual, gameMode;
    let campaignState;
    let eventosAgendados, dilemaAtual, emendaSugerida, cooldownViagem, fakeNewsAtivas, debateAtual;
    let pandemiaAtiva, regiaoEmRevolta;
    let jogoAtivo, historico, achievementsState, localHighScores;
    let notificacaoTimeout, evolucaoChart, jogoPausado;

    // --- STATIC DATA --- (Ensure no syntax errors like missing commas within these!)
    const GRUPOS_POPULACAO = ["Empres√°rios", "Trabalhadores", "Classe M√©dia", "Militares", "Religiosos", "Progressistas", "Nacionalistas"];
    const REGIOES = ["Sul", "Sudeste", "Nordeste", "Norte", "Centro-Oeste"];
    const AREAS_ORCAMENTO = ["saude", "educacao", "defesa", "infraestrutura", "seguranca", "social", "cultura", "meio_ambiente", "ciencia_tecnologia"];

    const poolMinistros = [
        { id: "min001", nome: "Ana Silva", area: "economia", personalidade: ["Leal", "Tecnocrata"], bonus: { custoProjetosEconomia: -0.05 }, partidoId: "partido_liberal", lealdadeInicial: 70, riscoCorrupcao: 15 },
        { id: "min002", nome: "Carlos Borges", area: "social", personalidade: ["Populista", "Ambicioso", "Corrupt√≠vel"], bonus: { popTrabalhadores: 2 }, partidoId: "partido_centro_esquerda", lealdadeInicial: 40, riscoCorrupcao: 60 },
        { id: "min003", nome: "Mariana Lima", area: "economia", personalidade: ["Pragm√°tica", "Negociadora"], bonus: { relacaoEmpresarios: 5 }, partidoId: "partido_conservador", lealdadeInicial: 60, riscoCorrupcao: 30 },
        { id: "min004", nome: "General F. Costa", area: "defesa", personalidade: ["Leal", "Austero"], bonus: { popMilitares: 5, custoDefesa: -0.1 }, partidoId: "partido_conservador", lealdadeInicial: 80, riscoCorrupcao: 5 },
        { id: "min005", nome: "Sofia Almeida", area: "social", personalidade: ["Idealista", "Progressista"], bonus: { popProgressistas: 3, "relacao ONGs": 10 }, partidoId: "partido_centro_esquerda", lealdadeInicial: 65, riscoCorrupcao: 10 },
        { id: "min006", nome: "Ricardo Alves", area: "economia", personalidade: ["Liberal", "Experiente"], bonus: { crescimentoPIB_mod: 0.1, inflacao_mod: -0.05 }, partidoId: "partido_liberal", lealdadeInicial: 55, riscoCorrupcao: 25 },
        { id: "min007", nome: "Helena Santos", area: "defesa", personalidade: ["Estrategista", "Ambiciosa"], bonus: { congresso_defesa_mod: 3 }, partidoId: "partido_liberal", lealdadeInicial: 50, riscoCorrupcao: 35 },
        { id: "min008", nome: "Pastor J. Oliveira", area: "social", personalidade: ["Carism√°tico", "Conservador"], bonus: { popReligiosos: 4 }, partidoId: "partido_conservador", lealdadeInicial: 75, riscoCorrupcao: 20 },
        { id: "min009", nome: "Dr. Eduardo Chen", area: "ciencia_tecnologia", personalidade: ["Tecnocrata", "Vision√°rio"], bonus: { chanceSucessoPesquisa: 0.1 }, partidoId: "partido_liberal", lealdadeInicial: 60, riscoCorrupcao: 5 },
        { id: "min010", nome: "Isabela Moreira", area: "meio_ambiente", personalidade: ["Idealista", "Combativa"], bonus: { relacaoVerdes: 10 }, partidoId: "partido_verde", lealdadeInicial: 70, riscoCorrupcao: 10 },
        { id: "min011", nome: "Roberto Andrade", area: "infraestrutura", personalidade: ["Pragm√°tico", "Corrupt√≠vel"], bonus: { custoInfra: -0.05 }, partidoId: "partido_populista", lealdadeInicial: 45, riscoCorrupcao: 70 },
        { id: "min012", nome: "S√©rgio Barros", area: "seguranca", personalidade: ["Linha Dura", "Leal"], bonus: { indicador_criminalidade_mod: -0.5 }, partidoId: "partido_conservador", lealdadeInicial: 70, riscoCorrupcao: 20 },
        { id: "min013", nome: "Beatriz Melo", area: "cultura", personalidade: ["Progressista", "Carism√°tica"], bonus: { popClasseMedia: 1 }, partidoId: "partido_centro_esquerda", lealdadeInicial: 65, riscoCorrupcao: 15 } // Hypothetical missing comma fixed here if it was the issue
    ];

    const partidosBase = {
        "partido_centro_esquerda": { nome: "Alian√ßa Progressista", ideologia: "Centro-Esquerda", forcaBaseCongresso: 20, relacaoInicial: { "partido_liberal": 40, "partido_conservador": 20, "partido_populista": 50, "partido_verde": 65 } },
        "partido_liberal": { nome: "Movimento Liberal", ideologia: "Liberal", forcaBaseCongresso: 25, relacaoInicial: { "partido_centro_esquerda": 40, "partido_conservador": 60, "partido_populista": 30, "partido_verde": 35 } },
        "partido_conservador": { nome: "Bloco Conservador", ideologia: "Conservador", forcaBaseCongresso: 22, relacaoInicial: { "partido_centro_esquerda": 20, "partido_liberal": 60, "partido_populista": 45, "partido_verde": 15 } },
        "partido_populista": { nome: "Voz do Povo", ideologia: "Populista", forcaBaseCongresso: 18, relacaoInicial: { "partido_centro_esquerda": 50, "partido_liberal": 30, "partido_conservador": 45, "partido_verde": 40 } },
        "partido_verde": { nome: "Partido Verde", ideologia: "Ambientalista", forcaBaseCongresso: 8, relacaoInicial: { "partido_centro_esquerda": 65, "partido_liberal": 35, "partido_conservador": 15, "partido_populista": 40 } },
        "partido_independente": { nome: "Independentes", ideologia: "Variada", forcaBaseCongresso: 7, relacaoInicial: {} }
    };

    const midia = {
        "jornal_conservador": { nome: "Gazeta Nacional", vies: "Conservador", audiencia: ["Empres√°rios", "Classe M√©dia", "Religiosos"] },
        "blog_progressista": { nome: "Voz Ativa Digital", vies: "Progressista", audiencia: ["Progressistas", "Trabalhadores"] },
        "tv_popular": { nome: "Canal do Povo TV", vies: "Populista", audiencia: ["Classe M√©dia", "Trabalhadores"] },
        "revista_liberal": { nome: "Mercado em Foco", vies: "Liberal", audiencia: ["Empres√°rios", "Classe M√©dia"] }
    };

    const dilemas = [
        { id: "d001", tipo: "economia", podeEmendar: true, texto: "Reforma Tribut√°ria: Simplificar impostos ou aumentar carga sobre os mais ricos?", opcoes: [ { texto: "Simplificar (Popular entre empres√°rios)", custoOrcamentoImediato: 20, efeitosImediatos: { popEmpresarios: +8, popClasseMedia: +3, popTrabalhadores: -2, congresso_mod: +5, receitaPorRodadaMod: -5 }, efeitosFuturos: [{ delayMin: 6, delayMax: 12, chance: 0.3, eventoId: "ev_burocracia_reduzida" }] }, { texto: "Aumentar carga nos ricos (Popular entre trabalhadores)", custoOrcamentoImediato: 5, efeitosImediatos: { popEmpresarios: -10, popClasseMedia: -2, popTrabalhadores: +10, congresso_mod: -5, receitaPorRodadaMod: +15 }, efeitosFuturos: [{ delayMin: 8, delayMax: 15, chance: 0.4, eventoId: "ev_fuga_capital" }] }, { texto: "Manter sistema atual (Status quo)", custoOrcamentoImediato: 0, efeitosImediatos: { indicador_dividaPublica: +0.5 }, efeitosFuturos: [] } ] },
        { id: "d002", tipo: "economia", podeEmendar: false, texto: "Privatizar a empresa estatal de energia?", opcoes: [ { texto: "Sim (Alegra mercado, irrita sindicatos)", custoOrcamentoImediato: 0, efeitosImediatos: { popEmpresarios: +10, popTrabalhadores: -8, indicador_dividaPublica: -5, tesouro: +500, congresso_mod: +8 }, efeitosFuturos: [{ delayMin: 10, delayMax: 18, chance: 0.5, eventoId: "ev_crise_tarifaria" }] }, { texto: "N√£o (Mant√©m controle, desagrada liberais)", custoOrcamentoImediato: 0, efeitosImediatos: { popEmpresarios: -6, popTrabalhadores: +4, satisfacaoMidia_revista_liberal: -8 }, efeitosFuturos: [{ delayMin: 5, delayMax: 10, chance: 0.3, eventoId: "ev_ineficiencia_estatal" }] } ] },
        { id: "d003", tipo: "social", podeEmendar: true, texto: "Ampliar programa de Bolsa Fam√≠lia?", opcoes: [ { texto: "Sim, aumentar valor e alcance", custoOrcamentoImediato: 50, efeitosImediatos: { popTrabalhadores: +12, popProgressistas: +5, popEmpresarios: -4, orcamentoAreaMod: { social: +25 }, indicador_desemprego: -0.2 }, efeitosFuturos: [] }, { texto: "N√£o, focar em programas de emprego", custoOrcamentoImediato: 15, efeitosImediatos: { popTrabalhadores: -6, popEmpresarios: +5, popClasseMedia: +3 }, efeitosFuturos: [{ delayMin: 8, delayMax: 16, chance: 0.4, eventoId: "ev_qualificacao_profissional" }] }, { texto: "Manter como est√°", custoOrcamentoImediato: 0, efeitosImediatos: {}, efeitosFuturos: [] } ] },
        { id: "d004", tipo: "ideologica", podeEmendar: false, texto: "Legalizar o casamento entre pessoas do mesmo sexo?", opcoes: [ { texto: "Sim (Apoio progressista, Oposi√ß√£o conservadora)", custoOrcamentoImediato: 5, efeitosImediatos: { popProgressistas: +20, popReligiosos: -25, popClasseMedia: +5, satisfacaoMidia_blog_progressista: +15, satisfacaoMidia_jornal_conservador: -15 }, efeitosFuturos: [] }, { texto: "N√£o (Apoio conservador, Oposi√ß√£o progressista)", custoOrcamentoImediato: 0, efeitosImediatos: { popProgressistas: -15, popReligiosos: +15, satisfacaoMidia_blog_progressista: -10, satisfacaoMidia_jornal_conservador: +10 }, efeitosFuturos: [] } ] },
        { id: "d005", tipo: "seguranca", podeEmendar: true, texto: "Aumentar o policiamento nas ruas ou investir em intelig√™ncia?", opcoes: [ { texto: "Mais policiamento ostensivo", custoOrcamentoImediato: 40, efeitosImediatos: { popMilitares: +5, popClasseMedia: +4, indicador_criminalidade: -3, orcamentoAreaMod: { seguranca: +15 } }, efeitosFuturos: [{ delayMin: 10, delayMax: 20, chance: 0.3, eventoId: "ev_violencia_policial" }] }, { texto: "Investir em intelig√™ncia e investiga√ß√£o", custoOrcamentoImediato: 30, efeitosImediatos: { popMilitares: -2, popProgressistas: +3, indicador_criminalidade: -2, orcamentoAreaMod: { seguranca: +10 } }, efeitosFuturos: [{ delayMin: 12, delayMax: 24, chance: 0.5, eventoId: "ev_desmantelar_quadrilha" }] }, { texto: "Manter estrat√©gia atual", custoOrcamentoImediato: 0, efeitosImediatos: {}, efeitosFuturos: [] } ] },
        { id: "d100", lore: true, tipo: "regional_conflito", texto: "Nova Caled√¥nia, uma prov√≠ncia rica em min√©rios, amea√ßa secess√£o se suas demandas por autonomia fiscal n√£o forem atendidas.", regiaoAlvoFixa: "sul", opcoes: [ { texto: "Conceder autonomia fiscal parcial", custoOrcamentoImediato: 10, efeitosImediatos: { regSul: +10, popNacionalistas: -5, receitaPorRodadaMod: -3 }, efeitosFuturos: [{ delayMin: 10, delayMax: 20, chance: 0.3, eventoId: "ev_abuso_autonomia" }] }, { texto: "Negociar um acordo intermedi√°rio", custoOrcamentoImediato: 5, efeitosImediatos: { regSul: +5, popNacionalistas: -2 } }, { texto: "Rejeitar demandas e refor√ßar presen√ßa federal", custoOrcamentoImediato: 30, efeitosImediatos: { regSul: -15, popNacionalistas: +10, chanceCriseSeparatismo: 0.4 } } ] },
    ];

    const eventosAleatorios = [
        { id: "ev_mercado_otimista", texto: "Mercado internacional reage com otimismo √†s pol√≠ticas do governo.", efeitos: { crescimentoPIB: +0.3, popEmpresarios: +4, tesouro: +20 } },
        { id: "ev_estrela_esporte", texto: "Atleta nacional ganha medalha de ouro ol√≠mpica!", efeitos: { popularidadeGeral: +5, satisfacaoMidia_tv_popular: +10 } },
        { id: "ev_descoberta_cientifica", texto: "Universidade p√∫blica faz descoberta cient√≠fica relevante.", efeitos: { popClasseMedia: +3, popProgressistas: +4, indicador_educacao: +1, orcamentoAreaMod: {ciencia_tecnologia: +5} } },
        { id: "ev_crise_refugiados", texto: "Onda de refugiados chega √† fronteira pedindo asilo.", chanceDilemaResposta: 0.8, efeitos: { popProgressistas: +2, popReligiosos: -3, popNacionalistas: -4} },
        { id: "ev_previsao_negativa", texto: "Ag√™ncia de risco internacional rebaixa a nota de cr√©dito do pa√≠s.", efeitos: { crescimentoPIB: -0.2, popEmpresarios: -5, indicador_dividaPublica: +1 } },
        { id: "ev_fofoca_ministro", texto: "Revista de fofocas publica mat√©ria sobre a vida pessoal de um ministro.", efeitos: { lealdadeMinistroAleatorio: -5, satisfacaoMidiaGeral: -2 } },
        { id: "ev100", lore: true, texto: "Descoberta de ru√≠nas ancestrais na Floresta de √âbano atrai aten√ß√£o internacional e de grupos ind√≠genas.", efeitos: { satisfacaoMidiaInternacional: +5, popProgressistas: +2 }, chanceDilemaResposta: 0.5 },
    ];

    const desastresRegionais = [
        { id: "desastre_enchentes", nome: "Fortes Chuvas e Enchentes", regioesPotenciais: ["Sul", "Sudeste"], probabilidadeBase: 0.03, efeitos: { popRegiaoAfetada: -15, popNacionalMedia: -5, custoRecuperacao: 100, indicador_saude: -2, chanceDilemaResposta: 0.8 } },
        { id: "desastre_seca", nome: "Seca Prolongada", regioesPotenciais: ["Nordeste"], probabilidadeBase: 0.04, efeitos: { popRegiaoAfetada: -12, indicador_crescimentoPIB: -0.3, custoAjudaEmergencial: 80, indicador_criminalidade: +1, chanceDilemaResposta: 0.7 } },
        { id: "desastre_queimadas", nome: "Queimadas Fora de Controle", regioesPotenciais: ["Norte", "Centro-Oeste"], probabilidadeBase: 0.02, efeitos: { popRegiaoAfetada: -8, satisfacaoMidiaInternacional: -15, custoCombateIncendio: 60, indicador_saude: -1, chanceDilemaResposta: 0.6 } }
    ];

    const crises = [
         { id: "crise_corrupcao_ministro", textoBase: "ESC√ÇNDALO! Seu Ministro [NOME_MINISTRO] da pasta de [PASTA] foi pego em grava√ß√µes negociando propina!", tipo: "gabinete", requerMinistro: true, opcoes: [ { texto: "Demitir imediatamente e apoiar investiga√ß√£o", efeitos: { demitirMinistroAlvo: true, popClasseMedia: +5, popProgressistas: +4, relacoesPartidoMinistro: -20, lealdadeMinistroAlvo: -100, setFlag: "escandalo_resolvido" } }, { texto: "Defender publicamente e abrir investiga√ß√£o interna", efeitos: { lealdadeMinistroAlvo: +20, relacoesPartidoMinistro: +10, popClasseMedia: -8, popProgressistas: -6, chanceFuturaCriseAgravada: 0.4, setFlag: "escandalo_resolvido" } }, { texto: "Tentar abafar o caso com a m√≠dia aliada (Requer M√≠dia > 65)", condicao: { tipo: 'satisfacaoMidiaGeral', minValor: 65 }, custoOrcamentoImediato: 20, efeitos: { popGeral: -15, chanceFuturaVazamento: 0.6, lealdadeMinistroAlvo: +10, setFlag: "escandalo_resolvido" } } ]},
         { id: "crise_protestos_massa", texto: "PROTESTOS EM MASSA! Milhares nas ruas contra o governo. Exigem sua ren√∫ncia!", tipo: "popularidade", opcoes: [ { texto: "Ignorar e reprimir com for√ßa", custoOrcamentoImediato: 50, efeitos: { popGeral: -20, popMilitares: +5, indicador_criminalidade: +5, congresso_mod: -10, chanceFuturaCriseAgravada: 0.5 } }, { texto: "Dialogar com l√≠deres e fazer concess√µes", custoOrcamentoImediato: 20, efeitos: { popGeral: +5, congresso_mod: -5, orcamentoAreaMod: { social: +5} } }, { texto: "Discurso √† na√ß√£o pedindo calma e unidade", efeitos: { popGeral: +2 } } ]},
        { id: "crise_confianca_mercado", texto: "Crise de Confian√ßa! Investidores retiram dinheiro do pa√≠s, moeda desvaloriza.", tipo: "economia", opcoes: [ { texto: "Aumentar juros drasticamente", efeitos: { inflacao: -1.0, crescimentoPIB: -0.8, popEmpresarios: -10, popTrabalhadores: -6, indicador_dividaPublica: +1 } }, { texto: "Intervir no c√¢mbio (gastar reservas)", custoOrcamentoImediato: 150, efeitos: { popEmpresarios: +5, tesouro: -150 } }, { texto: "Anunciar pacote de austeridade", efeitos: { popGeral: -10, indicador_dividaPublica: -2, receitaPorRodadaMod: +5, orcamentoTotalModPercent: -0.1, congresso_mod: +5 } } ]},
         { id: "crise_tentativa_golpe", texto: "ALERTA M√ÅXIMO! Setores das For√ßas Armadas se mobilizam e cercam o pal√°cio presidencial! Exigem sua ren√∫ncia imediata!", tipo: "golpe_estado", triggerCondicao: { popMilitares: 15, congresso: 25, popGeral: 25 }, opcoes: [ { texto: "Resistir e convocar for√ßas leais (Risco Alto!)", efeitos: { chanceGuerraCivil: 0.6, gameOverChanceResistir: 0.4, popMilitares: -10 } }, { texto: "Negociar uma transi√ß√£o pac√≠fica (Renunciar)", efeitos: { gameOver: true, mensagemFim: "Voc√™ renunciou sob press√£o militar para evitar um banho de sangue." } }, { texto: "Tentar fugir para o ex√≠lio", efeitos: { gameOver: true, mensagemFim: "Voc√™ fugiu do pa√≠s enquanto os militares tomavam o poder." } } ] },
         { id: "crise_greve_geral", texto: "GREVE GERAL! Sindicatos paralisam setores chave da economia exigindo reajuste salarial e melhores condi√ß√µes.", tipo: "social_economica", triggerCondicao: { popTrabalhadores: 25, indicador_inflacao: 8.0 }, opcoes: [ { texto: "Negociar com sindicatos (Ceder parcialmente)", custoOrcamentoImediato: 50, efeitos: { popTrabalhadores: +15, popEmpresarios: -5, orcamentoAreaMod: {social: +10}, indicador_inflacao: +0.2 } }, { texto: "Declarar greve ilegal e usar a for√ßa (Alto Risco)", custoOrcamentoImediato: 20, efeitos: { popTrabalhadores: -20, popMilitares: +5, popProgressistas: -10, indicador_criminalidade: +5, chanceEventoCaos: 0.5 } }, { texto: "Ignorar e esperar que a greve perca for√ßa", efeitos: { popTrabalhadores: -10, crescimentoPIB: -0.5, chanceEventoCaos: 0.3, satisfacaoMidiaGeral: -5 } } ] },
         { id: "crise_pressao_internacional", textoBase: "Press√£o Internacional! ONU e FMI criticam duramente seu governo [MOTIVO_CRITICA] e amea√ßam san√ß√µes / exigem reformas.", tipo: "internacional", triggerCondicao: { dividaPublica: 70 }, motivoPlaceholder: "pela alta d√≠vida e pol√≠ticas econ√¥micas", opcoes: [ { texto: "Aceitar exig√™ncias do FMI (Austeridade)", efeitos: { tesouro: +200, popGeral: -15, crescimentoPIB: -0.5, orcamentoTotalModPercent: -0.15, indicador_dividaPublica: -5 } }, { texto: "Rejeitar interfer√™ncia externa (Desafio)", efeitos: { satisfacaoMidiaInternacional: -20, popNacionalista: +10, chanceSancoes: 0.4 } }, { texto: "Buscar apoio de outras na√ß√µes (Diplomacia)", custoOrcamentoImediato: 30, efeitos: { chanceSucessoDiplomacia: 0.4 } } ] },
         { id: "crise_pandemia", texto: "PANDEMIA GLOBAL! Um v√≠rus altamente contagioso se espalha pelo mundo, casos confirmados no pa√≠s!", tipo: "saude_global", triggerCondicao: { randomChance: 0.005 }, efeitoContinuo: { indicador_saude: -1.5, crescimentoPIB: -0.1, indicador_desemprego: +0.1 }, opcoes: [ { texto: "Implementar Lockdown Nacional R√≠gido", custoOrcamentoImediato: 50, efeitos: { indicador_saude: +10, crescimentoPIB: -2.0, indicador_desemprego: +3.0, popGeral: -5, orcamentoAreaMod: {saude: +15}, pandemiaContidaChance: 0.6 } }, { texto: "Foco em testagem e tratamento (Sem lockdown)", custoOrcamentoImediato: 80, efeitos: { indicador_saude: -10, crescimentoPIB: -0.5, indicador_desemprego: +1.0, popGeral: +2, orcamentoAreaMod: {saude: +25}, pandemiaContidaChance: 0.2 } }, { texto: "Investir massivamente em vacina/cura (Longo prazo)", custoOrcamentoImediato: 200, efeitos: { indicador_saude: -8, tesouro: -200, orcamentoAreaMod: {ciencia_tecnologia: +30}, chanceFuturaVacina: 0.7 } } ] },
         { id: "crise_separatismo", textoBase: "REVOLTA REGIONAL! Movimento separatista na regi√£o [REGIAO] ganha for√ßa e declara inten√ß√£o de secess√£o!", tipo: "regional_conflito", requerRegiao: true, triggerCondicao: { apoioRegionalMin: 15 }, opcoes: [ { texto: "Negociar maior autonomia e investimentos", custoOrcamentoImediato: 100, efeitos: { popRegiaoAlvo: +20, congresso_mod: -5, orcamentoAreaMod: {infraestrutura: +8}, separatismoResolvidoChance: 0.7 } }, { texto: "Enviar For√ßas Armadas para reprimir", custoOrcamentoImediato: 80, efeitos: { popRegiaoAlvo: -30, popMilitares: +15, popProgressistas: -10, indicador_criminalidade: +8, chanceGuerraCivilRegional: 0.4, separatismoResolvidoChance: 0.5 } }, { texto: "Ignorar as demandas (Arriscado)", efeitos: { popRegiaoAlvo: -10, chancePerdaTerritorio: 0.3, satisfacaoMidiaGeral: -5 } } ] },
         { id: "crise_escandalo_familiar", textoBase: "ESC√ÇNDALO FAMILIAR! Seu familiar, [NOME_FAMILIAR], foi envolvido em [MOTIVO_ESCANDALO]!", tipo: "pessoal", requerFamiliar: true, opcoes: [ { texto: "Defender publicamente e usar influ√™ncia", custoOrcamentoImediato: 10, efeitos: { popGeral: -5, chanceAbafarSucesso: 0.6 } }, { texto: "Deixar a justi√ßa seguir seu curso", efeitos: { popGeral: +2 } }, { texto: "Cortar rela√ß√µes publicamente", efeitos: { popGeral: +4 } } ] }
    ];

    const eventosFuturosDefinidos = {
         "ev_burocracia_reduzida": { texto: "Empresas relatam melhora no ambiente de neg√≥cios ap√≥s reforma tribut√°ria.", efeitos: { crescimentoPIB: +0.2, popEmpresarios: +3 } },
         "ev_fuga_capital": { texto: "Grandes investidores amea√ßam deixar o pa√≠s devido √† alta carga tribut√°ria.", efeitos: { crescimentoPIB: -0.3, popEmpresarios: -6 } },
         "ev_crise_tarifaria": { texto: "Popula√ß√£o reclama de altas tarifas de energia ap√≥s privatiza√ß√£o.", efeitos: { popGeral: -8, inflacao: +0.3 } },
         "ev_ineficiencia_estatal": { texto: "Empresa estatal de energia apresenta preju√≠zo e pede mais verba.", efeitos: { tesouro: -50, popEmpresarios: -3 } },
         "ev_qualificacao_profissional": { texto: "Novos programas de emprego come√ßam a mostrar resultados positivos.", efeitos: { indicador_desemprego: -0.3, popClasseMedia: +2 } },
         "ev_violencia_policial": { texto: "Caso de viol√™ncia policial gera revolta e protestos.", efeitos: { popGeral: -7, popProgressistas: -10, indicador_criminalidade: +2 } },
         "ev_desmantelar_quadrilha": { texto: "Pol√≠cia Federal desmantela grande quadrilha de crime organizado.", efeitos: { popGeral: +6, indicador_criminalidade: -4 } },
         "protestos_previdencia": { texto: "Sindicatos organizam grandes protestos contra a Reforma da Previd√™ncia.", efeitos: { popTrabalhadores: -8, popClasseMedia: -3, congresso_mod: -5 } },
         "ev_abuso_autonomia": { texto: "Prov√≠ncia com autonomia fiscal parece estar desviando verbas federais.", efeitos: { popNacionalista: -4, tesouro: -15 } },
         "ev_sucesso_diplomacia": { texto: "Negocia√ß√µes diplom√°ticas foram bem-sucedidas!", efeitos: { satisfacaoMidiaInternacional: +10 } },
         "ev_falha_diplomacia": { texto: "Esfor√ßos diplom√°ticos falharam em resolver a tens√£o.", efeitos: { satisfacaoMidiaInternacional: -5 } },
         "ev_vazamento_abafado": { texto: "VAZOU! Tentativa de abafar esc√¢ndalo anterior veio √† tona!", efeitos: { popGeral: -20 } },
         "ev_vacina_descoberta": { texto: "CIENTISTAS ANUNCIAM VACINA EFICAZ! Fim da pandemia √† vista!", efeitos: { setFlag: "pandemia_controlada", indicador_saude: +20, popGeral: +15, crescimentoPIB: +1.0 } } // Used flag instead of direct bool change
    };

    const paises = {
        "pais_a": { nome: "Rep√∫blica Unida", ideologia: "Liberal Democrata", forcaMilitar: 9, forcaEconomica: 10, relacaoInicialMod: { 'Liberal': +10, 'Conservador': 0, 'CentroEsquerda': +5, 'Populista': -5 } },
        "pais_b": { nome: "Federa√ß√£o Oriental", ideologia: "Autorit√°rio Capitalista", forcaMilitar: 8, forcaEconomica: 8, relacaoInicialMod: { 'Liberal': -5, 'Conservador': +5, 'CentroEsquerda': -10, 'Populista': 0 } },
        "pais_c": { nome: "Vizinl√¢ndia Pr√≥spera", ideologia: "Social Democrata", forcaMilitar: 5, forcaEconomica: 7, relacaoInicialMod: { 'Liberal': +5, 'Conservador': -5, 'CentroEsquerda': +15, 'Populista': 0 } },
        "pais_d": { nome: "Rep√∫blica Inst√°vel", ideologia: "Populista Nacionalista", forcaMilitar: 4, forcaEconomica: 3, relacaoInicialMod: { 'Liberal': -10, 'Conservador': 0, 'CentroEsquerda': -5, 'Populista': +10 } },
        "pais_e": { nome: "Liga das Na√ß√µes Livres", ideologia: "Variada", forcaMilitar: 6, forcaEconomica: 6, relacaoInicialMod: { 'Liberal': 0, 'Conservador': 0, 'CentroEsquerda': 0, 'Populista': +5 } }
    };

    const blocos = {
        "bloco_sul": { nome: "Uni√£o Meridional", tipo: "Economico", membrosIniciais: ["pais_c"], beneficios: { receitaPorRodadaMod: +5, crescimentoPIB_mod: +0.05 }, condicoesEntrada: { relacaoMinPais: { "pais_c": 60 }, ideologiaCompativeis: ["Social Democrata", "CentroEsquerda", "Liberal"] } },
        "alianca_defesa_oeste": { nome: "Pacto de Defesa Ocidental", tipo: "Militar", membrosIniciais: ["pais_a"], beneficios: { defesaBonus: 10, relacao_pais_a: +2 }, condicoesEntrada: { relacaoMinPais: { "pais_a": 70 }, forcaMilitarMin: 5 } }
    };

    const crisesDiplomaticas = [
        { id: "crise_insulto_diplomata", textoBase: "Crise Diplom√°tica! Seu embaixador em [PAIS] fez coment√°rios ofensivos sobre o governo local. O pa√≠s [PAIS] exige um pedido formal de desculpas!", tipo: "diplomatica", requerPais: true, triggerCondicao: { randomChance: 0.05 }, opcoes: [ { texto: "Pedir desculpas formalmente", efeitos: { relacaoPaisAlvo: +15, popNacionalista: -5 } }, { texto: "Defender seu embaixador (Dobrar a aposta)", efeitos: { relacaoPaisAlvo: -25, popNacionalista: +10, chanceSancoes: 0.3 } }, { texto: "Retirar o embaixador discretamente", efeitos: { relacaoPaisAlvo: -5 } } ] },
        { id: "crise_guerra_comercial", textoBase: "Guerra Comercial Iminente! O pa√≠s [PAIS] acusa seu governo de pr√°ticas desleais e imp√µe tarifas sobre seus produtos!", tipo: "comercial", requerPais: true, triggerCondicao: { relacaoMinPais: 30 }, opcoes: [ { texto: "Retaliar com tarifas pr√≥prias", efeitos: { relacaoPaisAlvo: -15, receitaPorRodadaMod: -10, crescimentoPIB: -0.3, popEmpresarios: -5 } }, { texto: "Iniciar negocia√ß√µes na OMC", custoOrcamentoImediato: 20, efeitos: { chanceResolucaoOMC: 0.5 } }, { texto: "Oferecer concess√µes comerciais", efeitos: { relacaoPaisAlvo: +10, receitaPorRodadaMod: -5, popEmpresarios: +3 } } ] }
    ];

    const tracosDefinidos = {
        "Populista": { descricao: "Conecta-se facilmente com as massas.", efeito: "+1 Carisma, b√¥nus com popTrabalhadores/ClasseM√©dia, risco de desagradar empres√°rios." },
        "Idealista": { descricao: "Segue princ√≠pios fortes, √†s vezes inflex√≠veis.", efeito: "+1 Honestidade, b√¥nus com popProgressistas, pode recusar acordos pragm√°ticos." },
        "Pragm√°tico": { descricao: "Focado em resultados, custe o que custar.", efeito: "+1 Estrat√©gia, b√¥nus em negocia√ß√µes dif√≠ceis, risco de escolhas impopulares." },
        "Ambicioso": { descricao: "Busca poder e reconhecimento.", efeito: "Pode gerar eventos de consolida√ß√£o de poder, b√¥nus em a√ß√µes ousadas, risco de conflito interno." },
        "Corrupt√≠vel": { descricao: "Suscet√≠vel a ganhos il√≠citos.", efeito: "-1 Honestidade, aumenta chance de esc√¢ndalo pessoal, desbloqueia op√ß√µes 'cinzentas'." },
        "Leal": { descricao: "Valoriza aliados e compromissos.", efeito: "Melhora lealdade inicial de ministros alinhados, b√¥nus em manter coaliz√µes." },
        "Tecnocrata": { descricao: "Confia em dados e especialistas.", efeito: "+1 Estrat√©gia, b√¥nus em efici√™ncia de projetos, risco de parecer 'frio' (-Carisma impl√≠cito)." },
        "Conservador": { descricao: "Defende valores tradicionais e estabilidade.", efeito: "+1 Honestidade, b√¥nus com popReligiosos/Militares, pode resistir a mudan√ßas sociais." },
        "Liberal": { descricao: "Prioriza liberdade individual e econ√¥mica.", efeito: "+1 Estrat√©gia, b√¥nus com popEmpresarios, pode cortar gastos sociais." },
        "Progressista": { descricao: "Busca igualdade social e reformas.", efeito: "+1 Carisma, b√¥nus com popProgressistas, pode aumentar gastos p√∫blicos." },
    };

    const habilidadesDefinidas = {
        "negociador_experiente": { nome: "Negociador Experiente", descricao: "Melhora chances (+10%) em emendas e acordos (+5 rel.).", cost: 1 },
        "mestre_oratoria": { nome: "Mestre da Orat√≥ria", descricao: "+10% de b√¥nus de Carisma em discursos e debates.", cost: 1 },
        "gestor_crise": { nome: "Gestor de Crise", descricao: "Reduz o impacto negativo inicial de crises em 15%.", cost: 2 },
        "integridade_reconhecida": { nome: "Integridade Reconhecida", descricao: "Reduz chance (-20%) de esc√¢ndalos pessoais/corrup√ß√£o.", cost: 2 },
        "economista_astuto": { nome: "Economista Astuto", descricao: "+0.1% Cresc. PIB e -0.1% Infla√ß√£o passivos por rodada.", cost: 1 },
        "articulador_partidario": { nome: "Articulador Partid√°rio", descricao: "+5 de b√¥nus ao tentar melhorar rela√ß√µes com partidos.", cost: 1 },
        "diplomata_habil": { nome: "Diplomata H√°bil", descricao: "Melhora chances (+10%) de sucesso em acordos e diplomacia internacional.", cost: 1 }
    };

    const eventosFamiliares = [
        { id: "ev_filho_problema", tipo: "filho", riscoMin: 50, textoCrise: "ESC√ÇNDALO FAMILIAR! Seu filho, [NOME_FAMILIAR], foi preso por [MOTIVO_ESCANDALO]!", motivosPossiveis: ["dirigir embriagado", "briga em festa", "porte de drogas", "fraude leve"], criseAssociada: "crise_escandalo_familiar", chance: 0.5 },
        { id: "ev_conjuge_influencia", tipo: "conjuge", influencia: ["positiva", "moderada"], chance: 0.1, textoEvento: "Seu c√¥njuge, [NOME_FAMILIAR], oferece um conselho sobre a situa√ß√£o atual...", efeitoHint: { bonusTemp: { carisma: 1 }, duracao: 2 } },
        { id: "ev_parente_nomeacao", tipo: "parente_distante", chance: 0.05, textoDilema: "Um parente distante pede sua ajuda para conseguir um cargo no governo. Ele parece pouco qualificado...", dilemaAssociado: "dilema_nepotismo" } // Needs dilemma defined
    ];

    const oponentesPool = [
        { id: "op001", nome: "Deputado Silva", partidoId: "partido_centro_esquerda", personalidade: ["Agressivo", "Populista"], foco: ["Corrup√ß√£o", "Social"], taticas: ["AtaquePessoal", "FakeNewsLight"], popularidadeBase: 30 },
        { id: "op002", nome: "Senadora Lima", partidoId: "partido_liberal", personalidade: ["Calculista", "Carism√°tico"], foco: ["Economia", "Gest√£o"], taticas: ["PropostaAlternativa", "DebateTecnico", "FakeNewsSofisticada"] , popularidadeBase: 35 },
        { id: "op003", nome: "Governador Rocha", partidoId: "partido_conservador", personalidade: ["Experiente", "Moderado"], foco: ["Estabilidade", "Regional"], taticas: ["CriticaConstrutiva", "AliancasOposicao"], popularidadeBase: 25 }
    ];

    const fakeNewsTemplates = [
        { id: "fn001", tipo: "Corrup√ß√£oPessoal", texto: "FONTES AN√îNIMAS afirmam que o Presidente desviou fundos de [AREA_RECENTE] para benef√≠cio pr√≥prio!", impactoPopGeral: -3, alvoAttr: "honestidade", duracao: 4 },
        { id: "fn002", tipo: "IncompetenciaEconomica", texto: "IMAGENS VAZADAS mostrariam reuni√µes secretas do governo que levaram ao aumento recente de [INDICADOR_RUIM]!", impactoPopGrupo: { empresarios: -4, classeMedia: -3 }, duracao: 5 },
        { id: "fn003", tipo: "EscandaloFamiliarFake", texto: "Boato online sugere que [NOME_FAMILIAR] estaria envolvido em neg√≥cios il√≠citos com empresas estrangeiras.", impactoPopGeral: -2, alvoAttr: "familia", duracao: 3 },
        { id: "fn004", tipo: "AliancaSecreta", texto: "OPOSI√á√ÉO den√∫ncia acordo secreto do governo com [PAIS_RELACAO_BAIXA] que prejudicaria a soberania nacional!", impactoPopGrupo: { nacionalistas: -5 }, duracao: 4 }
    ];

    const debateQuestoes = [
        { id: "dq001", tema: "Economia", pergunta: "Sua pol√≠tica econ√¥mica levou ao aumento de [INDICADOR_RUIM]. O que o senhor diz aos milh√µes de afetados?", indicadorRuim: ["desemprego", "inflacao"] },
        { id: "dq002", tema: "Social", pergunta: "A oposi√ß√£o afirma que seus programas sociais s√£o insuficientes/exagerados. Como o senhor responde √†s cr√≠ticas sobre [PROGRAMA_SOCIAL]?", programaSocial: ["Bolsa Fam√≠lia", "Reforma Agr√°ria", "gasto social"] },
        { id: "dq003", tema: "Corrup√ß√£o", pergunta: "Diante dos recentes esc√¢ndalos envolvendo [MINISTRO_ESCANDALO || 'seu governo'], como pode garantir a honestidade de sua administra√ß√£o?" },
        { id: "dq004", tema: "Internacional", pergunta: "Sua rela√ß√£o conflituosa com [PAIS_RELACAO_BAIXA] preocupa especialistas. Qual sua estrat√©gia diplom√°tica?" },
        { id: "dq005", tema: "Seguran√ßa", pergunta: "A criminalidade em [REGIAO_ALEATORIA] est√° em alta. Quais s√£o suas propostas concretas para resolver isso?" }
    ];

    const campaignChapters = [
        { id: "cap0", title: "A Ascens√£o Inesperada", introText: "Voc√™ venceu a elei√ß√£o por uma margem apertada. O pa√≠s est√° dividido e uma crise econ√¥mica se avizinha. Seus primeiros meses ser√£o cruciais.", forcedEvents: ["d001"], endConditions: { rodadaMinGlobal: 6 }, outroText: "Os primeiros meses foram turbulentos. Agora, a oposi√ß√£o se organiza." },
        { id: "cap1", title: "Fogo Cruzado", introText: "Sua popularidade est√° em jogo enquanto a oposi√ß√£o, liderada por [NOME_OPONENTE], intensifica os ataques. Rumores de um esc√¢ndalo come√ßam a circular.", forcedEvents: ["trigger_debate", "crise_corrupcao_ministro"], endConditions: { flagSet: "escandalo_resolvido" }, outroText: "Voc√™ navegou pelo esc√¢ndalo, mas a confian√ßa foi abalada." },
    ];

    const dilemasSatira = [
        { id: "ds001", texto: "PROPOSTA: Instituir a 'Lei da Farofa Obrigat√≥ria' em todos os almo√ßos de reparti√ß√µes p√∫blicas.", tipo: "social_surreal", opcoes: [ { texto: "Aprovar! (Alegria do Sindicato dos Farofeiros)", efeitosImediatos: { popTrabalhadores: +15, popClasseMedia: -5 } }, { texto: "Rejeitar! (Absurdo! Revolta dos Nutricionistas)", efeitosImediatos: { popClasseMedia: +5, popTrabalhadores: -10 } } ] },
        { id: "ds002", texto: "Ministro da Economia sugere pagar d√≠vida externa com NFTs de capivara.", tipo: "economia_zoada", opcoes: [ { texto: "GENIAL! Mintar agora!", custoOrcamentoImediato: 50, efeitosImediatos: { tesouro: -50, chanceSucessoNFT: 0.1, chanceCriseInternacionalNFT: 0.5 } }, { texto: "Demitir o ministro imediatamente.", efeitosImediatos: { demitirMinistroPasta: "economia", popGeral: +5 } } ] }
    ];
    const eventosSatira = [ { id: "es001", texto: "Pombos com chap√©us de alum√≠nio s√£o vistos protestando em frente ao pal√°cio.", efeitos: { popGeral: -1 } } ];
    const nomesOponentesSatira = ["Doutor Evil√°zio", "Baronesa Von Trambik", "Professor Pardal"];

    const achievementsList = {
        "mandato_completo": { nome: "Primeiro Mandato", desc: "Complete seu primeiro mandato.", icon: "üèõÔ∏è" },
        "reeleito": { nome: "Reeleito!", desc: "Ven√ßa uma reelei√ß√£o.", icon: "üó≥Ô∏è" },
        "tres_mandatos": { nome: "Lenda Pol√≠tica", desc: "Complete 3 mandatos.", icon: "üëë" },
        "sobrevivente_escandalo": { nome: "Sobrevivente", desc: "Supere um esc√¢ndalo de corrup√ß√£o sem ser demitido.", icon: "üé≠" },
        "popularidade_alta": { nome: "Querido Pelo Povo", desc: "Atinja 85% de popularidade geral.", icon: "üíñ" },
        "congresso_forte": { nome: "Mestre Articulador", desc: "Atinja 75% de apoio no congresso.", icon: "ü§ù" },
        "economia_forte": { nome: "Milagre Econ√¥mico", desc: "Atinja 5% de Crescimento do PIB com Infla√ß√£o abaixo de 4%.", icon: "üìà" },
        "sem_divida": { nome: "Contas em Dia", desc: "Tenha um tesouro positivo ao final de um mandato.", icon: "üí∞" },
        "orcamento_aprovado": { nome: "Or√ßamento Aprovado", desc: "Consiga aprovar seu primeiro or√ßamento anual.", icon: "üìä" },
        "nivel_up": { nome: "Experi√™ncia Adquirida", desc: "Suba de n√≠vel como l√≠der pela primeira vez.", icon: "‚≠ê" },
        "aprovador_leis": { nome: "Legislador", desc: "Aprove 10 leis/dilemas.", icon: "üìú", required: 10 },
        "viajante": { nome: "Viajante", desc: "Realize 5 viagens presidenciais.", icon: "‚úàÔ∏è", required: 5 },
        "diplomata": { nome: "Diplomata Nato", desc: "Firme 3 tratados internacionais.", icon: "üåê", required: 3 },
        "construtor_blocos": { nome: "Arquiteto de Blocos", desc: "Entre ou forme 1 bloco econ√¥mico/militar.", icon: "üß±", required: 1 }
    };
    // --- End Static Data ---


    // --- Utility & Helper Functions --- (Defined FIRST)
    function clamp(value, min, max) { return Math.max(min, Math.min(max, Math.round(value))); }
    function capitalize(s) { if (typeof s !== 'string' || s.length === 0) return ''; return s.charAt(0).toUpperCase() + s.slice(1).toLowerCase().replace(/_/g, ' '); }
    function formatCurrency(value) { if(isNaN(value)) value = 0; return `${value >= 0 ? '' : '-'}R$ ${Math.abs(value).toLocaleString('pt-BR')} M`; }
    function formatPercent(value) { return `${(value || 0).toFixed(1)}%`; }
    function getRandomElement(arr) { if (!arr || arr.length === 0) return null; return arr[Math.floor(Math.random() * arr.length)]; }
    function truncateText(text, maxLength) { if (!text || text.length <= maxLength) return text || ""; return text.substring(0, maxLength - 3) + "..."; }
    function calcularPopularidadeGeral() { let total = 0, count = 0; if (!popularidadeGrupos) return 50; for(const k in popularidadeGrupos){ total += popularidadeGrupos[k]; count++; } return count > 0 ? clamp(Math.round(total/count), 0, 100) : 50; }
    function getGrupoKey(grupoNome) { if(!grupoNome) return ''; return grupoNome.toLowerCase().replace(/ /g, '_').replace('√ß','c').replace('√£','a').replace('√©','e'); }
    function getRegiaoKey(regiaoNome) { if(!regiaoNome) return ''; return regiaoNome.toLowerCase().replace(/-/g, '_'); }
    function getMinistroPartidoId(ministroId) { return ministrosAtivos[ministroId]?.partidoId || poolMinistros.find(m => m.id === ministroId)?.partidoId || null; }
    function getCondicaoDesc(condicao) {
         if (!condicao) return "";
         try {
            if (condicao.tipo === 'satisfacaoMidia') return `Rela√ß√£o com ${midia[condicao.midiaId]?.nome} >= ${condicao.minValor}%`;
            if (condicao.tipo === 'lealdadeMinistro') return `Lealdade do Ministro >= ${condicao.minValor}%`;
            if (condicao.tipo === 'satisfacaoMidiaGeral') return `Satisfa√ß√£o geral da M√≠dia >= ${condicao.minValor}%`;
            if (condicao.tipo === 'atributo') return `${capitalize(condicao.atributo)} do L√≠der >= ${condicao.minValor}`;
         } catch (e) { console.error("Erro ao gerar descri√ß√£o da condi√ß√£o:", e, condicao); }
         return "Condi√ß√£o espec√≠fica";
    }
    function fecharModal(modalId) { try { const modal = document.getElementById(modalId); if (modal) modal.style.display = "none"; } catch(e){ console.error("Erro ao fechar modal:", modalId, e);} }
    function fecharModalNarrativa() {
          fecharModal('modal-narrativa');
          jogoPausado = false;
          console.log("Jogo Resumed (narrativa fechada)");
          if(jogoAtivo && !jogoPausado && !eventoOrcamentoAtivo) {
               setTimeout(proximoTurno, 100);
          }
    }




/**
     * Calcula a receita estimada para a rodada atual.
     * Considera uma base, modificadores de PIB e b√¥nus de tratados/blocos.
     * @returns {number} - A receita calculada para a rodada.
     */
     function calcularReceitaAtual() {
        let receitaBase = BASE_RECEITA_POR_RODADA;

        // Modificador de Crescimento do PIB
        const pibAtual = indicadoresSociaisEconomicos.crescimentoPIB || 0;
        const bonusPIB = clamp(pibAtual * FATOR_RECEITA_PIB, -MAX_RECEITA_EXTRA_PIB / 2, MAX_RECEITA_EXTRA_PIB); // Limita b√¥nus/penalidade do PIB
        receitaBase += bonusPIB;

        // Modificadores de Tratados e Blocos (Receita)
        let bonusDiplomacia = 0;
        tratadosAtivos.forEach(t => {
            if (t.beneficios?.receitaPorRodadaMod) {
                bonusDiplomacia += t.beneficios.receitaPorRodadaMod;
            }
        });
        Object.keys(blocosAtivos).forEach(bId => {
             if (blocosAtivos[bId]?.membros?.includes("jogador") && blocos[bId]?.beneficios?.receitaPorRodadaMod) {
                 bonusDiplomacia += blocos[bId].beneficios.receitaPorRodadaMod;
             }
        });

        const receitaFinal = Math.max(10, receitaBase + bonusDiplomacia); // Garante uma receita m√≠nima
        console.log(`Receita Calculada: Base=${BASE_RECEITA_POR_RODADA.toFixed(1)}, PIB=${bonusPIB.toFixed(1)}, Diplomacia=${bonusDiplomacia.toFixed(1)} -> Total=${receitaFinal.toFixed(1)}`);
        return receitaFinal;
    }

    /**
     * Calcula a despesa estimada para a rodada atual.
     * Considera gastos alocados (ajustados pela infla√ß√£o), custos fixos,
     * custos din√¢micos (desemprego) e custos de manuten√ß√£o de tratados.
     * @returns {number} - A despesa calculada para a rodada.
     */
    function calcularDespesaAtual() {
        let despesaTotal = despesasFixasPorRodada;

        // Soma dos Gastos Alocados
        let gastoAlocadoTotal = 0;
        for (const area in orcamentoAlocado) {
            gastoAlocadoTotal += (orcamentoAlocado[area] || 0);
        }

        // Ajuste pela Infla√ß√£o (aplicado sobre o gasto alocado)
        const inflacaoAtual = indicadoresSociaisEconomicos.inflacao || 0;
        // O fator de ajuste garante que a infla√ß√£o aumente os custos. N√£o permitir defla√ß√£o reduzir custos abaixo do alocado base.
        const fatorAjusteInflacao = 1 + Math.max(0, inflacaoAtual / 100 * FATOR_CUSTO_INFLACAO);
        const gastoAlocadoAjustado = gastoAlocadoTotal * fatorAjusteInflacao;
        despesaTotal += gastoAlocadoAjustado;

        // Custos Din√¢micos - Desemprego
        const desempregoAtual = indicadoresSociaisEconomicos.desemprego || 0;
        const pontosAcimaLimiar = Math.max(0, desempregoAtual - LIMIAR_CUSTO_DESEMPREGO);
        const custoDesemprego = clamp(pontosAcimaLimiar * CUSTO_POR_PONTO_DESEMPREGO, 0, MAX_CUSTO_EXTRA_DESEMPREGO); // Limita custo extra
        despesaTotal += custoDesemprego;

        // Custos de Manuten√ß√£o de Tratados
        let custoManutencaoTratados = 0;
        tratadosAtivos.forEach(t => {
            custoManutencaoTratados += (t.custoManutencao || 0);
        });
        despesaTotal += custoManutencaoTratados;

        console.log(`Despesa Calculada: Fixa=${despesasFixasPorRodada}, Aloc=${gastoAlocadoTotal.toFixed(1)} (Ajust:${gastoAlocadoAjustado.toFixed(1)} Inf:${inflacaoAtual}%), Desemp=${custoDesemprego.toFixed(1)} (Taxa:${desempregoAtual}%), Tratados=${custoManutencaoTratados.toFixed(1)} -> Total=${despesaTotal.toFixed(1)}`);
        return despesaTotal;
    }

    /**
     * Executa o ciclo or√ßament√°rio da rodada: calcula receita, calcula despesa,
     * e atualiza o tesouro global.
     * Chamada no in√≠cio de proximoTurno.
     */
    function cicloOrcamentario() {
        console.log("--- Iniciando Ciclo Or√ßament√°rio da Rodada ---");
        const receitaDaRodada = calcularReceitaAtual();
        const despesaDaRodada = calcularDespesaAtual();
        const saldoDaRodada = Math.round(receitaDaRodada - despesaDaRodada); // Arredonda o saldo final

        // Atualiza o tesouro global
        tesouro += saldoDaRodada;

        console.log(`>>> Saldo da Rodada: ${formatCurrency(saldoDaRodada)} (Receita: ${receitaDaRodada.toFixed(1)}, Despesa: ${despesaDaRodada.toFixed(1)})`);
        console.log(`>>> Novo Tesouro: ${formatCurrency(tesouro)}`);

        // Opcional: Adicionar not√≠cia sobre super√°vit/d√©ficit significativo
        if (saldoDaRodada > (BASE_RECEITA_POR_RODADA * 0.2)) { // Ex: Super√°vit > 20% da receita base
            adicionarNoticia(`üìà Super√°vit or√ßament√°rio de ${formatCurrency(saldoDaRodada)} nesta rodada!`, "sistema", "sucesso");
        } else if (saldoDaRodada < -(BASE_RECEITA_POR_RODADA * 0.25)) { // Ex: D√©ficit > 25% da receita base
            adicionarNoticia(`üìâ D√©ficit or√ßament√°rio significativo de ${formatCurrency(Math.abs(saldoDaRodada))} nesta rodada.`, "sistema", "perigo");
        }
         // Note: N√£o chama atualizarUI() aqui, pois proximoTurno far√° isso no final.
    }


















    function findDilemmaById(id) {
        const pools = [dilemas, dilemasSatira, crises, crisesDiplomaticas, eventosFamiliares.filter(e => e.dilemaAssociado)];
        for (const pool of pools) {
            const found = pool.find(item => item.id === id || item.dilemaAssociado === id);
            if (found) return found;
        }
        if (eventosFuturosDefinidos[id] && eventosFuturosDefinidos[id].opcoes) { return eventosFuturosDefinidos[id]; }
        //console.warn("N√£o foi poss√≠vel encontrar Dilema/Crise/Evento com ID:", id); // Reduce console noise
        return null;
    }
    function resetGameVariables() {
        console.log("Resetando vari√°veis de estado do jogo...");
        congresso = 50; tesouro = ORCAMENTO_INICIAL; popularidadeGrupos = {}; apoioRegional = {}; indicadoresSociaisEconomicos = {};
        orcamentoAlocado = {}; despesasFixasPorRodada = DESPESAS_FIXAS_POR_RODADA; propostaOrcamento = null; eventoOrcamentoAtivo = false;
        liderAtual = null; lider = {}; gabinete = {}; ministrosAtivos = {}; partidos = {}; relacoesPartidos = {}; coalizao = [];
        oponentePrincipal = null; popularidadeOponente = 0; relacoesPaises = {}; blocosAtivos = {}; tratadosAtivos = [];
        rodada = 0; mandatoAtual = 1; gameMode = 'standard'; campaignState = { chapter: 0, flags: {}, isActive: false };
        eventosAgendados = []; dilemaAtual = null; emendaSugerida = false; cooldownViagem = 0; fakeNewsAtivas = []; debateAtual = null;
        pandemiaAtiva = false; regiaoEmRevolta = null; jogoAtivo = false;
        historico = {}; achievementsState = {}; localHighScores = []; notificacaoTimeout = null;
        if(evolucaoChart) { evolucaoChart.destroy(); evolucaoChart = null; }
        document.body.classList.remove('satire-mode');
        jogoPausado = false;
        console.log("Vari√°veis resetadas.");
    }


    // --- ACHIEVEMENTS --- (Defined before initialization)
    function initializeAchievements() {
        console.log("Inicializando Conquistas...");
        achievementsState = {};
        for (const id in achievementsList) {
            achievementsState[id] = { ...achievementsList[id], unlocked: false };
            if (achievementsState[id].required) { achievementsState[id].current = 0; }
        }
        console.log("Estado das conquistas inicializado.");
    }
    function checkAchievement(id) {
        if (!achievementsState || !achievementsState[id] || achievementsState[id].unlocked) return;
        const achievementDef = achievementsList[id];
        const achievementCurrent = achievementsState[id];
        let conditionMet = false;
        if (achievementDef.required) { if ((achievementCurrent.current || 0) >= achievementDef.required) conditionMet = true; }
        else {
            if (id === 'popularidade_alta' && calcularPopularidadeGeral() >= 85) conditionMet = true;
            else if (id === 'congresso_forte' && congresso >= 75) conditionMet = true;
            else if (id === 'economia_forte' && (indicadoresSociaisEconomicos.crescimentoPIB || 0) >= 5 && (indicadoresSociaisEconomicos.inflacao || 10) <= 4) conditionMet = true;
            else if (id === 'sem_divida' && tesouro > 0) conditionMet = true;
            else if (['mandato_completo', 'reeleito', 'tres_mandatos', 'sobrevivente_escandalo', 'orcamento_aprovado', 'nivel_up'].includes(id)) { conditionMet = true; }
        }
        if (conditionMet) unlockAchievement(id);
    }
    function incrementAchievementCounter(id, value = 1) {
        if (!achievementsState || !achievementsState[id] || achievementsState[id].unlocked || !achievementsList[id].required) return;
        if (achievementsState[id].current === undefined) achievementsState[id].current = 0;
        achievementsState[id].current += value;
        console.log(`Contador da conquista '${id}' incrementado para: ${achievementsState[id].current}`);
        checkAchievement(id);
    }
    function unlockAchievement(id) {
         if (!achievementsState || !achievementsState[id] || achievementsState[id].unlocked) return;
         achievementsState[id].unlocked = true;
         const achievement = achievementsList[id];
         mostrarNotificacaoConquista(achievement);
         console.log("Conquista Desbloqueada:", achievement.nome);
    }
    function mostrarNotificacaoConquista(achievement) {
         const notificacao = document.getElementById('notificacao-conquista');
         if(!notificacao) return;
         document.getElementById('achievement-icon').innerText = achievement.icon || 'üèÜ';
         document.getElementById('achievement-name').innerText = achievement.nome;
         notificacao.classList.add('show');
         if (notificacaoTimeout) clearTimeout(notificacaoTimeout);
         notificacaoTimeout = setTimeout(() => { notificacao.classList.remove('show'); notificacaoTimeout = null; }, 4000);
    }
    function checkAllAchievements() {
        if (!achievementsState || !jogoAtivo) return;
        checkAchievement('popularidade_alta');
        checkAchievement('congresso_forte');
        checkAchievement('economia_forte');
        if (tesouro > 0) checkAchievement('sem_divida');
    }
    function mostrarModalConquistas() {
         const lista = document.getElementById("lista-conquistas");
         if(!lista) return;
         lista.innerHTML = '';
         if (!achievementsState || Object.keys(achievementsState).length === 0) initializeAchievements();
         if (Object.keys(achievementsState).length === 0) { lista.innerHTML = '<p>Erro ao carregar conquistas.</p>'; return; }
         const sortedIds = Object.keys(achievementsState).sort((a, b) => {
             if (achievementsState[a].unlocked !== achievementsState[b].unlocked) return achievementsState[b].unlocked - achievementsState[a].unlocked;
             return achievementsList[a].nome.localeCompare(achievementsList[b].nome);
         });
         sortedIds.forEach(id => {
             const ach = achievementsState[id]; const def = achievementsList[id]; if(!def) return;
             const li = document.createElement("li"); li.className = 'conquista-item'; li.style.opacity = ach.unlocked ? 1 : 0.6;
             let progress = ''; if (def.required && !ach.unlocked) { progress = ` (${ach.current || 0}/${def.required})`; }
             li.innerHTML = `<div style="display: flex; align-items: center;"><span style="font-size: 1.5em; margin-right: 10px; width: 30px; text-align: center;">${def.icon || '‚ùì'}</span><div><strong>${def.nome}</strong>${progress}<br><small>${def.desc}</small></div></div>`;
             lista.appendChild(li);
         });
         document.getElementById("modal-conquistas").style.display = "block";
    }

    // --- HIGH SCORES (Local) --- (Defined before onload)
    function calculateScore() { let score = (mandatoAtual - 1) * 5000; score += calcularPopularidadeGeral() * 50; score += congresso * 30; score += Math.max(0, Math.round(tesouro / 5)); score += (lider?.nivel || 1) * 150; score += Object.values(achievementsState || {}).filter(a => a.unlocked).length * 250; if (tesouro < -500) score -= 2000; return Math.max(0, Math.round(score)); }
    function loadHighScores() { try { const scores = localStorage.getItem(HIGHSCORE_KEY); return scores ? JSON.parse(scores) : []; } catch (e) { console.error("Error loading high scores:", e); return []; } }
    function saveHighScore() { const score = calculateScore(); localHighScores = loadHighScores(); const lowestHighScore = localHighScores.length < MAX_HIGH_SCORES ? 0 : (localHighScores[MAX_HIGH_SCORES - 1]?.score || 0); if (score > lowestHighScore) { const playerName = prompt(`Nova Pontua√ß√£o Alta: ${score}! Digite seu nome (3-10 chars):`, lider?.nome || "Presidente"); if (playerName && playerName.trim().length >= 3 && playerName.trim().length <= 10) { const newEntry = { nome: playerName.trim(), score, mandates: mandatoAtual -1, pop: calcularPopularidadeGeral(), cong: congresso, date: new Date().toLocaleDateString('pt-BR') }; localHighScores.push(newEntry); localHighScores.sort((a, b) => b.score - a.score); localHighScores = localHighScores.slice(0, MAX_HIGH_SCORES); try { localStorage.setItem(HIGHSCORE_KEY, JSON.stringify(localHighScores)); adicionarNoticia(`üèÜ Pontua√ß√£o ${score} salva para ${playerName}!`, "sistema", "sucesso"); displayHighScores(); document.getElementById("modal-highscores").style.display = "block"; } catch (e) { console.error("Error saving high scores:", e); alert("Erro ao salvar a pontua√ß√£o."); } } else { alert("Nome inv√°lido ou cancelado, pontua√ß√£o n√£o salva."); } } else { console.log("Score n√£o foi alto o suficiente para o ranking."); } }
    function displayHighScores() { const lista = document.getElementById("lista-highscores"); if (!lista) return; lista.innerHTML = ''; localHighScores = loadHighScores(); if (localHighScores.length === 0) { lista.innerHTML = "<li>Nenhuma pontua√ß√£o registrada ainda.</li>"; return; } localHighScores.forEach((entry, index) => { const li = document.createElement("li"); li.className = 'highscore-item'; li.innerHTML = `<span><strong>${index + 1}. ${entry.nome}</strong> - ${entry.score.toLocaleString('pt-BR')} pts</span> <small>(${entry.mandates} M, Pop: ${entry.pop}%, Cong: ${entry.cong}%, ${entry.date || '?'})</small>`; lista.appendChild(li); }); }
    function mostrarModalHighScores() { displayHighScores(); document.getElementById("modal-highscores").style.display = "block"; }

    // --- SAVE / LOAD --- (Defined before initialization)
    function gatherGameState() { console.log("Gathering game state for saving..."); return { congresso, tesouro, popularidadeGrupos: JSON.parse(JSON.stringify(popularidadeGrupos)), apoioRegional: JSON.parse(JSON.stringify(apoioRegional)), indicadoresSociaisEconomicos: JSON.parse(JSON.stringify(indicadoresSociaisEconomicos)), orcamentoAlocado: JSON.parse(JSON.stringify(orcamentoAlocado)), despesasFixasPorRodada, propostaOrcamento: JSON.parse(JSON.stringify(propostaOrcamento)), eventoOrcamentoAtivo, liderAtual: JSON.parse(JSON.stringify(liderAtual)), lider: JSON.parse(JSON.stringify(lider)), gabinete: JSON.parse(JSON.stringify(gabinete)), ministrosAtivos: JSON.parse(JSON.stringify(ministrosAtivos)), partidos: JSON.parse(JSON.stringify(partidos)), relacoesPartidos: JSON.parse(JSON.stringify(relacoesPartidos)), coalizao: JSON.parse(JSON.stringify(coalizao)), oponentePrincipal: JSON.parse(JSON.stringify(oponentePrincipal)), popularidadeOponente, relacoesPaises: JSON.parse(JSON.stringify(relacoesPaises)), blocosAtivos: JSON.parse(JSON.stringify(blocosAtivos)), tratadosAtivos: JSON.parse(JSON.stringify(tratadosAtivos)), rodada, mandatoAtual, gameMode, campaignState: JSON.parse(JSON.stringify(campaignState)), eventosAgendados: JSON.parse(JSON.stringify(eventosAgendados)), dilemaAtual: JSON.parse(JSON.stringify(dilemaAtual)), emendaSugerida, cooldownViagem, fakeNewsAtivas: JSON.parse(JSON.stringify(fakeNewsAtivas)), debateAtual: JSON.parse(JSON.stringify(debateAtual)), pandemiaAtiva, regiaoEmRevolta, jogoAtivo, jogoPausado, historico: JSON.parse(JSON.stringify(historico)), achievementsState: JSON.parse(JSON.stringify(achievementsState)) }; }
    function saveGame() { if (!jogoAtivo) { console.log("Jogo n√£o ativo, n√£o salvando."); return; } console.log("Tentando salvar jogo..."); try { const gameState = gatherGameState(); if (!gameState.liderAtual) throw new Error("Estado inv√°lido para salvar (sem l√≠der)."); localStorage.setItem(SAVE_KEY, JSON.stringify(gameState)); console.log("Jogo Salvo!"); adicionarNoticia("‚öôÔ∏è Jogo salvo com sucesso!", "sistema", "sucesso"); } catch (error) { console.error("Erro ao salvar jogo:", error); adicionarNoticia("‚ö†Ô∏è Erro ao salvar o jogo! Verifique o console.", "sistema", "perigo"); } }
    function loadGame() { console.log("Tentando carregar jogo..."); const savedDataString = localStorage.getItem(SAVE_KEY); if (!savedDataString) { console.log("Nenhum jogo salvo encontrado."); return false; } try { const loadedState = JSON.parse(savedDataString); console.log("Dados salvos encontrados, restaurando estado..."); if (!loadedState.liderAtual || !loadedState.lider || !loadedState.partidos) { throw new Error("Save data parece corrompido."); }
        // Restore state
        congresso = loadedState.congresso; tesouro = loadedState.tesouro; popularidadeGrupos = loadedState.popularidadeGrupos; apoioRegional = loadedState.apoioRegional; indicadoresSociaisEconomicos = loadedState.indicadoresSociaisEconomicos;
        orcamentoAlocado = loadedState.orcamentoAlocado; despesasFixasPorRodada = loadedState.despesasFixasPorRodada; propostaOrcamento = loadedState.propostaOrcamento; eventoOrcamentoAtivo = loadedState.eventoOrcamentoAtivo;
        liderAtual = loadedState.liderAtual; lider = loadedState.lider; gabinete = loadedState.gabinete; ministrosAtivos = loadedState.ministrosAtivos; partidos = loadedState.partidos; relacoesPartidos = loadedState.relacoesPartidos;
        coalizao = loadedState.coalizao; oponentePrincipal = loadedState.oponentePrincipal; popularidadeOponente = loadedState.popularidadeOponente;
        relacoesPaises = loadedState.relacoesPaises; blocosAtivos = loadedState.blocosAtivos; tratadosAtivos = loadedState.tratadosAtivos;
        rodada = loadedState.rodada; mandatoAtual = loadedState.mandatoAtual; gameMode = loadedState.gameMode; campaignState = loadedState.campaignState;
        eventosAgendados = loadedState.eventosAgendados || []; dilemaAtual = loadedState.dilemaAtual; emendaSugerida = loadedState.emendaSugerida;
        cooldownViagem = loadedState.cooldownViagem; fakeNewsAtivas = loadedState.fakeNewsAtivas || []; debateAtual = loadedState.debateAtual;
        pandemiaAtiva = loadedState.pandemiaAtiva; regiaoEmRevolta = loadedState.regiaoEmRevolta;
        jogoAtivo = loadedState.jogoAtivo; jogoPausado = loadedState.jogoPausado;
        historico = loadedState.historico || {}; achievementsState = loadedState.achievementsState || {};
        if (!achievementsState || Object.keys(achievementsState).length === 0) initializeAchievements();
        if (!historico.rodadas) historico = { rodadas: [], congresso: [], tesouro: [], liderNivel: [], popularidadeGrupos: {}, indicadores: {} };

        if (gameMode === 'satire') { document.body.classList.add('satire-mode'); } else { document.body.classList.remove('satire-mode'); }

        jogoAtivo = true;
        document.getElementById("tela-modo-jogo").style.display = "none"; document.getElementById("inicio").style.display = "none"; document.getElementById("ministros-inicial").style.display = "none"; document.getElementById("jogo").style.display = "block"; document.getElementById("fim-jogo").style.display = "none";

        setupChart();

        if (eventoOrcamentoAtivo) { iniciarEventoOrcamentoAnual(); }
        else if (dilemaAtual && dilemaAtual.id) { const dilemmaData = findDilemmaById(dilemaAtual.id); if (dilemmaData) { const isCrisis = crises.some(c => c.id === dilemmaData.id) || crisesDiplomaticas.some(c => c.id === dilemmaData.id); reapresentarDilema(dilemmaData, isCrisis); } else { console.warn("Dilema salvo n√£o encontrado:", dilemaAtual.id); dilemaAtual = null; } }
        else { document.getElementById("titulo-dilema").innerText = "Pr√≥xima A√ß√£o"; document.getElementById("dilema-texto").innerText = "Jogo carregado. Aguardando..."; document.getElementById("painel-opcoes").innerHTML = ''; }

        adicionarNoticia("‚öôÔ∏è Jogo carregado com sucesso!", "sistema", "sucesso");
        calcularApoioCongresso();
        atualizarUI();
        return true;
    } catch (error) { console.error("Erro CR√çTICO ao carregar jogo:", error); localStorage.removeItem(SAVE_KEY); alert("Erro fatal ao carregar o jogo salvo. O save foi removido. Por favor, inicie um novo jogo."); reiniciarJogo(); return false; } }
    function loadGameWrapper() { if (!loadGame()) { const btn = document.getElementById('btn-continuar-jogo'); if (btn) btn.style.display = 'none'; } else { const btn = document.getElementById('tela-inicial-botoes'); if(btn) btn.style.display = 'none'; } }

    // --- PDF EXPORT ---
    function generatePDFReport() { console.log("Gerando relat√≥rio PDF..."); if (typeof jspdf === 'undefined') { alert("Erro: Biblioteca jsPDF n√£o carregada."); return; } const { jsPDF } = window.jspdf; const doc = new jsPDF(); let yPos = 15; const MARGIN = 15; const MAX_WIDTH = doc.internal.pageSize.getWidth() - 2 * MARGIN; function addText(text, size, align = 'left', weight = 'normal', x = MARGIN) { if (yPos > 275) { doc.addPage(); yPos = MARGIN; } doc.setFontSize(size); doc.setFont('helvetica', weight); let textX = x; if(align === 'center') textX = doc.internal.pageSize.getWidth() / 2; else if(align === 'right') textX = doc.internal.pageSize.getWidth() - MARGIN; const splitText = doc.splitTextToSize(text, MAX_WIDTH - (x > MARGIN ? x - MARGIN : 0)); doc.text(splitText, textX, yPos, { align: align }); yPos += (splitText.length * (size * 0.35)) + 2; } function addLine() { if (yPos > 270) { doc.addPage(); yPos = MARGIN; } doc.setDrawColor(150); doc.line(MARGIN, yPos, doc.internal.pageSize.getWidth() - MARGIN, yPos); yPos += 4; }
        addText("Relat√≥rio Presidencial", 18, 'center', 'bold'); yPos += 5;
        addText(`Modo de Jogo: ${capitalize(gameMode)}`, 12); addText(`L√≠der: ${liderAtual?.tipo || 'N/A'} (${partidos[liderAtual?.partidoId]?.nome?.replace(" (Seu)","") || 'N/A'})`, 12); addText(`Mandatos Completos: ${mandatoAtual - 1} | Rodadas Totais: ${(mandatoAtual - 1) * RODADAS_PER_MANDATO + rodada}`, 12); yPos += 5; addLine();
        addText("Estat√≠sticas Finais", 14, 'left', 'bold'); addText(`- Pontua√ß√£o Final: ${calculateScore().toLocaleString('pt-BR')}`, 10); addText(`- Popularidade Geral (M√©dia): ${calcularPopularidadeGeral()}%`, 10); addText(`- Apoio no Congresso: ${congresso}%`, 10); addText(`- Tesouro: ${formatCurrency(tesouro)}`, 10); yPos += 5;
        addText("Indicadores Socioecon√¥micos Finais", 12, 'left', 'bold'); for (const ind in indicadoresSociaisEconomicos) { addText(`  * ${capitalize(ind)}: ${indicadoresSociaisEconomicos[ind]}${['inflacao', 'desemprego', 'crescimentoPIB'].includes(ind) ? '%' : ''}`, 10, 'left', 'normal', MARGIN + 5); } yPos += 5; addLine();
        addText("Gabinete Final", 14, 'left', 'bold'); for (const area in gabinete) { const ministroId = gabinete[area]; const ministro = ministroId ? (ministrosAtivos[ministroId] || poolMinistros.find(m => m.id === ministroId)) : null; addText(`- ${capitalize(area)}: ${ministro ? ministro.nome : 'Vago'}`, 10); } yPos += 5; addLine();
        addText("Hist√≥rico Resumido (In√≠cio -> Fim)", 14, 'left', 'bold'); if(historico && historico.rodadas && historico.rodadas.length > 0) { const startIdx = 0; const endIdx = historico.rodadas.length - 1; addText(`Rodadas: ${historico.rodadas[startIdx]} a ${historico.rodadas[endIdx]}`, 10); addText(`Congresso: ${historico.congresso?.[startIdx]}% -> ${historico.congresso?.[endIdx]}%`, 10); const trabKey = getGrupoKey("Trabalhadores"); addText(`Pop. Trab.: ${historico.popularidadeGrupos?.[trabKey]?.[startIdx]}% -> ${historico.popularidadeGrupos?.[trabKey]?.[endIdx]}%`, 10); addText(`Cresc. PIB: ${historico.indicadores?.crescimentoPIB?.[startIdx]}% -> ${historico.indicadores?.crescimentoPIB?.[endIdx]}%`, 10); addText(`Tesouro: ${formatCurrency(historico.tesouro?.[startIdx])} -> ${formatCurrency(historico.tesouro?.[endIdx])}`, 10); } else { addText("Hist√≥rico n√£o dispon√≠vel.", 10); } yPos += 5; addLine();
        addText("Conquistas Desbloqueadas", 14, 'left', 'bold'); let unlockedCount = 0; for(const id in achievementsState) { if(achievementsState[id].unlocked) { const def = achievementsList[id]; addText(`${def.icon || 'üèÜ'} ${def.nome}`, 10, 'left', 'normal', MARGIN + 5); unlockedCount++; } } if(unlockedCount === 0) addText("Nenhuma conquista desbloqueada.", 10, 'left', 'normal', MARGIN + 5);
        doc.save(`Relatorio_${liderAtual?.tipo || 'Presidencial'}_${new Date().toISOString().slice(0,10)}.pdf`); adicionarNoticia("üìÑ Relat√≥rio PDF gerado!", "sistema", "sucesso");
    }

    // --- UI Update Functions --- (Defined before use in game loop/init)
    function atualizarUI() {
        // --- 1. Safety Check ---
        if (!jogoAtivo || !liderAtual) {
            // Don't try to update if the game isn't actively running or leader isn't set
            // console.warn("atualizarUI skipped: Jogo n√£o ativo ou l√≠der n√£o definido.");
            return;
        }

        // Add a slight delay or throttle if updates become too frequent? For now, direct call.
        // console.log("--- Atualizando UI ---"); // Can be noisy, uncomment if debugging needed

        try { // Wrap major updates in try-catch

            // --- 2. Update Header Info ---
            const elTipoLider = document.getElementById("tipoLider");
            if (elTipoLider && liderAtual && partidos[liderAtual.partidoId]) {
                elTipoLider.innerText = `L√≠der: ${liderAtual.tipo} (${partidos[liderAtual.partidoId].nome})`;
            }
            const elMandatoInfo = document.getElementById("mandatoInfo");
            if (elMandatoInfo) {
                elMandatoInfo.innerText = `Mandato: ${mandatoAtual} / Rodada: ${rodada}`;
            }

            // --- 3. Call Specific Panel Update Functions ---
            atualizarPainelLider();
            atualizarPainelIndicadores();
            // For budget, recalculate the values to pass them
            const receitaCalc = calcularReceitaAtual();
            const despesaCalc = calcularDespesaAtual();
            atualizarPainelOrcamento(receitaCalc, despesaCalc, receitaCalc - despesaCalc);
            atualizarPainelApoioGrupos();
            atualizarPainelApoioRegional();
            atualizarPainelCongresso();
            atualizarPainelOposicao();
            atualizarPainelMundo();
            // Note: News feed (#lista-manchetes) is updated by adicionarNoticia, not here directly

            // --- 4. Update General Button States ---
            // Travel Button
            const btnViagem = document.getElementById("botao-viagem");
            if (btnViagem) {
                btnViagem.disabled = cooldownViagem > 0 || tesouro < CUSTO_VIAGEM || jogoPausado || eventoOrcamentoAtivo || debateAtual;
                btnViagem.innerText = cooldownViagem > 0 ? `Viagem (${cooldownViagem})` : 'Viagem Presidencial';
                btnViagem.title = btnViagem.disabled ? (cooldownViagem > 0 ? `Aguarde ${cooldownViagem}r` : (tesouro < CUSTO_VIAGEM ? "Or√ßamento baixo" : "Indispon√≠vel agora")) : "";
            }

            // Amend Button (Visibility handled by apresentarDilema, just handle disabled state)
            const btnEmendar = document.getElementById("botao-emendar");
            if (btnEmendar && btnEmendar.style.display !== 'none') {
                 btnEmendar.disabled = emendaSugerida || tesouro < 15 || jogoPausado || eventoOrcamentoAtivo || debateAtual; // Example cost 15
                 btnEmendar.innerText = emendaSugerida ? "Emenda Sugerida" : "Sugerir Emenda";
                 btnEmendar.title = btnEmendar.disabled ? (emendaSugerida ? "J√° negociada" : (tesouro < 15 ? "Custo alto" : "Indispon√≠vel agora")) : "";
            }

            // Budget Button (Visibility handled by proximoTurno, just ensure state consistency)
            const btnOrcamento = document.getElementById("botao-orcamento");
             if (btnOrcamento) {
                 btnOrcamento.style.display = eventoOrcamentoAtivo ? 'inline-block' : 'none';
                  // Disable other action buttons if budget event is active
                  if(btnViagem) btnViagem.disabled = btnViagem.disabled || eventoOrcamentoAtivo;
                  if(btnEmendar) btnEmendar.disabled = btnEmendar.disabled || eventoOrcamentoAtivo;
                  // Disable main dilemma choice buttons too?
                  document.querySelectorAll('#painel-opcoes .botao').forEach(btn => { btn.disabled = eventoOrcamentoAtivo; });
             }


            // Level Up Button (Visibility/State handled in atualizarPainelLider)


            // --- 5. Update Chart ---
            if (evolucaoChart && historico.rodadas && historico.rodadas.length > 0) {
                try {
                    evolucaoChart.data.labels = historico.rodadas;
                    evolucaoChart.data.datasets.forEach(dataset => {
                        const labelLower = dataset.label.toLowerCase();
                        if (labelLower === 'congresso') dataset.data = historico.congresso;
                        else if (labelLower.startsWith('pop:')) {
                            const grupoKey = getGrupoKey(labelLower.substring(5).trim().replace('.', ''));
                            if (historico.popularidadeGrupos[grupoKey]) dataset.data = historico.popularidadeGrupos[grupoKey];
                        } else if (labelLower.includes('tesouro')) dataset.data = historico.tesouro;
                        else if (labelLower.includes('infla√ß√£o')) dataset.data = historico.indicadores?.inflacao || [];
                        else if (labelLower.includes('desemprego')) dataset.data = historico.indicadores?.desemprego || [];
                        else if (labelLower.includes('cresc. pib')) dataset.data = historico.indicadores?.crescimentoPIB || [];
                        // Map other datasets if added
                    });
                    evolucaoChart.update('none'); // Use 'none' to prevent distracting animations during frequent updates
                } catch (chartError) {
                     console.error("Erro ao atualizar o gr√°fico:", chartError);
                     // Optionally destroy and recreate chart if update fails repeatedly
                }
            } else if (!evolucaoChart && document.getElementById('evolucaoChart')) {
                 // Try to set up chart if it doesn't exist but canvas does (e.g., after load game error?)
                 console.log("Tentando configurar o gr√°fico novamente...");
                 setupChart();
            }

            // console.log("--- UI Atualizada ---"); // Reduce console noise

        } catch (uiError) {
             console.error("!!! ERRO GERAL DURANTE ATUALIZAR UI !!!", uiError);
             // Display error to user? Stop game?
             // alert("Erro ao atualizar a interface. Verifique o console.");
             // jogoAtivo = false; // Consider stopping game if UI update fails badly
        }
    }

    function atualizarPainelLider() {
        // --- 1. Safety Check & Get Elements ---
        if (!lider || !lider.atributos) {
            // console.warn("atualizarPainelLider skipped: Leader data not available.");
            return; // Don't update if leader object isn't initialized
        }

        const painelAtributos = document.getElementById("lider-atributos");
        const spanTracos = document.getElementById("lider-tracos");
        const spanNivel = document.getElementById("lider-nivel");
        const spanXP = document.getElementById("lider-xp");
        const spanXPMax = document.getElementById("lider-xp-max");
        const spanHabilidades = document.getElementById("lider-habilidades");
        const spanPontos = document.getElementById("lider-pontos");
        const btnLevelUp = document.getElementById("botao-levelup");

        // Check if all elements were found
        if (!painelAtributos || !spanTracos || !spanNivel || !spanXP || !spanXPMax || !spanHabilidades || !spanPontos || !btnLevelUp) {
            console.error("Erro: Um ou mais elementos do Painel do L√≠der n√£o foram encontrados no HTML.");
            return;
        }

        // --- 2. Update Attributes ---
        painelAtributos.innerHTML = ''; // Clear previous attributes
        for (const atr in lider.atributos) {
            // Make sure the value is a number, default to 0 if not
            const value = Number(lider.atributos[atr]) || 0;
            painelAtributos.innerHTML += `
                <div class="lider-attr-item">
                    <span class="lider-attr-label">${capitalize(atr)}:</span>
                    <span class="lider-attr-valor">${clamp(value, 1, 10)}/10</span>
                </div>`;
        }

        // --- 3. Update Traits ---
        spanTracos.innerText = lider.tracos?.join(', ') || 'Nenhum';

        // --- 4. Update Level & XP ---
        const nivelAtual = lider.nivel || 1;
        const xpAtual = lider.experiencia || 0;
        const xpNecessario = nivelAtual * 15 + 10; // Use the same formula as checkLevelUp
        spanNivel.innerText = nivelAtual;
        spanXP.innerText = xpAtual;
        spanXPMax.innerText = xpNecessario;

        // --- 5. Update Skills ---
        spanHabilidades.innerText = lider.habilidades?.length > 0
            ? lider.habilidades.map(hId => habilidadesDefinidas[hId]?.nome || capitalize(hId)).join(', ')
            : 'Nenhuma';

        // --- 6. Update Skill Points & Button ---
        const pontosDisponiveis = lider.pontosHabilidade || 0;
        spanPontos.innerText = pontosDisponiveis;
        btnLevelUp.style.display = pontosDisponiveis > 0 ? 'inline-block' : 'none';
        btnLevelUp.disabled = pontosDisponiveis <= 0; // Ensure button is disabled if no points

    }
    
    function atualizarPainelIndicadores() {
        // --- 1. Safety Check & Get Elements ---
        if (!indicadoresSociaisEconomicos) {
            // console.warn("atualizarPainelIndicadores skipped: Indicator data not available.");
            return; // Don't update if indicator object isn't initialized
        }

        const listaIndicadores = document.getElementById("lista-indicadores");
        if (!listaIndicadores) {
            console.error("Erro: Elemento #lista-indicadores n√£o encontrado no HTML.");
            return;
        }

        // --- 2. Clear Previous Content ---
        listaIndicadores.innerHTML = '';

        // --- 3. Iterate and Populate ---
        // Define desired order if necessary
        const order = ['crescimentoPIB', 'inflacao', 'desemprego', 'dividaPublica', 'saude', 'educacao', 'criminalidade'];
        const indicatorsToDisplay = order.filter(key => indicadoresSociaisEconomicos.hasOwnProperty(key));
        // Add any remaining indicators not in the defined order
        Object.keys(indicadoresSociaisEconomicos).forEach(ind => {
            if (!indicatorsToDisplay.includes(ind)) {
                 indicatorsToDisplay.push(ind);
            }
        });


        indicatorsToDisplay.forEach(ind => {
            const value = indicadoresSociaisEconomicos[ind];
            let formattedValue = value?.toLocaleString('pt-BR', { maximumFractionDigits: 1 }) || '0'; // Format numbers
            let trendClass = 'valor-neutro'; // Default: neutral color

            // Apply specific formatting and color coding based on indicator type
            // (These thresholds are examples and should be balanced)
            switch (ind) {
                case 'crescimentoPIB':
                    formattedValue = formatPercent(value);
                    if (value > 3.0) trendClass = 'valor-positivo';
                    else if (value < 0.5) trendClass = 'valor-negativo';
                    break;
                case 'inflacao':
                    formattedValue = formatPercent(value);
                    if (value > 7.0) trendClass = 'valor-negativo'; // High inflation is bad
                    else if (value < 1.5) trendClass = 'valor-negativo'; // Deflation can also be bad
                    else if (value >= 2.0 && value <= 4.0) trendClass = 'valor-positivo'; // Target range
                    break;
                case 'desemprego':
                    formattedValue = formatPercent(value);
                    if (value > 10.0) trendClass = 'valor-negativo'; // High unemployment is bad
                    else if (value < 4.0) trendClass = 'valor-positivo'; // Very low is good
                    break;
                case 'dividaPublica':
                    formattedValue = formatPercent(value); // Assuming % of GDP
                    if (value > 75.0) trendClass = 'valor-negativo'; // Very high debt is bad
                    else if (value < 40.0) trendClass = 'valor-positivo'; // Low is generally good
                    break;
                case 'saude':
                case 'educacao':
                    formattedValue = value?.toFixed(0); // Index 0-100
                    if (value > 70) trendClass = 'valor-positivo'; // High index is good
                    else if (value < 45) trendClass = 'valor-negativo'; // Low index is bad
                    break;
                case 'criminalidade':
                    formattedValue = value?.toFixed(0); // Index 0-100
                    if (value > 65) trendClass = 'valor-negativo'; // High crime index is bad
                    else if (value < 35) trendClass = 'valor-positivo'; // Low crime index is good
                    break;
                default:
                    // Default formatting for unknown indicators
                     if (typeof value === 'number') formattedValue = value.toFixed(1);
                     else formattedValue = String(value);
                    break;
            }

            // Create and append the list item
            const div = document.createElement('div');
            div.className = 'indicador-item';
            div.innerHTML = `
                <span class="indicador-label">${capitalize(ind)}:</span>
                <span class="indicador-valor ${trendClass}">${formattedValue}</span>
            `;
            listaIndicadores.appendChild(div);
        }); // End forEach indicator
    }
    
    function atualizarPainelOrcamento(receitaCalc = 0, despesaCalc = 0, saldoCalc = 0) {
        // --- 1. Safety Check & Get Elements ---
        if (orcamentoAlocado === undefined || tesouro === undefined) { // Check basic state exists
            // console.warn("atualizarPainelOrcamento skipped: Budget data not available.");
            return;
        }

        const listaOrcamento = document.getElementById("lista-orcamento");
        if (!listaOrcamento) {
            console.error("Erro: Elemento #lista-orcamento n√£o encontrado no HTML.");
            return;
        }

        // --- 2. Format Passed Values & Treasury ---
        const tesouroFormatted = formatCurrency(tesouro);
        const receitaFormatted = formatCurrency(receitaCalc);
        const despesaFormatted = formatCurrency(despesaCalc);
        const saldoFormatted = formatCurrency(saldoCalc);

        // --- 3. Generate HTML for Allocated Spending ---
        let alocacaoHTML = '<hr><p style="margin: 5px 0 3px 0;"><strong>Gasto Alocado (/rodada):</strong></p>';
        let totalAlocado = 0;
        // Use defined order for consistency
        AREAS_ORCAMENTO.forEach(area => {
            // Get value, default to 0 if area doesn't exist in current allocation (e.g., after loading old save)
            const valor = orcamentoAlocado[area] || 0;
            alocacaoHTML += `
                <div class="indicador-item" style="font-size: 0.85em; padding-bottom: 1px; border: none;">
                    <span class="indicador-label">${capitalize(area)}:</span>
                    <span class="indicador-valor">${formatCurrency(valor)}</span>
                </div>`;
            totalAlocado += valor;
        });
        // Add any areas present in orcamentoAlocado but not in AREAS_ORCAMENTO (less likely but safe)
        for (const area in orcamentoAlocado) {
            if (!AREAS_ORCAMENTO.includes(area)) {
                 const valor = orcamentoAlocado[area] || 0;
                 alocacaoHTML += `
                     <div class="indicador-item" style="font-size: 0.85em; padding-bottom: 1px; border: none; color: #aaa;"> <!-- Style differently? -->
                         <span class="indicador-label">${capitalize(area)} (?):</span>
                         <span class="indicador-valor">${formatCurrency(valor)}</span>
                      </div>`;
                 totalAlocado += valor;
            }
        }


        // Display Total Allocated and Fixed Costs
        alocacaoHTML += `
            <div class="indicador-item" style="font-size: 0.9em; padding-top: 3px; border-top: 1px solid #555; margin-top: 3px;">
                <span class="indicador-label"><strong>Subtotal Alocado:</strong></span>
                <span class="indicador-valor"><strong>${formatCurrency(totalAlocado)}</strong></span>
            </div>
            <div class="indicador-item" style="font-size: 0.85em; padding-bottom: 1px; border: none;">
                <span class="indicador-label">Custos Fixos:</span>
                <span class="indicador-valor">${formatCurrency(despesasFixasPorRodada)}</span>
            </div>`;
            // Add display for dynamic costs like unemployment if calculated separately?
            // const dynamicCosts = despesaCalc - totalAlocado - despesasFixasPorRodada; // Approximate dynamic
            // alocacaoHTML += `<div><span>Custos Din√¢micos (Est.):</span><span>${formatCurrency(dynamicCosts)}</span></div>`;

        // --- 4. Update Panel HTML ---
        listaOrcamento.innerHTML = `
            <div class="indicador-item">
                <span class="indicador-label">Tesouro Atual:</span>
                <span class="indicador-valor ${tesouro < 0 ? 'valor-negativo' : 'valor-positivo'}">${tesouroFormatted}</span>
            </div>
            <hr>
            <p style="margin: 5px 0 3px 0;"><strong>Proje√ß√£o Pr√≥x. Rodada:</strong></p>
            <div class="indicador-item">
                <span class="indicador-label">Receita Estimada:</span>
                <span class="indicador-valor">${receitaFormatted}</span>
            </div>
            <div class="indicador-item">
                <span class="indicador-label">Despesa Estimada*:</span>
                <span class="indicador-valor">${despesaFormatted}</span>
            </div>
            <div class="indicador-item">
                <span class="indicador-label">Saldo Estimado:</span>
                <span class="indicador-valor ${saldoCalc < 0 ? 'valor-negativo' : 'valor-positivo'}">${saldoFormatted}</span>
            </div>
            ${alocacaoHTML}
            <small style="display: block; text-align: right; margin-top: 5px; color: #aaa;">* Despesa estimada inclui infla√ß√£o, custos fixos e din√¢micos.</small>
        `;
    }
    
    function atualizarPainelApoioGrupos() {
        // --- 1. Safety Check & Get Elements ---
        if (!popularidadeGrupos || Object.keys(popularidadeGrupos).length === 0) {
            // If GRUPOS_POPULACAO is defined but popularidadeGrupos isn't populated yet (early init issue?)
            if(typeof GRUPOS_POPULACAO !== 'undefined' && GRUPOS_POPULACAO.length > 0 && (!popularidadeGrupos || Object.keys(popularidadeGrupos).length === 0)) {
                console.warn("PopularidadeGrupos vazio, tentando inicializar...");
                popularidadeGrupos = {};
                GRUPOS_POPULACAO.forEach(g => popularidadeGrupos[getGrupoKey(g)] = 50);
            } else {
                // console.warn("atualizarPainelApoioGrupos skipped: Group popularity data not available.");
                 return; // Don't update if group data isn't initialized
            }
        }

        const listaApoioGrupos = document.getElementById("lista-apoio-grupos");
        if (!listaApoioGrupos) {
            console.error("Erro: Elemento #lista-apoio-grupos n√£o encontrado no HTML.");
            return;
        }

        // --- 2. Clear Previous Content ---
        listaApoioGrupos.innerHTML = '';

        // --- 3. Iterate and Populate ---
        // Use defined order if necessary, otherwise iterate through the state object
        const groupsToDisplay = GRUPOS_POPULACAO.map(g => getGrupoKey(g)); // Get keys in defined order

        groupsToDisplay.forEach(grupoKey => {
            // Ensure the group exists in the current state, default to 50 if missing
            const value = popularidadeGrupos[grupoKey] !== undefined ? popularidadeGrupos[grupoKey] : 50;
            let trendClass = 'valor-neutro'; // Default color

            // Apply color coding based on value thresholds (example)
            if (value > 65) { // High support
                trendClass = 'valor-positivo';
            } else if (value < 35) { // Low support
                trendClass = 'valor-negativo';
            }
            // You could add more nuanced coloring (e.g., light green/red for moderate levels)

            // Create and append the list item
            const div = document.createElement('div');
            div.className = 'apoio-item'; // Use the specific class for styling if needed
            div.innerHTML = `
                <span class="apoio-label">${capitalize(grupoKey)}:</span>
                <span class="apoio-valor ${trendClass}">${value.toFixed(0)}%</span>
            `;
            listaApoioGrupos.appendChild(div);
        }); // End forEach group

        // Optionally, display overall average popularity
        const overallPop = calcularPopularidadeGeral();
        const divOverall = document.createElement('div');
        divOverall.className = 'apoio-item';
        divOverall.style.borderTop = '1px solid #555'; // Separator
        divOverall.style.marginTop = '5px';
        divOverall.style.paddingTop = '5px';
        divOverall.innerHTML = `
            <span class="apoio-label"><strong>Geral (M√©dia):</strong></span>
            <span class="apoio-valor ${overallPop < 40 ? 'valor-negativo' : (overallPop > 60 ? 'valor-positivo' : 'valor-neutro')}"><strong>${overallPop.toFixed(0)}%</strong></span>
        `;
        listaApoioGrupos.appendChild(divOverall);

    }
    
    function atualizarPainelApoioRegional() {
        // --- 1. Safety Check & Get Elements ---
        if (!apoioRegional || Object.keys(apoioRegional).length === 0) {
            // If REGIOES is defined but apoioRegional isn't populated yet
            if(typeof REGIOES !== 'undefined' && REGIOES.length > 0 && (!apoioRegional || Object.keys(apoioRegional).length === 0)) {
                console.warn("ApoioRegional vazio, tentando inicializar...");
                apoioRegional = {};
                REGIOES.forEach(r => apoioRegional[getRegiaoKey(r)] = 50);
            } else {
                 // console.warn("atualizarPainelApoioRegional skipped: Regional support data not available.");
                 return; // Don't update if data isn't initialized
            }
        }

        const listaApoioRegional = document.getElementById("lista-apoio-regional");
        if (!listaApoioRegional) {
            console.error("Erro: Elemento #lista-apoio-regional n√£o encontrado no HTML.");
            return;
        }

        // --- 2. Clear Previous Content ---
        listaApoioRegional.innerHTML = '';

        // --- 3. Iterate and Populate ---
        // Use defined order from REGIOES constant
        const regionsToDisplay = REGIOES.map(r => getRegiaoKey(r)); // Get keys in defined order

        regionsToDisplay.forEach(regiaoKey => {
            // Ensure the region exists in the current state, default to 50 if missing
            const value = apoioRegional[regiaoKey] !== undefined ? apoioRegional[regiaoKey] : 50;
            let trendClass = 'valor-neutro'; // Default color

            // Apply color coding based on value thresholds (example)
            if (value > 65) { // High support
                trendClass = 'valor-positivo';
            } else if (value < 35) { // Low support
                trendClass = 'valor-negativo';
            }

            // Create and append the list item
            const div = document.createElement('div');
            div.className = 'apoio-item'; // Reuse styling class
            div.innerHTML = `
                <span class="apoio-label">${capitalize(regiaoKey)}:</span>
                <span class="apoio-valor ${trendClass}">${value.toFixed(0)}%</span>
            `;
            listaApoioRegional.appendChild(div);
        }); // End forEach region

        // Optionally, display national average support if not shown elsewhere?
        // const overallPop = calcularPopularidadeGeral(); // Or calculate average regional support?
        // ... append overall average if desired ...

    }
    
    function atualizarPainelCongresso() {
        // --- 1. Safety Check & Get Elements ---
        const congressoBar = document.querySelector("#congresso .preenchimento");
        const detalhesEl = document.getElementById("congresso-detalhes");

        if (!congressoBar) {
            console.error("Erro: Elemento da barra de congresso (#congresso .preenchimento) n√£o encontrado.");
            // Don't return, maybe details can still update
        }
         if (!detalhesEl) {
            console.error("Erro: Elemento de detalhes do congresso (#congresso-detalhes) n√£o encontrado.");
            // Don't return, maybe bar can still update
         }
         if (!congressoBar && !detalhesEl) return; // Return only if neither is found

         // Ensure 'congresso' state variable exists and is a number
         const currentSupport = typeof congresso === 'number' ? clamp(congresso, 0, 100) : 50; // Default to 50 if invalid


        // --- 2. Update Progress Bar ---
        if (congressoBar) {
            congressoBar.style.width = currentSupport + "%";
            congressoBar.innerText = currentSupport + "%";
             // Optionally change bar color based on support level
             if (currentSupport < 35) {
                 congressoBar.style.backgroundColor = '#dc3545'; // Red
             } else if (currentSupport < 50) {
                  congressoBar.style.backgroundColor = '#ffc107'; // Yellow
             } else {
                  congressoBar.style.backgroundColor = 'gold'; // Default gold/greenish
             }
        }

        // --- 3. Update Coalition Details Text ---
        if (detalhesEl) {
            let detalhesCoalizaoText = "Nenhum partido na coaliz√£o."; // Default text
            if (coalizao && coalizao.length > 0 && partidos) {
                // Map party IDs to names, removing the "(Seu)" suffix for display
                detalhesCoalizaoText = coalizao
                    .map(id => partidos[id]?.nome?.replace(" (Seu)", "") || capitalize(id)) // Get name or fallback to ID
                    .join(', ');
            }
            // Prepend total support percentage
            detalhesEl.innerText = `Coaliz√£o (${currentSupport}%): ${detalhesCoalizaoText}`;
        }
    }
    
    function atualizarPainelOposicao() {
        // --- 1. Get Elements ---
        const elNome = document.getElementById("op-nome");
        const elPartido = document.getElementById("op-partido");
        const elPop = document.getElementById("op-popularidade");

        // --- 2. Safety Check ---
        if (!elNome || !elPartido || !elPop) {
            console.error("Erro: Um ou mais elementos do Painel de Oposi√ß√£o n√£o foram encontrados.");
            return;
        }

        // --- 3. Update Content Based on State ---
        if (oponentePrincipal && oponentePrincipal.id) { // Check if an opponent is actually selected
            elNome.innerText = oponentePrincipal.nome || "Desconhecido";

            // Get opponent's party name (handle if party data is missing)
            const partidoOponente = partidos[oponentePrincipal.partidoId];
            elPartido.innerText = partidoOponente ? partidoOponente.nome.replace(" (Seu)", "") : (oponentePrincipal.partidoId || "Independente");

            // Format and display opponent popularity
            const popOponenteNum = typeof popularidadeOponente === 'number' ? clamp(popularidadeOponente, 0, 100) : 0;
            elPop.innerText = popOponenteNum.toFixed(0); // Display as integer percentage

            // Optional: Add color based on opponent popularity?
            if (popOponenteNum > 60) {
                elPop.className = 'valor-negativo'; // High opponent pop is bad for player
                elPop.title = "Oposi√ß√£o Forte";
            } else if (popOponenteNum < 30) {
                 elPop.className = 'valor-positivo'; // Low opponent pop is good for player
                 elPop.title = "Oposi√ß√£o Fraca";
            } else {
                elPop.className = 'valor-neutro';
                elPop.title = "";
            }

        } else {
            // Default display if no opponent is active
            elNome.innerText = "Ningu√©m Definido";
            elPartido.innerText = "-";
            elPop.innerText = "?";
            elPop.className = 'valor-neutro';
            elPop.title = "";
        }
    }
    
    function atualizarPainelMundo() {
        // --- 1. Get Elements ---
        const divPaises = document.getElementById("lista-paises");
        const spanBlocos = document.getElementById("blocos-ativos-lista");
        const spanTratados = document.getElementById("tratados-ativos-lista");
        const btnDiplomacia = document.getElementById("btn-mostrar-diplomacia"); // Get button too

        // --- 2. Safety Check ---
        if (!divPaises || !spanBlocos || !spanTratados || !btnDiplomacia) {
            console.error("Erro: Um ou mais elementos do Painel Mundo n√£o foram encontrados.");
            return;
        }
        // Also check if core foreign policy states exist
        if (typeof relacoesPaises !== 'object' || typeof blocosAtivos !== 'object' || !Array.isArray(tratadosAtivos)) {
             console.warn("atualizarPainelMundo skipped: Foreign policy state not initialized.");
             // Set default text to avoid errors
             divPaises.innerHTML = '<span>Rela√ß√µes n√£o dispon√≠veis.</span>';
             spanBlocos.innerText = 'N/A';
             spanTratados.innerText = 'N/A';
             return;
        }


        // --- 3. Update Relations with Countries ---
        divPaises.innerHTML = ''; // Clear previous list
        const paisIds = Object.keys(paises || {}); // Get defined countries
        if (paisIds.length === 0) {
             divPaises.innerHTML = '<span>Nenhum pa√≠s definido.</span>';
        } else {
            paisIds.forEach(paisId => {
                const rel = relacoesPaises[paisId] || 50; // Get relation, default 50
                let trendClass = 'valor-neutro';
                if (rel > 65) trendClass = 'valor-positivo';
                else if (rel < 35) trendClass = 'valor-negativo';

                const div = document.createElement('div');
                div.className = 'diplomacia-item'; // Use a consistent class
                // Display only name and relation % for brevity in the panel
                div.innerHTML = `
                    <span>${paises[paisId]?.nome || capitalize(paisId)}:</span>
                    <span class="${trendClass}">${rel}%</span>
                `;
                divPaises.appendChild(div);
            });
        }

        // --- 4. Update Active Blocs/Alliances ---
        const blocosPlayer = Object.keys(blocosAtivos).filter(bId => blocosAtivos[bId]?.membros?.includes("jogador")); // Check player membership
        if (blocosPlayer.length > 0) {
            spanBlocos.innerText = blocosPlayer.map(bId => blocosAtivos[bId]?.nome || capitalize(bId)).join(', ');
            spanBlocos.title = spanBlocos.innerText; // Show full list on hover if long
        } else {
            spanBlocos.innerText = 'Nenhum';
            spanBlocos.title = '';
        }
         // Check achievement for joining a bloc
         if (blocosPlayer.length > 0) checkAchievement('construtor_blocos');


        // --- 5. Update Active Treaties Count ---
        const numTratados = tratadosAtivos.length;
        if (numTratados > 0) {
            spanTratados.innerText = `${numTratados} Ativo(s)`;
             // Generate tooltip text listing treaties
             spanTratados.title = tratadosAtivos.map(t => `${t.tipo} com ${paises[t.paisAlvoId]?.nome || '?'}`).join('; ');
        } else {
            spanTratados.innerText = 'Nenhum';
            spanTratados.title = '';
        }
         // Check achievement for treaties (can call checkAchievement directly as state is updated elsewhere)
         // Or use the counter mechanism: achievementsState['diplomata'].current = numTratados; checkAchievement('diplomata');


        // --- 6. Update Diplomacy Button State (Optional) ---
        // Disable button if game paused etc.
        btnDiplomacia.disabled = jogoPausado || eventoOrcamentoAtivo || debateAtual;

    }
    
    function adicionarNoticia(texto, tipo = "sistema", classeCss = null) {
        // --- 1. Safety Check & Get Element ---
        const listaManchetes = document.getElementById("lista-manchetes");
        if (!listaManchetes) {
            console.warn("Elemento #lista-manchetes n√£o encontrado, n√£o foi poss√≠vel adicionar not√≠cia:", texto);
            return; // Can't add if the list doesn't exist
        }
        if (!texto || typeof texto !== 'string' || texto.trim() === '') {
             console.warn("Tentativa de adicionar not√≠cia vazia.");
             return; // Don't add empty messages
        }

        // --- 2. Create New List Item ---
        const novoItem = document.createElement("li");

        // --- 3. Determine Prefix & CSS Class based on Type ---
        let prefix = "";
        let itemClass = `noticia-${tipo}`; // Base class from type

        switch (tipo) {
            case "evento": prefix = "‚ö° "; itemClass += " noticia-evento"; break; // Use existing style
            case "desastre": prefix = "üö® "; itemClass += " noticia-desastre"; break; // Use existing style
            case "sistema": prefix = "‚öôÔ∏è "; itemClass += " noticia-sistema"; break; // Use existing style
            case "midia": prefix = "üì∞ "; itemClass += " noticia-midia"; break; // Use existing style
            case "oposicao": prefix = "üì¢ "; itemClass += " noticia-oposicao"; break; // Use existing style (changed icon)
            case "diplomacia": prefix = "üåê "; itemClass += " noticia-diplomacia"; break; // Added type
            case "gabinete": prefix = "üë• "; itemClass += " noticia-gabinete"; break; // Added type
            case "pessoal": prefix = "üë§ "; itemClass += " noticia-pessoal"; break; // Added type
            // Add more types as needed
            default: prefix = "‚ÑπÔ∏è "; break; // Default info icon
        }

        // Apply additional explicit CSS class if provided (e.g., for success/warning/danger)
        if (classeCss) {
             if(classeCss === 'perigo') itemClass += ' valor-negativo';
             else if (classeCss === 'sucesso') itemClass += ' valor-positivo';
             else if (classeCss === 'aviso') itemClass += ' valor-aviso'; // Make sure .valor-aviso exists in CSS
             else itemClass += ` ${classeCss}`; // Add any other custom class
        }

        novoItem.className = itemClass; // Set the combined class(es)

        // --- 4. Set Content (Prefix + Text) ---
        // Basic sanitization (prevent injecting raw HTML tags)
        novoItem.textContent = `${prefix}${texto}`; // Use textContent to avoid HTML injection issues

        // --- 5. Add to List & Limit Size ---
        // Add to top
        if (listaManchetes.firstChild) {
            listaManchetes.insertBefore(novoItem, listaManchetes.firstChild);
        } else {
            listaManchetes.appendChild(novoItem); // Append if list was empty
        }

        // Limit the number of items in the list
        const maxNoticias = 25; // Keep more history visible
        while (listaManchetes.children.length > maxNoticias) {
            listaManchetes.removeChild(listaManchetes.lastChild);
        }

        // Optional: Scroll to top? Might be annoying.
        // listaManchetes.scrollTop = 0;
    }
    
    function atualizarPainelMidia(novasManchetes) {
        // --- 1. Input Validation ---
        if (!Array.isArray(novasManchetes)) {
            console.warn("atualizarPainelMidia received non-array input:", novasManchetes);
            return; // Expecting an array
        }

        if (novasManchetes.length === 0) {
            // console.log("Nenhuma nova manchete de m√≠dia para adicionar."); // Optional log
            return; // Nothing to add
        }

        console.log(`Adicionando ${novasManchetes.length} novas manchetes de m√≠dia.`);

        // --- 2. Add Each Headline using adicionarNoticia ---
        novasManchetes.forEach(mancheteTexto => {
            // Call adicionarNoticia for each headline, specifying the type as 'midia'
            // No additional 'classeCss' is typically needed here unless gerarManchetes adds sentiment info
            adicionarNoticia(mancheteTexto, 'midia');
        });
    }

    // --- Leader Characteristics --- (Defined before init)
    function initializeLeaderState() {
        console.log("Inicializando estado do l√≠der...");

        // --- 1. Safety Check ---
        if (!liderAtual || !liderAtual.tipo) {
            console.error("CRITICAL: N√£o √© poss√≠vel inicializar o l√≠der - liderAtual n√£o definido!");
            // Fallback to default if possible? Or stop game?
            liderAtual = { tipo: "Pragm√°tico", partidoId: "partido_independente" }; // Risky fallback
            // return; // Alternatively, just stop
        }

        // --- 2. Reset Leader Object ---
        lider = {
            atributos: { carisma: 5, honestidade: 5, estrategia: 5 }, // Default attributes
            tracos: [],
            experiencia: 0,
            nivel: 1,
            pontosHabilidade: 0,
            habilidades: [],
            familia: []
        };

        // --- 3. Assign Attributes/Traits based on Type ---
        const tipo = liderAtual.tipo;
        console.log(`Definindo atributos/tra√ßos para o tipo: ${tipo}`);

        switch (tipo) {
            case 'CentroEsquerda':
                lider.atributos = { carisma: 6, honestidade: 6, estrategia: 5 };
                lider.tracos = ['Idealista', 'Progressista']; // Example traits
                break;
            case 'Liberal':
                lider.atributos = { carisma: 5, honestidade: 5, estrategia: 7 };
                lider.tracos = ['Pragm√°tico', 'Liberal'];
                break;
            case 'Conservador':
                lider.atributos = { carisma: 5, honestidade: 7, estrategia: 5 };
                lider.tracos = ['Leal', 'Conservador'];
                break;
            case 'Populista':
                lider.atributos = { carisma: 8, honestidade: 4, estrategia: 4 };
                lider.tracos = ['Populista', 'Ambicioso'];
                break;
            default: // Fallback if type is unexpected
                console.warn(`Tipo de l√≠der desconhecido '${tipo}', usando atributos padr√£o.`);
                lider.atributos = { carisma: 5, honestidade: 5, estrategia: 5 };
                lider.tracos = ['Pragm√°tico'];
                break;
        }

        // --- 4. Apply Initial Trait Modifiers to Attributes (Optional Refinement) ---
        // This allows traits to slightly adjust base attributes
        lider.tracos.forEach(trait => {
            const traitDef = tracosDefinidos[trait];
            if (traitDef) {
                 console.log(`Aplicando efeito do tra√ßo: ${trait}`);
                 // Example effects based on descriptions (can be more complex)
                 if (traitDef.efeito?.includes("+1 Carisma")) lider.atributos.carisma = clamp(lider.atributos.carisma + 1, 1, 10);
                 if (traitDef.efeito?.includes("-1 Carisma")) lider.atributos.carisma = clamp(lider.atributos.carisma - 1, 1, 10);
                 if (traitDef.efeito?.includes("+1 Honestidade")) lider.atributos.honestidade = clamp(lider.atributos.honestidade + 1, 1, 10);
                 if (traitDef.efeito?.includes("-1 Honestidade")) lider.atributos.honestidade = clamp(lider.atributos.honestidade - 1, 1, 10);
                 if (traitDef.efeito?.includes("+1 Estrategia")) lider.atributos.estrategia = clamp(lider.atributos.estrategia + 1, 1, 10);
                 if (traitDef.efeito?.includes("-1 Estrategia")) lider.atributos.estrategia = clamp(lider.atributos.estrategia - 1, 1, 10);
            } else {
                 console.warn(`Defini√ß√£o para o tra√ßo '${trait}' n√£o encontrada.`);
            }
        });

        // --- 5. Generate Initial Family ---
        console.log("Gerando fam√≠lia inicial...");
        lider.familia = gerarFamiliaInicial();

        console.log("Estado inicial do l√≠der definido:", lider);
    }

    // --- Helper function called by initializeLeaderState ---
    function gerarFamiliaInicial() {
        let familia = [];
        const spouseNames = ["Maria Silva", "Jos√© Santos", "Ana Oliveira", "Carlos Souza", "Sofia Pereira", "Ricardo Costa"];
        const childNames = ["J√∫nior", "Mariana", "Pedro Santos", "Laura Oliveira", "Lucas Silva", "Beatriz Costa"];

        // Add Spouse
        const spouseName = getRandomElement(spouseNames);
        familia.push({
            tipo: 'conjuge',
            nome: spouseName,
            // Influence could affect certain decisions or event outcomes later
            influencia: getRandomElement(['baixa', 'moderada', 'alta']),
            risco: clamp(Math.random() * 20 + 5, 5, 25) // Low base risk for spouse (5-25)
        });

        // Add 0, 1 or 2 Children (adjust probabilities)
        const numChildren = Math.random() < 0.4 ? 0 : (Math.random() < 0.7 ? 1 : 2);
        let usedChildNames = [];
        for (let i = 0; i < numChildren; i++) {
            let childName = getRandomElement(childNames);
            // Ensure unique names if multiple children
            while (usedChildNames.includes(childName)) {
                childName = getRandomElement(childNames);
            }
            usedChildNames.push(childName);
            familia.push({
                tipo: 'filho', // Or 'filha' if you want gender specifics
                nome: childName,
                risco: clamp(Math.random() * 50 + 10, 10, 60) // Higher potential risk for children (10-60)
            });
        }

        console.log("Fam√≠lia gerada:", familia);
        return familia;
    }
    
    function gerarFamiliaInicial() {
        let familia = []; // Initialize empty array for family members

        // Pool of potential names
        const spouseNames = [
            "Maria Silva", "Jos√© Santos", "Ana Oliveira", "Carlos Souza",
            "Sofia Pereira", "Ricardo Costa", "Beatriz Almeida", "Fernando Lima"
        ];
        const childNames = [
            "J√∫nior", "Mariana Santos", "Pedro Oliveira", "Laura Souza",
            "Lucas Silva", "Beatriz Costa", "Gabriel Pereira", "Isabela Lima"
        ];

        // --- 1. Add Spouse ---
        const spouseName = getRandomElement(spouseNames);
        familia.push({
            tipo: 'conjuge',
            nome: spouseName,
            // Influence level can affect event triggers or outcomes later
            influencia: getRandomElement(['baixa', 'moderada', 'alta']),
            // Base risk factor for spouse-related negative events (e.g., minor scandals)
            risco: clamp(Math.random() * 20 + 5, 5, 25) // Low-ish risk: 5-25
        });

        // --- 2. Add Children ---
        // Determine number of children (adjust probabilities as desired)
        const numChildrenRoll = Math.random();
        let numChildren = 0;
        if (numChildrenRoll < 0.3) { // 30% chance of 0 children
            numChildren = 0;
        } else if (numChildrenRoll < 0.8) { // 50% chance of 1 child (0.8 - 0.3)
            numChildren = 1;
        } else { // 20% chance of 2 children
            numChildren = 2;
        }

        console.log(`Gerando ${numChildren} filho(s)...`);

        let usedChildNames = []; // To avoid duplicate names if generating multiple children
        for (let i = 0; i < numChildren; i++) {
            let childName = getRandomElement(childNames);
            // Ensure unique names if generating more than one child
            let attempts = 0; // Prevent infinite loop if name pool is small
            while (usedChildNames.includes(childName) && attempts < childNames.length * 2) {
                childName = getRandomElement(childNames);
                attempts++;
            }
            if (attempts >= childNames.length * 2) console.warn("Could not find unique child name."); // Fallback if needed
            usedChildNames.push(childName);

            familia.push({
                tipo: 'filho', // Could differentiate 'filha' based on name if needed later
                nome: childName,
                // Children often have higher potential for causing trouble (scandals)
                risco: clamp(Math.random() * 50 + 10, 10, 60) // Medium/Higher risk: 10-60
            });
        }

        console.log("Fam√≠lia gerada:", familia);
        return familia; // Return the array of family member objects
    }
    
    function checkLevelUp() {
        // --- 1. Safety Checks & Get Data ---
        if (!lider || typeof lider.experiencia !== 'number' || typeof lider.nivel !== 'number') {
            // console.warn("checkLevelUp skipped: Leader XP/Level data missing or invalid.");
            return; // Exit if data is missing
        }

        // --- 2. Calculate XP Needed ---
        // XP formula: Base + (Level * Multiplier) - Adjust as needed for pacing
        const xpParaProximoNivel = (lider.nivel * 15) + 10; // e.g., Lvl 1->2 needs 25 XP, Lvl 2->3 needs 40 XP

        // --- 3. Check for Level Up ---
        if (lider.experiencia >= xpParaProximoNivel) {
            console.log(`--- LEVEL UP! N√≠vel ${lider.nivel} -> ${lider.nivel + 1} ---`);

            // --- 4. Apply Level Up Changes ---
            lider.nivel++;
            lider.experiencia -= xpParaProximoNivel; // Subtract cost, keep leftover XP
            lider.pontosHabilidade = (lider.pontosHabilidade || 0) + 1; // Grant skill point

            // --- 5. Provide Feedback ---
            adicionarNoticia(`‚≠ê PARAB√âNS! Voc√™ atingiu o N√≠vel ${lider.nivel} de experi√™ncia! Ganhou 1 Ponto de Habilidade.`, "sistema", "sucesso");

            // Check achievement for leveling up (only first time?)
            if (lider.nivel === 2) { // Assuming level starts at 1
                 checkAchievement('nivel_up');
            }

            // --- 6. Trigger Level Up Modal ---
            // Open immediately to force player to spend point? Or let them do it via button?
            // Opening immediately might interrupt flow, let's rely on the button becoming visible.
            console.log("Ponto de habilidade dispon√≠vel. Bot√£o 'Melhorar' ser√° exibido.");
            // Triggering UI update is necessary for the button to appear
            atualizarUI(); // Ensure UI reflects new level, XP, and available point

            // --- Optional: Recursive check if multiple level ups are possible ---
            // If gaining a large chunk of XP could trigger multiple levels at once
            // checkLevelUp(); // Be careful with potential infinite loops if XP gain is buggy

        }
        // --- 7. Update XP display even if no level up ---
        // (This is handled by atualizarPainelLider called within atualizarUI)
    }
    
    function mostrarModalLevelUp() {
        // --- 1. Safety Checks & Get Elements ---
        if (!lider || typeof lider.pontosHabilidade !== 'number' || lider.pontosHabilidade <= 0) {
            console.warn("mostrarModalLevelUp chamado sem pontos de habilidade dispon√≠veis.");
            alert("Voc√™ n√£o tem pontos de habilidade para gastar.");
            return; // Don't show if no points
        }

        const modal = document.getElementById("modal-levelup");
        const pontosDisplay = document.getElementById("levelup-pontos");
        const atributosDiv = document.getElementById("levelup-atributos");
        const habilidadesDiv = document.getElementById("levelup-habilidades");

        if (!modal || !pontosDisplay || !atributosDiv || !habilidadesDiv) {
            console.error("Erro: Elementos do modal de Level Up n√£o encontrados!");
            return;
        }

        console.log("Abrindo modal de Level Up...");

        // --- 2. Update Point Display ---
        pontosDisplay.innerText = lider.pontosHabilidade;

        // --- 3. Populate Attribute Upgrade Options ---
        atributosDiv.innerHTML = ''; // Clear previous
        for (const atr in lider.atributos) {
            const currentValue = lider.atributos[atr];
            const canUpgrade = currentValue < 10; // Check if attribute is maxed out

            const div = document.createElement('div');
            div.className = 'indicador-item'; // Reuse style
            div.innerHTML = `
                <span class="indicador-label">${capitalize(atr)}:</span>
                <span class="indicador-valor">${currentValue}/10</span>
                <button class="botao botao-pequeno sucesso"
                        onclick="gastarPontoHabilidade('atributo', '${atr}')"
                        ${!canUpgrade ? 'disabled title="M√°ximo Atingido"' : ''}>
                    +1 ${canUpgrade ? '(1 Pt)' : ''}
                </button>
            `;
            atributosDiv.appendChild(div);
        }

        // --- 4. Populate Skill Learning Options ---
        habilidadesDiv.innerHTML = ''; // Clear previous
        let availableSkillCount = 0;
        for (const skillId in habilidadesDefinidas) {
            // Check if skill is already learned
            if (!lider.habilidades || !lider.habilidades.includes(skillId)) {
                const skillDef = habilidadesDefinidas[skillId];
                const cost = skillDef.cost || 1; // Default cost to 1 if not specified
                const canAfford = lider.pontosHabilidade >= cost;

                const div = document.createElement('div');
                div.className = 'indicador-item'; // Reuse style
                div.style.alignItems = 'center'; // Align button vertically
                div.innerHTML = `
                    <div>
                        <strong>${skillDef.nome}</strong><br>
                        <small>${skillDef.desc}</small>
                    </div>
                    <button class="botao botao-pequeno sucesso"
                            onclick="gastarPontoHabilidade('habilidade', '${skillId}')"
                            ${!canAfford ? 'disabled title="Pontos Insuficientes"' : ''}>
                        Aprender ${canAfford ? `(${cost} Pt)` : ''}
                    </button>
                `;
                habilidadesDiv.appendChild(div);
                availableSkillCount++;
            }
        }
        if (availableSkillCount === 0) {
             habilidadesDiv.innerHTML = '<p><i>Nenhuma nova habilidade dispon√≠vel ou todas j√° aprendidas.</i></p>';
        }


        // --- 5. Display Modal ---
        modal.style.display = 'block';
    }

    /**
     * Handles spending a skill point on an attribute or skill.
     * Called by buttons within the Level Up modal.
     * @param {'atributo'|'habilidade'} tipo - The type of upgrade.
     * @param {string} idOuAtributo - The ID of the skill or the name of the attribute.
     */
    function gastarPontoHabilidade(tipo, idOuAtributo) {
        console.log(`Tentando gastar ponto em: ${tipo} - ${idOuAtributo}`);
        if (!lider || lider.pontosHabilidade <= 0) {
            console.warn("Tentativa de gastar ponto sem ter pontos.");
            return;
        }

        let cost = 1; // Default cost

        // --- Process Upgrade ---
        if (tipo === 'atributo') {
            if (lider.atributos && lider.atributos[idOuAtributo] !== undefined && lider.atributos[idOuAtributo] < 10) {
                lider.atributos[idOuAtributo]++;
                console.log(`Atributo ${idOuAtributo} aumentado para ${lider.atributos[idOuAtributo]}`);
                // No specific achievement for attribute increase?
            } else {
                console.warn(`N√£o foi poss√≠vel aumentar atributo '${idOuAtributo}' (inv√°lido ou j√° no m√°ximo).`);
                return; // Don't spend point if upgrade failed
            }
        } else if (tipo === 'habilidade') {
            const skillDef = habilidadesDefinidas[idOuAtributo];
            if (skillDef && (!lider.habilidades || !lider.habilidades.includes(idOuAtributo))) {
                cost = skillDef.cost || 1; // Get skill cost
                if (lider.pontosHabilidade < cost) {
                    console.warn(`Pontos insuficientes para aprender habilidade ${idOuAtributo} (Custo: ${cost})`);
                    alert(`Pontos insuficientes! Esta habilidade custa ${cost} ponto(s).`);
                    return; // Don't spend point
                }
                if (!lider.habilidades) lider.habilidades = []; // Ensure array exists
                lider.habilidades.push(idOuAtributo);
                console.log(`Habilidade '${skillDef.nome}' aprendida.`);
                // Add achievement check if relevant (e.g., learn first skill, learn X skills)
            } else {
                console.warn(`N√£o foi poss√≠vel aprender habilidade '${idOuAtributo}' (inv√°lida ou j√° aprendida).`);
                return; // Don't spend point if upgrade failed
            }
        } else {
            console.error("Tipo de gasto de ponto desconhecido:", tipo);
            return; // Invalid type
        }

        // --- Deduct Point & Update ---
        lider.pontosHabilidade -= cost;
        console.log(`Ponto(s) gasto(s). Pontos restantes: ${lider.pontosHabilidade}`);

        // --- Refresh Modal & UI ---
        if (lider.pontosHabilidade > 0) {
            // If points remain, just refresh the modal content
            mostrarModalLevelUp();
        } else {
            // If no points left, close the modal
            fecharModal('modal-levelup');
        }
        // Update the main leader panel display immediately
        atualizarPainelLider();
         // Save game after spending points
         saveGame();
    }
    
    function gastarPontoHabilidade(tipo, idOuAtributo) {
        console.log(`Tentando gastar ponto em: ${tipo} - ${idOuAtributo}`);

        // --- 1. Validation ---
        if (!lider || typeof lider.pontosHabilidade !== 'number' || lider.pontosHabilidade <= 0) {
            console.warn("Tentativa de gastar ponto sem ter pontos dispon√≠veis.");
            alert("Voc√™ n√£o tem pontos de habilidade para gastar!");
            return; // Exit if no points
        }
        if (!tipo || !idOuAtributo) {
            console.error("gastarPontoHabilidade chamado com tipo ou ID inv√°lido.");
            return; // Exit if parameters are missing
        }

        let cost = 1; // Default cost is 1 point

        // --- 2. Process Upgrade based on Type ---
        if (tipo === 'atributo') {
            // Ensure attribute exists and is not maxed out
            if (lider.atributos && lider.atributos[idOuAtributo] !== undefined && lider.atributos[idOuAtributo] < 10) {
                lider.atributos[idOuAtributo]++; // Increment the attribute
                console.log(`Atributo ${idOuAtributo} aumentado para ${lider.atributos[idOuAtributo]}`);
                // No specific achievement for attribute increase in this design
            } else {
                console.warn(`N√£o foi poss√≠vel aumentar atributo '${idOuAtributo}' (inv√°lido ou j√° no m√°ximo 10).`);
                alert(`N√£o √© poss√≠vel aumentar mais o atributo ${capitalize(idOuAtributo)}.`);
                return; // Don't spend point if upgrade failed
            }
        } else if (tipo === 'habilidade') {
            const skillDef = habilidadesDefinidas[idOuAtributo];
            // Ensure skill exists, isn't already learned, and initialize skills array if needed
            if (skillDef && (!lider.habilidades || !lider.habilidades.includes(idOuAtributo))) {
                cost = skillDef.cost || 1; // Get skill cost, default to 1

                // Check affordability
                if (lider.pontosHabilidade < cost) {
                    console.warn(`Pontos insuficientes para aprender habilidade ${idOuAtributo} (Custo: ${cost}, Dispon√≠vel: ${lider.pontosHabilidade})`);
                    alert(`Pontos insuficientes! Esta habilidade custa ${cost} ponto(s).`);
                    return; // Don't spend point
                }

                // Learn the skill
                if (!lider.habilidades) {
                    lider.habilidades = []; // Ensure the array exists before pushing
                }
                lider.habilidades.push(idOuAtributo);
                console.log(`Habilidade '${skillDef.nome}' aprendida.`);

                // Check achievements related to learning skills (e.g., learn first skill, learn N skills)
                // if (lider.habilidades.length === 1) checkAchievement('primeira_habilidade'); // Example
                // if (lider.habilidades.length === 5) checkAchievement('mestre_habilidades'); // Example

            } else {
                if (!skillDef) {
                     console.warn(`N√£o foi poss√≠vel aprender habilidade '${idOuAtributo}' (Defini√ß√£o n√£o encontrada).`);
                } else {
                     console.warn(`N√£o foi poss√≠vel aprender habilidade '${idOuAtributo}' (J√° aprendida).`);
                     alert(`Voc√™ j√° aprendeu a habilidade ${skillDef.nome}.`);
                }
                return; // Don't spend point if upgrade failed
            }
        } else {
            console.error("Tipo de gasto de ponto desconhecido:", tipo);
            return; // Invalid type
        }

        // --- 3. Deduct Point & Update State ---
        lider.pontosHabilidade -= cost;
        console.log(`Ponto(s) gasto(s): ${cost}. Pontos restantes: ${lider.pontosHabilidade}`);

        // --- 4. Refresh Modal or Close ---
        if (lider.pontosHabilidade > 0) {
            // If points remain, refresh the modal content to show updated options/points
            console.log("Atualizando modal de Level Up...");
            mostrarModalLevelUp();
        } else {
            // If no points left, close the modal
            console.log("Nenhum ponto restante, fechando modal.");
            fecharModal('modal-levelup');
        }

        // --- 5. Update Main UI ---
        // Update the leader panel display immediately to reflect the change
        atualizarPainelLider();

        // --- 6. Save Game ---
        // Persist the changes made by spending the point
        saveGame();
    }

    // --- Cabinet & Party Management --- (Defined before init)
 function initializeMinistroAtivo(ministroId) {
        // --- 1. Input Validation ---
        if (!ministroId) {
            // console.warn("initializeMinistroAtivo called with no ID."); // Can be noisy
            return; // Do nothing if no ID provided
        }

        // --- 2. Check if Already Active ---
        if (ministrosAtivos[ministroId]) {
            // console.log(`Minister ${ministroId} is already active.`); // Already initialized
            return; // Don't re-initialize
        }

        // --- 3. Find Base Data in Pool ---
        const ministroPoolData = poolMinistros.find(m => m.id === ministroId);

        // --- 4. Check if Found ---
        if (!ministroPoolData) {
            console.error(`Could not find minister data in poolMinistros for ID: ${ministroId}`);
            // Should we add a placeholder? Or just skip? Skipping is safer.
            return; // Minister definition not found
        }

        // --- 5. Create Active Minister State ---
        console.log(`Initializing active state for minister: ${ministroPoolData.nome} (${ministroId})`);
        ministrosAtivos[ministroId] = {
            ...ministroPoolData, // Copy all static data (nome, area, personalidade, bonus, partidoId, riscoCorrupcao etc.)
            lealdade: ministroPoolData.lealdadeInicial || 50 // Set initial loyalty (default to 50 if undefined)
            // Add any other dynamic state needed later (e.g., 'emInvestigacao: false')
        };

        // console.log("Current ministrosAtivos:", ministrosAtivos); // Uncomment for debugging
    }
    function mostrarModalGabinete() {
        console.log("Mostrando modal do Gabinete...");

        // --- 1. Get Elements ---
        const modal = document.getElementById("modal-gabinete");
        const listaGabinete = document.getElementById("lista-gabinete");
        const btnNomear = document.getElementById("btn-iniciar-nomeacao"); // Button to nominate for vacant post

        if (!modal || !listaGabinete || !btnNomear) {
            console.error("Erro: Elementos do modal do Gabinete n√£o encontrados!");
            return;
        }

        // --- 2. Clear Previous Content ---
        listaGabinete.innerHTML = '';

        // --- 3. Determine Order & Check Vacancies ---
        const areasPrincipais = ["economia", "social", "defesa"];
        // Get all currently defined cabinet roles (keys in the `gabinete` object)
        const todasAsAreas = Object.keys(gabinete);
        const outrasAreas = todasAsAreas.filter(a => !areasPrincipais.includes(a));
        const displayOrder = [...areasPrincipais, ...outrasAreas];

        let hasVacancy = false; // Flag to enable/disable nomination button

        // --- 4. Populate List ---
        displayOrder.forEach(area => {
            const ministroId = gabinete[area]; // Get ID from current cabinet state
            const div = document.createElement("div");
            div.className = 'gabinete-item'; // Styling class

            let content = `<strong style="min-width: 100px; display: inline-block;">${capitalize(area)}:</strong> `;

            if (ministroId && ministrosAtivos[ministroId]) {
                // Minister is assigned and active data exists
                const ministro = ministrosAtivos[ministroId];
                const partido = partidos[ministro.partidoId] || { nome: 'Ind.' }; // Get party info
                let loyaltyClass = 'valor-neutro';
                if (ministro.lealdade > 70) loyaltyClass = 'valor-positivo';
                else if (ministro.lealdade < 40) loyaltyClass = 'valor-negativo';

                content += `
                    <span style="flex-grow: 1; margin: 0 10px;">
                        ${ministro.nome} (${partido.nome.replace(" (Seu)", "")})
                    </span>
                    <span class="${loyaltyClass}" style="min-width: 80px; text-align: right;">
                        Lealdade: ${ministro.lealdade}%
                    </span>
                    <button class="botao botao-perigo botao-pequeno"
                            onclick="demitirMinistro('${ministroId}')"
                            title="Demitir ${ministro.nome}">
                        Demitir
                    </button>`;
            } else {
                // Role is vacant
                content += `<span style="flex-grow: 1; margin: 0 10px; font-style: italic; color: #aaa;">Vago</span>`;
                // Optionally add a "Nomear" button directly here
                content += `<button class="botao botao-sucesso botao-pequeno"
                                    onclick="iniciarNomeacao('${area}')"
                                    title="Nomear para ${capitalize(area)}">
                                Nomear
                            </button>`;
                hasVacancy = true; // Mark that there's at least one vacancy
            }
            div.innerHTML = content;
            listaGabinete.appendChild(div);
        }); // End forEach area

        // Add message if cabinet is empty (shouldn't happen after init, but good check)
        if (displayOrder.length === 0) {
             listaGabinete.innerHTML = '<p>Nenhuma pasta ministerial definida ainda.</p>';
             hasVacancy = true; // Treat as vacant for nomination button
        }

        // --- 5. Update Nomination Button State ---
        btnNomear.disabled = !hasVacancy;
        btnNomear.title = hasVacancy ? "Iniciar nomea√ß√£o para uma pasta vaga" : "Nenhuma pasta vaga no momento";

        // --- 6. Display Modal ---
        modal.style.display = "block";
    }
    
/**
     * Handles the dismissal of a minister.
     * Applies political consequences, removes the minister from the cabinet
     * and active list, updates UI, and optionally triggers nomination.
     * @param {string} ministroId - The ID of the minister to dismiss.
     * @param {boolean} [abrirModalNomeacao=true] - Whether to automatically open the nomination modal afterwards.
     */
     function demitirMinistro(ministroId, abrirModalNomeacao = true) {
        console.log(`Tentando demitir ministro: ${ministroId}`);

        // --- 1. Validation ---
        if (!ministroId) {
            console.warn("demitirMinistro chamado sem ID."); return;
        }
        const ministro = ministrosAtivos[ministroId];
        if (!ministro) {
            console.warn(`Ministro com ID ${ministroId} n√£o encontrado na lista de ativos.`);
            // Maybe the minister was already fired or the ID is wrong? Silently return?
            return;
        }

        // Find the area/role this minister occupies
        const areaMinistro = Object.keys(gabinete).find(a => gabinete[a] === ministroId);
        if (!areaMinistro) {
             console.warn(`Ministro ${ministroId} encontrado em ministrosAtivos, mas n√£o atribu√≠do a nenhuma pasta no gabinete atual? Estado inconsistente.`);
             // Proceed with removal from active list anyway, but don't clear a cabinet slot?
        }

        // --- 2. Apply Consequences ---
        adicionarNoticia(`üö® GABINETE: Ministro ${ministro.nome} (${capitalize(areaMinistro || '?')}) foi DEMITIDO!`, "gabinete", "aviso");

        let efeitosDemissao = {};

        // 2a. Relation Hit with Minister's Party
        const partidoId = ministro.partidoId; // Get party from active minister data
        if (partidoId && partidoId !== liderAtual.partidoId && relacoesPartidos[partidoId] !== undefined) {
            const relationHit = -25; // Significant penalty
            efeitosDemissao[`relacoesPartidos_${partidoId}`] = relationHit; // Use specific effect key format
            adicionarNoticia(`O partido ${partidos[partidoId]?.nome || partidoId} est√° furioso com a demiss√£o. Rela√ß√µes abaladas!`, "sistema", "perigo");

            // Check if party leaves coalition due to extreme low relations
            if ((relacoesPartidos[partidoId] + relationHit) < 20 && coalizao.includes(partidoId)) {
                 coalizao = coalizao.filter(pid => pid !== partidoId); // Remove party
                 adicionarNoticia(`FIM DA ALIAN√áA! O partido ${partidos[partidoId]?.nome || partidoId} deixou a coaliz√£o governista!`, "sistema", "perigo");
                 // Congress support will be recalculated later
            }
        }

        // 2b. General Popularity / Stability Hit
        efeitosDemissao.popGeral = -3; // Small hit for instability
        // Maybe larger hit if minister was popular or from key group?
        if (ministro.bonus?.popTrabalhadores > 0 && popularidadeGrupos[getGrupoKey('Trabalhadores')] > 50) efeitosDemissao.popTrabalhadores = -3;
        if (ministro.bonus?.popEmpresarios > 0 && popularidadeGrupos[getGrupoKey('Empres√°rios')] > 50) efeitosDemissao.popEmpresarios = -3;
        // Add more specific pop hits based on minister's bonuses/focus

        // 2c. Apply effects
        aplicarEfeitos(efeitosDemissao);

        // --- 3. Update Game State ---
        // 3a. Remove from cabinet slot
        if (areaMinistro) {
            gabinete[areaMinistro] = null; // Set the slot to vacant
            console.log(`Pasta ${areaMinistro} agora est√° vaga.`);
        }

        // 3b. Remove from active ministers list
        delete ministrosAtivos[ministroId];
        console.log(`Ministro ${ministroId} removido da lista de ativos.`);

        // --- 4. Update UI & Potentially Trigger Nomination ---
        calcularApoioCongresso(); // Recalculate congress support immediately after relation/coalition changes
        atualizarUI(); // Refresh the entire UI to show changes

        // Close the cabinet modal if it's currently open
        fecharModal('modal-gabinete');

        // Trigger nomination modal if requested and a valid area was cleared
        if (abrirModalNomeacao && areaMinistro) {
            console.log(`Abrindo modal de nomea√ß√£o para ${areaMinistro} ap√≥s demiss√£o.`);
            // Use setTimeout to allow UI updates and modal closing to process first
            setTimeout(() => iniciarNomeacao(areaMinistro), 300);
        }
    }
/**
     * Helper function to dismiss a minister based on their portfolio/area name.
     * Finds the minister currently holding the specified role and calls demitirMinistro.
     * @param {string} pasta - The key name of the ministerial area (e.g., 'economia', 'saude').
     */
     function demitirMinistroPorPasta(pasta) {
        console.log(`Tentando demitir ministro pela pasta: ${pasta}`);

        // --- 1. Validation ---
        if (!pasta || typeof pasta !== 'string') {
            console.warn("demitirMinistroPorPasta chamado com pasta inv√°lida:", pasta);
            return;
        }
        if (!gabinete || typeof gabinete !== 'object') {
            console.error("demitirMinistroPorPasta: Objeto gabinete n√£o est√° inicializado.");
            return;
        }

        // --- 2. Find Minister ID by Area ---
        // The `find` logic in the original snippet was slightly flawed.
        // We need to get the ID *stored* at the 'pasta' key.
        const ministroId = gabinete[pasta]; // Directly access the ID stored for that area

        // --- 3. Call demitirMinistro if Found ---
        if (ministroId) {
            console.log(`Ministro ${ministroId} encontrado na pasta ${pasta}. Chamando demitirMinistro...`);
            // Call the main dismissal function with the found ID.
            // Decide whether to automatically open nomination modal (usually yes for gameplay flow).
            demitirMinistro(ministroId, true);
        } else {
            // Log if no minister was assigned to that specific role.
            console.warn(`Nenhum ministro encontrado na pasta '${pasta}' para demitir.`);
            // Optionally add a news item?
            // adicionarNoticia(`Tentativa de demiss√£o na pasta ${capitalize(pasta)}, mas o cargo j√° estava vago.`, "sistema");
        }
    }
    
    
    /**
     * Opens and populates the minister nomination modal.
     * Filters candidates for a specific area or the first available vacancy.
     * @param {string|null} [areaEspecifica=null] - The specific area key (e.g., 'economia') to fill. If null, finds the first vacant spot.
     */
     function iniciarNomeacao(areaEspecifica = null) {
        console.log(`Iniciando processo de nomea√ß√£o. √Årea espec√≠fica: ${areaEspecifica || 'Primeira Vaga'}`);

        // --- 1. Validation & Element Check ---
         if (!jogoAtivo || jogoPausado || eventoOrcamentoAtivo || debateAtual) {
             console.warn("Nomea√ß√£o bloqueada - jogo inativo ou em outro evento.");
             alert("N√£o √© poss√≠vel nomear ministros agora.");
             return;
         }
        const modal = document.getElementById("modal-nomeacao");
        const titulo = document.getElementById("nomeacao-titulo");
        const pastaDisplay = document.getElementById("nomeacao-pasta");
        const listaCandidatos = document.getElementById("lista-candidatos");

        if (!modal || !titulo || !pastaDisplay || !listaCandidatos) {
            console.error("Erro: Elementos do modal de Nomea√ß√£o n√£o encontrados!");
            return;
        }

        // --- 2. Determine Target Area ---
        let areaAlvo = areaEspecifica;

        // If no specific area provided, find the first vacant one
        if (!areaAlvo) {
            // Iterate through expected areas first, then any others
             const potentialAreas = [...AREAS_ORCAMENTO, ...Object.keys(gabinete)]; // Combine defined and existing
             areaAlvo = potentialAreas.find(area => gabinete[area] === null || gabinete[area] === undefined);
        }

        // Check if a valid target area was found or specified
        if (!areaAlvo || (areaEspecifica && gabinete[areaEspecifica] !== null && gabinete[areaEspecifica] !== undefined)) {
            if (areaEspecifica){
                alert(`A pasta de ${capitalize(areaEspecifica)} j√° est√° ocupada.`);
                 console.warn(`Tentativa de nomear para pasta ocupada: ${areaEspecifica}`);
            } else {
                 alert("N√£o h√° pastas vagas para nomear no momento.");
                 console.log("Nenhuma pasta vaga encontrada.");
            }
            return; // Stop if no vacant spot or specified spot is filled
        }

        console.log(`√Årea alvo para nomea√ß√£o: ${areaAlvo}`);

        // --- 3. Update Modal Titles ---
        titulo.innerText = `Nomear Ministro para ${capitalize(areaAlvo)}`;
        pastaDisplay.innerText = capitalize(areaAlvo);

        // --- 4. Find and Display Candidates ---
        listaCandidatos.innerHTML = ''; // Clear previous list

        // Get IDs of ministers currently serving in *any* capacity
        const idsMinistrosAtuaisNoGabinete = Object.values(gabinete).filter(id => id !== null);

        // Filter pool for candidates matching the target area AND not currently serving elsewhere
        const candidatos = poolMinistros.filter(m =>
            m.area === areaAlvo &&
            !idsMinistrosAtuaisNoGabinete.includes(m.id)
        );

        console.log(`Encontrados ${candidatos.length} candidatos v√°lidos para ${areaAlvo}.`);

        if (candidatos.length === 0) {
            listaCandidatos.innerHTML = '<p><i>N√£o h√° candidatos qualificados dispon√≠veis para esta pasta no momento. Tente novamente mais tarde.</i></p>';
        } else {
            // Sort candidates? Maybe by loyalty risk, or relevant bonus? Simple display for now.
            candidatos.forEach(candidato => {
                const div = document.createElement("div");
                div.className = 'gabinete-item'; // Reuse style, provides bottom border
                const partido = partidos[candidato.partidoId] || { nome: 'Ind.' };
                // Display key info: Name, Party, Primary Personality, Key Bonus?, Risk
                const primaryPersonality = candidato.personalidade ? candidato.personalidade[0] : '?';
                // Simple bonus display (needs improvement)
                let bonusText = '';
                 if(candidato.bonus) {
                     const firstBonusKey = Object.keys(candidato.bonus)[0];
                     if(firstBonusKey) bonusText = ` (+ ${firstBonusKey.replace(/_/g,' ')})`;
                 }

                div.innerHTML = `
                    <div style="flex-grow: 1;">
                        <strong>${candidato.nome}</strong> (${partido.nome.replace(" (Seu)", "")})<br>
                        <small>Perfil: ${primaryPersonality}${bonusText} | Risco Corrup.: ${candidato.riscoCorrupcao}% | Lealdade Inicial: ${candidato.lealdadeInicial}%</small>
                    </div>
                    <button class="botao botao-sucesso botao-pequeno"
                            onclick="confirmarNomeacao('${areaAlvo}', '${candidato.id}')">
                        Nomear
                    </button>
                `;
                listaCandidatos.appendChild(div);
            });
        }

        // --- 5. Display Modal ---
        modal.style.display = "block";
    }
    
    /**
     * Confirms the nomination of a minister for a specific area.
     * Updates the cabinet state, initializes the active minister,
     * applies political consequences, closes the modal, and updates UI.
     * @param {string} area - The area key (e.g., 'economia') being filled.
     * @param {string} ministroId - The ID of the chosen minister from poolMinistros.
     */
     function confirmarNomeacao(area, ministroId) {
        console.log(`Confirmando nomea√ß√£o de ${ministroId} para ${area}`);

        // --- 1. Validation ---
        if (!jogoAtivo || jogoPausado) { console.warn("Nomea√ß√£o bloqueada."); return; }
        if (!area || !gabinete.hasOwnProperty(area)) { // Check if area is a valid key in gabinete
            console.error(`√Årea de nomea√ß√£o inv√°lida: ${area}`);
            alert("Erro: √Årea ministerial inv√°lida.");
            return;
        }
        if (gabinete[area] !== null && gabinete[area] !== undefined) {
            console.warn(`Tentativa de nomear para pasta ${area} que j√° est√° ocupada por ${gabinete[area]}.`);
            alert(`A pasta de ${capitalize(area)} j√° est√° ocupada.`);
            fecharModal('modal-nomeacao'); // Close modal anyway
            return;
        }
        const ministroData = poolMinistros.find(m => m.id === ministroId);
        if (!ministroData) {
            console.error(`Dados n√£o encontrados para ministro ID: ${ministroId}`);
            alert("Erro: Candidato inv√°lido selecionado.");
            return;
        }
        // Check if minister is already serving elsewhere (should be caught by iniciarNomeacao filter, but double check)
        const isServing = Object.values(gabinete).includes(ministroId);
        if (isServing) {
             console.warn(`Ministro ${ministroId} j√° est√° servindo em outra pasta.`);
             alert(`${ministroData.nome} j√° ocupa outra pasta no gabinete.`);
             return;
        }


        // --- 2. Update Game State ---
        // 2a. Assign to Cabinet
        gabinete[area] = ministroId;

        // 2b. Initialize Active Minister State
        initializeMinistroAtivo(ministroId); // This handles adding to ministrosAtivos with loyalty etc.
        if (!ministrosAtivos[ministroId]) {
             // Should not happen if initializeMinistroAtivo works, but handle defensively
             console.error(`Falha ao inicializar estado ativo para ${ministroId} ap√≥s nomea√ß√£o!`);
             gabinete[area] = null; // Revert cabinet assignment
             alert("Erro cr√≠tico ao ativar ministro. Nomea√ß√£o cancelada.");
             fecharModal('modal-nomeacao');
             return;
        }

        // --- 3. Apply Political Consequences ---
        adicionarNoticia(`üë• GABINETE: ${ministroData.nome} foi nomeado Ministro de ${capitalize(area)}!`, "gabinete", "sucesso");

        let efeitosNomeacao = {};

        // 3a. Relation Boost with Minister's Party
        const partidoId = ministroData.partidoId;
        if (partidoId && partidoId !== liderAtual.partidoId && relacoesPartidos[partidoId] !== undefined) {
            const relationBoost = 15; // Bonus for appointing their member
            efeitosNomeacao[`relacoesPartidos_${partidoId}`] = relationBoost;
            adicionarNoticia(`Rela√ß√µes com o partido ${partidos[partidoId]?.nome || partidoId} melhoraram (+${relationBoost}).`, "sistema");

            // 3b. Potentially Add Party to Coalition? (Simplified Logic)
            // If relations are good enough after the boost, invite them?
            const currentRelation = relacoesPartidos[partidoId] + relationBoost;
            if (!coalizao.includes(partidoId) && currentRelation >= 55) { // Threshold to join
                coalizao.push(partidoId);
                adicionarNoticia(`NOVA ALIAN√áA: O partido ${partidos[partidoId]?.nome || partidoId} entrou na coaliz√£o governista!`, "sistema", "sucesso");
            }
        }

        // 3c. Minor General Pop Boost (Stability)
        efeitosNomeacao.popGeral = 1;

        // 3d. Apply effects
        aplicarEfeitos(efeitosNomeacao);

        // --- 4. Close Modal & Update UI ---
        fecharModal('modal-nomeacao');
        calcularApoioCongresso(); // Recalculate support with potential new coalition member/relation change
        atualizarUI(); // Refresh display

        // Optional: Re-open cabinet modal briefly to show the change?
        // setTimeout(mostrarModalGabinete, 300);
    }
    
    /**
     * Populates and displays the Political Parties and Coalition modal.
     */
     function mostrarModalPartidos() {
        console.log("Mostrando modal de Partidos...");

        // --- 1. Get Elements ---
        const modal = document.getElementById("modal-partidos");
        const listaPartidos = document.getElementById("lista-partidos");
        const coalizaoAtualSpan = document.getElementById("coalizao-atual");

        if (!modal || !listaPartidos || !coalizaoAtualSpan) {
            console.error("Erro: Elementos do modal de Partidos n√£o encontrados!");
            return;
        }
         if (!partidos || Object.keys(partidos).length === 0) {
             console.error("Estado 'partidos' n√£o inicializado corretamente.");
             listaPartidos.innerHTML = "<p>Erro ao carregar dados dos partidos.</p>";
             coalizaoAtualSpan.innerText = "Erro";
             modal.style.display = "block";
             return;
         }

        // --- 2. Clear Previous Content ---
        listaPartidos.innerHTML = '';

        // --- 3. Update Coalition Display ---
        if (coalizao && coalizao.length > 0) {
            coalizaoAtualSpan.innerText = coalizao
                .map(id => partidos[id]?.nome || capitalize(id)) // Get name or fallback
                .join(', ');
        } else {
            coalizaoAtualSpan.innerText = "Nenhum (Governo Minorit√°rio)";
        }

        // --- 4. Populate Party List ---
        // Sort parties? Maybe by strength or relation? Alphabetical for now.
        const sortedPartyIds = Object.keys(partidos).sort((a, b) => {
             // Put player's party first, then sort others by name
             if (a === liderAtual.partidoId) return -1;
             if (b === liderAtual.partidoId) return 1;
             return (partidos[a]?.nome || a).localeCompare(partidos[b]?.nome || b);
        });

        sortedPartyIds.forEach(partidoId => {
            // Skip the generic 'Independents' meta-party for detailed listing
            if (partidoId === "partido_independente") return;

            const partido = partidos[partidoId];
            const div = document.createElement("div");
            div.className = 'partido-item'; // Styling class

            const isPlayerParty = (partidoId === liderAtual.partidoId);
            const isInCoalition = coalizao.includes(partidoId);
            const relation = isPlayerParty ? 100 : (relacoesPartidos[partidoId] || 50); // Player relation to them

            let relationClass = 'valor-neutro';
            if (relation > 65) relationClass = 'valor-positivo';
            else if (relation < 35) relationClass = 'valor-negativo';

            let statusText = '';
            if (isPlayerParty) {
                statusText = `<span style="color: cyan; font-weight: bold;"> (Seu Partido)</span>`;
            } else if (isInCoalition) {
                statusText = ` <span style="color: lightgreen;">(Na Coaliz√£o)</span>`;
            } else {
                 statusText = ` <span style="color: lightcoral;">(Oposi√ß√£o)</span>`;
                 // Optionally add a button to negotiate coalition entry?
                 // if (relation > 45) { // Example threshold to allow negotiation
                 //     statusText += `<button class="botao botao-pequeno sucesso" onclick="negociarCoalizao('${partidoId}')">Convidar</button>`;
                 // }
            }

            div.innerHTML = `
                <div style="flex-grow: 1;">
                    <strong>${partido.nome.replace(" (Seu)", "")}</strong> (${partido.ideologia || '?'})
                    <small style="display: block; color: #bbb;">For√ßa Base: ${partido.forcaBaseCongresso}%</small>
                </div>
                ${!isPlayerParty ? `<span class="${relationClass}" style="min-width: 80px; text-align: right;">Rela√ß√£o: ${relation}%</span>` : ''}
                <div style="min-width: 110px; text-align: right;">${statusText}</div>
            `;
            listaPartidos.appendChild(div);
        }); // End forEach party

        // --- 5. Display Modal ---
        modal.style.display = "block";
    }

    /**
     * Placeholder function for initiating coalition negotiation.
     * In a full implementation, this would trigger events or require choices.
     * @param {string} partidoId - The ID of the party to negotiate with.
     */
    function negociarCoalizao(partidoId) {
        alert(`Negociar com ${partidos[partidoId]?.nome}? (L√≥gica de negocia√ß√£o n√£o implementada)`);
        // TODO: Implement negotiation logic:
        // - Check conditions (relation threshold, ideological compatibility)
        // - Cost political capital / budget?
        // - Offer ministry posts? (Requires linking choices here)
        // - Success chance based on factors
        // - If successful: add partidoId to coalizao, update relations, recalculate congress, add news
    }
    
    /**
     * Calculates the player's current support percentage in Congress.
     * Considers coalition members, player's relationship with them,
     * and a small influence from independents based on general popularity.
     * Updates the global `congresso` variable.
     */
     function calcularApoioCongresso() {
        let apoioTotalCalculado = 0;
        let detalhesCalculo = []; // For logging/debugging

        // --- 1. Safety Checks ---
        if (!Array.isArray(coalizao)) {
            console.error("calcularApoioCongresso: Estado 'coalizao' inv√°lido.");
            coalizao = liderAtual?.partidoId ? [liderAtual.partidoId] : []; // Attempt recovery
        }
        if (!partidos || typeof relacoesPartidos !== 'object') {
             console.error("calcularApoioCongresso: Estado 'partidos' ou 'relacoesPartidos' inv√°lido.");
             congresso = 30; // Assign a low default on error
             return; // Cannot calculate accurately
        }

        // --- 2. Iterate Through Coalition Parties ---
        // Keep track of parties leaving mid-calculation
        let partidosSairamNestaRodada = [];

        coalizao.forEach(partidoId => {
            const partido = partidos[partidoId];
            if (!partido) {
                console.warn(`Partido ${partidoId} na coaliz√£o n√£o encontrado nos dados de partidos.`);
                return; // Skip if party data is missing
            }

            let contribuicao = 0;
            let relacao = 50; // Default relation if missing

            if (partidoId === liderAtual.partidoId) {
                // Player's own party always contributes full base strength
                contribuicao = partido.forcaBaseCongresso || 0;
                relacao = 100; // Effective relation is 100%
                detalhesCalculo.push(`${partido.nome}: ${contribuicao.toFixed(1)}% (Base)`);
            } else {
                relacao = relacoesPartidos[partidoId];
                if (relacao === undefined || relacao === null) {
                     console.warn(`Rela√ß√£o com ${partido.nome} (${partidoId}) n√£o definida, usando 50.`);
                     relacao = 50;
                }

                // --- Check if party leaves coalition ---
                const LIMITE_SAIDA_COALIZAO = 25; // Threshold below which a party leaves
                if (relacao < LIMITE_SAIDA_COALIZAO) {
                    partidosSairamNestaRodada.push(partidoId);
                    adicionarNoticia(`FIM DA ALIAN√áA! O partido ${partido.nome} deixou a coaliz√£o por baixa rela√ß√£o (${relacao}%)!`, "sistema", "perigo");
                    contribuicao = 0; // They contribute nothing if they leave
                    detalhesCalculo.push(`${partido.nome}: Saiu! (Rel: ${relacao}%)`);
                } else {
                    // --- Calculate contribution based on relation ---
                    // Formula: Base Strength * Relation Factor
                    // Relation Factor example: 0% rel -> 0% contribution, 50% rel -> 50% contribution, 100% rel -> 100% contribution
                    const fatorRelacao = relacao / 100;
                    contribuicao = (partido.forcaBaseCongresso || 0) * fatorRelacao;
                    detalhesCalculo.push(`${partido.nome}: ${contribuicao.toFixed(1)}% (Base ${partido.forcaBaseCongresso}%, Rel ${relacao}%)`);
                }
            }
            apoioTotalCalculado += contribuicao;
        }); // End forEach coalition member

        // --- 3. Remove Parties That Left ---
        if (partidosSairamNestaRodada.length > 0) {
             coalizao = coalizao.filter(pid => !partidosSairamNestaRodada.includes(pid));
             console.log("Coaliz√£o atualizada ap√≥s sa√≠das:", coalizao);
        }

        // --- 4. Add Support from Independents ---
        // Simplified: Based on general average popularity
        const popMedia = calcularPopularidadeGeral();
        const forcaBaseIndependente = partidos["partido_independente"]?.forcaBaseCongresso || 0;
        // Factor: 0% pop -> 0% support, 50% pop -> 50% support, 100% pop -> 100% support
        const fatorPop = popMedia / 100;
        const apoioIndependente = forcaBaseIndependente * fatorPop;
        apoioTotalCalculado += apoioIndependente;
        if (apoioIndependente > 0) {
            detalhesCalculo.push(`Independentes: ${apoioIndependente.toFixed(1)}% (Pop: ${popMedia}%)`);
        }

        // --- 5. Apply Temporary Modifiers? ---
        // Could add temporary bonus/malus from recent events or leader skills here
        // Example: if (lider.habilidades?.includes('articulador_congresso')) apoioTotalCalculado += 2;

        // --- 6. Final Calculation & State Update ---
        const novoApoioCongresso = clamp(Math.round(apoioTotalCalculado), 0, 100); // Clamp final value

        // Optional: Log change if significant
        if (Math.abs(novoApoioCongresso - congresso) > 1) {
            console.log(`Apoio no Congresso recalculado: ${congresso}% -> ${novoApoioCongresso}%. Detalhes: [${detalhesCalculo.join(' | ')}]`);
        }

        congresso = novoApoioCongresso; // Update the global state variable

        // --- 7. Update UI ---
        // The update is handled by atualizarPainelCongresso, which is called by atualizarUI.
        // No direct UI update needed here.
    }


    // --- Budget Event --- (Defined before game loop)
    /**
     * Initiates the annual budget definition event.
     * Pauses the game, copies the current budget to the proposal state,
     * populates and displays the budget modal (#modal-orcamento).
     */
    function iniciarEventoOrcamentoAnual() {
        console.log("--- Iniciando Evento de Or√ßamento Anual ---");

        // --- 1. Validation & State Check ---
        if (!jogoAtivo || jogoPausado) { console.warn("Or√ßamento bloqueado - jogo inativo/pausado."); return; }
        if (eventoOrcamentoAtivo) { console.warn("Evento de or√ßamento j√° est√° ativo."); return; } // Prevent re-triggering
        if (debateAtual) { alert("Conclua o debate antes de definir o or√ßamento."); return; } // Block if in debate
        if (!orcamentoAlocado || Object.keys(orcamentoAlocado).length === 0) {
            console.error("CRITICAL: orcamentoAlocado n√£o est√° definido! N√£o √© poss√≠vel iniciar evento de or√ßamento.");
            alert("Erro interno [ORC_ALLOC_UNDEF]. N√£o √© poss√≠vel definir o or√ßamento.");
            return;
        }

        // --- 2. Set Flags & Prepare Proposal ---
        eventoOrcamentoAtivo = true; // Flag to pause normal dilemmas/events
        jogoPausado = true; // Use general pause flag too for extra safety? Maybe not needed if event flag is checked.
        propostaOrcamento = JSON.parse(JSON.stringify(orcamentoAlocado)); // Deep copy current budget as starting point

        // --- 3. Get Modal Elements ---
        const modal = document.getElementById("modal-orcamento");
        const categoriasDiv = document.getElementById("orcamento-categorias");
        const tesouroAtualEl = document.getElementById('orc-tesouro-atual');
        const congressoAtualEl = document.getElementById('orc-congresso-atual');
        // Buttons inside modal for listeners
        const btnSubmeter = document.getElementById('btn-submeter-orcamento');
        const btnCancelar1 = document.getElementById('btn-cancelar-orcamento'); // Close button X
        const btnCancelar2 = document.getElementById('btn-cancelar-orcamento-2'); // Cancel button

        if (!modal || !categoriasDiv || !tesouroAtualEl || !congressoAtualEl || !btnSubmeter || !btnCancelar1 || !btnCancelar2) {
            console.error("Erro: Elementos do modal de Or√ßamento (#modal-orcamento ou internos) n√£o encontrados!");
            eventoOrcamentoAtivo = false; // Reset flag on error
            jogoPausado = false;
            return;
        }

        // --- 4. Populate Modal ---
        console.log("Populando modal de or√ßamento...");
        categoriasDiv.innerHTML = ''; // Clear previous content (sliders/inputs)
        tesouroAtualEl.innerText = formatCurrency(tesouro);
        congressoAtualEl.innerText = `${congresso}%`;

        // Create sliders/inputs for each budget category
        AREAS_ORCAMENTO.forEach(area => {
            const valorAtual = propostaOrcamento[area] || 0; // Default to 0 if area is new
            // Define min/max for slider/input (allow reasonable changes)
            // Min could be 0 or a small % of current. Max could be % increase or absolute cap?
            const minVal = 0; // Allow zeroing out budget? Risky. Maybe Math.max(0, Math.round(valorAtual * 0.2));
            const maxVal = Math.round(valorAtual * 2 + 50); // Allow doubling + 50M increase, adjust as needed

            const div = document.createElement("div");
            div.style.marginBottom = '15px'; // Spacing for each category control
            div.innerHTML = `
                <label for="orc-${area}" style="display: block; margin-bottom: 3px; font-weight: bold;">${capitalize(area)}:</label>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <input type="range" id="orc-${area}" name="${area}"
                           min="${minVal}" max="${maxVal}" value="${valorAtual}" step="1"
                           style="flex-grow: 1; height: 5px;"
                           oninput="updateOrcamentoValue(this, '${area}')">
                    <span id="val-orc-${area}" style="font-weight: bold; min-width: 70px; text-align: right;">
                        ${formatCurrency(valorAtual)}
                    </span>
                     <!-- Optional: Add +/- buttons for fine control -->
                     <!-- <button onclick="adjustBudgetValue('${area}', -5)">-5</button> -->
                     <!-- <button onclick="adjustBudgetValue('${area}', +5)">+5</button> -->
                </div>
            `;
            categoriasDiv.appendChild(div);
        }); // End forEach area

        // --- 5. Attach Button Listeners (if not already attached globally) ---
        // It's safer to attach/remove listeners specifically for the modal lifecycle
        // Remove previous listeners if any (important if modal can be opened multiple times)
        btnSubmeter.replaceWith(btnSubmeter.cloneNode(true)); // Clone node removes old listeners
        document.getElementById('btn-submeter-orcamento').addEventListener('click', submeterOrcamentoAoCongresso);

        btnCancelar1.replaceWith(btnCancelar1.cloneNode(true));
        document.getElementById('btn-cancelar-orcamento').addEventListener('click', cancelarOrcamento);

        btnCancelar2.replaceWith(btnCancelar2.cloneNode(true));
        document.getElementById('btn-cancelar-orcamento-2').addEventListener('click', cancelarOrcamento);


        // --- 6. Calculate Initial Totals & Display Modal ---
        atualizarTotaisModalOrcamento(); // Calculate initial totals based on copied budget
        modal.style.display = "block";
        adicionarNoticia("üóìÔ∏è HORA DO OR√áAMENTO! Defina os gastos para o pr√≥ximo ano.", "sistema", "aviso");
        console.log("Modal de or√ßamento exibido. Jogo pausado para or√ßamento.");

        // Update main UI to disable other actions
        atualizarUI(); // Ensure buttons like travel are disabled
    }

    /**
     * Updates the value display and recalculates totals when a budget slider/input changes.
     * Called by the oninput event of the range inputs.
     * @param {HTMLInputElement} inputElement - The input element that changed.
     * @param {string} area - The budget area key corresponding to the input.
     */
    function updateOrcamentoValue(inputElement, area) {
        if (!propostaOrcamento) return; // Should not happen if modal is open

        const newValue = parseInt(inputElement.value, 10);
        propostaOrcamento[area] = newValue; // Update the temporary proposal object

        // Update the displayed value next to the slider
        const valueSpan = document.getElementById(`val-orc-${area}`);
        if (valueSpan) {
            valueSpan.innerText = formatCurrency(newValue);
        }

        // Recalculate and update the totals/support needed display
        atualizarTotaisModalOrcamento();
    }

    /**
     * Recalculates and updates the total proposed spending, projected balance,
     * and estimated Congress support needed within the budget modal.
     */
    function atualizarTotaisModalOrcamento() {
        if (!propostaOrcamento) return; // Safety check

        // --- Calculate Totals ---
        let totalProposto = 0;
        for (const area in propostaOrcamento) {
            totalProposto += propostaOrcamento[area] || 0;
        }
        // Estimate next round's expense/revenue based on proposal (Simplified - ignores future inflation/unemp changes)
        const despesaEstimadaProposta = totalProposto + despesasFixasPorRodada;
        const receitaEstimada = calcularReceitaAtual(); // Use current round's estimated revenue projection
        const saldoProjetado = receitaEstimada - despesaEstimadaProposta;

        // --- Estimate Support Needed ---
        const suporteNecessario = calculateBudgetSupportNeeded(propostaOrcamento, orcamentoAlocado); // Compare proposal to *current* allocation

        // --- Update Modal Displays ---
        const totalEl = document.getElementById('orc-total-proposto');
        const saldoEl = document.getElementById('orc-saldo-projetado');
        const suporteEl = document.getElementById('orc-suporte-necessario');

        if(totalEl) totalEl.innerText = formatCurrency(totalProposto);
        if(saldoEl) {
             saldoEl.innerText = formatCurrency(saldoProjetado);
             saldoEl.className = saldoProjetado >= 0 ? 'valor-positivo' : 'valor-negativo';
        }
        if(suporteEl) {
             suporteEl.innerText = `~${suporteNecessario}%`;
             suporteEl.className = congresso >= suporteNecessario ? 'valor-positivo' : 'valor-negativo';
        }
    }
    
    /**
     * Updates the temporary budget proposal object and the displayed value
     * when a budget slider/input changes within the budget modal.
     * Also recalculates and updates the displayed totals and required support.
     * Called by the oninput event of the range inputs.
     * @param {HTMLInputElement} inputElement - The input element (range slider) that changed.
     * @param {string} area - The budget area key (e.g., 'saude') corresponding to the input.
     */
     function updateOrcamentoValue(inputElement, area) {
        // --- 1. Validation ---
        // Ensure the temporary proposal object exists (it should if the modal is open)
        if (!propostaOrcamento) {
            console.error("updateOrcamentoValue chamado mas propostaOrcamento √© nulo!");
            return;
        }
        // Ensure the area key is valid for the proposal object
        if (propostaOrcamento[area] === undefined) {
            console.warn(`updateOrcamentoValue: √Årea '${area}' n√£o encontrada na proposta de or√ßamento.`);
            // Initialize it if it was missing? Or ignore? Ignoring is safer.
            return;
        }

        // --- 2. Get and Update Value ---
        // Get the numerical value from the input (sliders usually return strings)
        const newValue = parseInt(inputElement.value, 10);

        // Check if the value is a valid number
        if (isNaN(newValue)) {
            console.error(`Valor inv√°lido recebido do input para ${area}:`, inputElement.value);
            // Optionally reset input to previous value?
            // inputElement.value = propostaOrcamento[area];
            return;
        }

        // Update the value in the temporary proposal object
        propostaOrcamento[area] = newValue;

        // --- 3. Update Displayed Value Next to Slider ---
        const valueSpan = document.getElementById(`val-orc-${area}`);
        if (valueSpan) {
            valueSpan.innerText = formatCurrency(newValue);
        } else {
            console.warn(`Span 'val-orc-${area}' n√£o encontrado para atualizar valor.`);
        }

        // --- 4. Recalculate and Update Totals ---
        // Call the function that handles the summary display in the modal
        atualizarTotaisModalOrcamento();
    }
    
    /**
     * Recalculates and updates the summary display (Total Proposed,
     * Projected Balance, Required Support) within the budget modal based
     * on the current values in the `propostaOrcamento` object.
     */
     function atualizarTotaisModalOrcamento() {
        // --- 1. Safety Check & Get Elements ---
        if (!propostaOrcamento || !jogoAtivo) {
            // console.warn("atualizarTotaisModalOrcamento: Proposta de or√ßamento n√£o dispon√≠vel ou jogo inativo.");
            return; // Exit if proposal object doesn't exist or game isn't running
        }

        const totalEl = document.getElementById('orc-total-proposto');
        const saldoEl = document.getElementById('orc-saldo-projetado');
        const suporteEl = document.getElementById('orc-suporte-necessario');

        if (!totalEl || !saldoEl || !suporteEl) {
            console.error("Erro: Elementos de totais do modal de or√ßamento n√£o encontrados!");
            return;
        }

        // --- 2. Calculate Total Proposed Spending ---
        let totalProposto = 0;
        for (const area in propostaOrcamento) {
            // Ensure value is a number, default to 0 if somehow invalid
            totalProposto += Number(propostaOrcamento[area]) || 0;
        }

        // --- 3. Estimate Projected Balance ---
        // This uses the *current* round's estimated revenue and fixed costs
        // It does NOT try to predict inflation/unemployment changes for the *next* round
        const despesaEstimadaProposta = totalProposto + (despesasFixasPorRodada || 0);
        const receitaEstimada = calcularReceitaAtual(); // Get current projection
        const saldoProjetado = receitaEstimada - despesaEstimadaProposta;

        // --- 4. Estimate Required Congress Support ---
        // Compares the proposed budget total to the *currently active* allocated budget total
        const suporteNecessario = calculateBudgetSupportNeeded(propostaOrcamento, orcamentoAlocado);

        // --- 5. Update Modal Display Elements ---
        totalEl.innerText = formatCurrency(totalProposto);

        saldoEl.innerText = formatCurrency(saldoProjetado);
        saldoEl.className = saldoProjetado >= 0 ? 'valor-positivo' : 'valor-negativo'; // Update color

        suporteEl.innerText = `~${suporteNecessario}%`;
        // Update color based on whether current congress support meets the need
        suporteEl.className = congresso >= suporteNecessario ? 'valor-positivo' : 'valor-negativo';
        suporteEl.title = `Seu apoio atual no congresso √© ${congresso}%`; // Add tooltip

        // console.log(`Totais Or√ßamento Modal Atualizados: Total=${totalProposto}, Saldo=${saldoProjetado}, SuporteNec=${suporteNecessario}% (Atual ${congresso}%)`); // Optional log
    }
    
    /**
     * Estimates the percentage of Congress support needed to pass a proposed budget.
     * Compares the total spending of the proposed budget to the current one
     * and applies penalties/bonuses based on changes, deficit, and leader skills.
     * @param {Object} proposed - The temporary budget proposal object (e.g., `propostaOrcamento`).
     * @param {Object} current - The currently active budget allocation object (e.g., `orcamentoAlocado`).
     * @returns {number} The estimated percentage of support needed (clamped).
     */
     function calculateBudgetSupportNeeded(proposed, current) {
        // --- 1. Set Base and Calculate Totals ---
        let baseSupport = 50; // Default support needed for a status quo budget

        let currentTotal = 0;
        if (current && typeof current === 'object') {
            for (const area in current) {
                currentTotal += Number(current[area]) || 0;
            }
        } else {
            // If current budget is invalid, assume a baseline average total for comparison
            currentTotal = (AREAS_ORCAMENTO.length || 8) * (150 / (AREAS_ORCAMENTO.length || 8)); // Approx 150M total
            console.warn("calculateBudgetSupportNeeded: Current budget invalid, using estimate.");
        }


        let proposedTotal = 0;
        if (proposed && typeof proposed === 'object') {
            for (const area in proposed) {
                proposedTotal += Number(proposed[area]) || 0;
            }
        } else {
             console.error("calculateBudgetSupportNeeded: Proposed budget invalid!");
             return 60; // Return a higher requirement if proposal is broken
        }


        // --- 2. Calculate Penalty/Bonus for Spending Change ---
        // Avoid division by zero if current total is 0
        const percentChange = currentTotal === 0 ? (proposedTotal > 0 ? 100 : 0) : ((proposedTotal - currentTotal) / currentTotal) * 100;

        // Apply modifier: +/- 1% support needed for every ~4-5% change in total budget size? More sensitive to increases?
        let changeModifier = 0;
        if (percentChange > 5) { // Increased spending
            changeModifier = Math.round(percentChange / 4); // More support needed for big increases
        } else if (percentChange < -5) { // Decreased spending (cuts)
            changeModifier = Math.round(percentChange / 6); // Slightly less opposition for moderate cuts? Very deep cuts might increase opposition again (more complex)
        }
         // Limit the impact of this modifier
         changeModifier = clamp(changeModifier, -10, 15);


        // --- 3. Calculate Penalty for Projected Deficit ---
        // Estimate deficit based on proposed spending
        const receitaEstimada = calcularReceitaAtual(); // Current revenue projection
        const despesaEstimadaProposta = proposedTotal + (despesasFixasPorRodada || 0);
        const saldoProjetado = receitaEstimada - despesaEstimadaProposta;
        let deficitPenalty = 0;

        if (saldoProjetado < -20) { // Small deficit penalty starts
             deficitPenalty += 2;
        }
        if (saldoProjetado < -80) { // Moderate deficit penalty
            deficitPenalty += 4;
        }
        if (saldoProjetado < -200) { // Large deficit penalty
            deficitPenalty += 6;
        }
         // Maximum penalty for deficit
         deficitPenalty = Math.min(deficitPenalty, 12);

        // --- 4. Apply Leader Skill/Trait Modifiers ---
        let skillModifier = 0;
        if (lider.habilidades?.includes('negociador_experiente')) {
            skillModifier -= 4; // Skill makes approval easier
        }
        if (lider.habilidades?.includes('articulador_partidario')) {
             skillModifier -= 2; // Skill makes approval easier
        }
        if (lider.tracos?.includes('Pragm√°tico')) {
            skillModifier -= 1; // Trait helps slightly
        }
         if (lider.tracos?.includes('Idealista') && Math.abs(percentChange) > 15) {
             skillModifier += 2; // Idealists might struggle more with large, pragmatic shifts
         }


        // --- 5. Calculate Final Required Support ---
        const finalSupport = baseSupport + changeModifier + deficitPenalty + skillModifier;

        // --- 6. Clamp and Return ---
        const clampedSupport = clamp(finalSupport, 30, 85); // Ensure required support is within reasonable bounds (e.g., 30% to 85%)

         // console.log(`Budget Support Needed: Base=${baseSupport}, ChangeMod=${changeModifier}(${percentChange.toFixed(1)}%), DeficitPen=${deficitPenalty}, SkillMod=${skillModifier} => Final=${finalSupport} => Clamped=${clampedSupport}`); // Debug log

        return clampedSupport;
    }
    
    /**
     * Submits the proposed budget (`propostaOrcamento`) for congressional approval.
     * Compares current support (`congresso`) with the calculated required support.
     * Applies the outcome (approve/reject), updates state, closes the modal,
     * provides feedback, and resumes the game loop.
     */
     function submeterOrcamentoAoCongresso() {
        console.log("Submetendo or√ßamento ao Congresso...");

        // --- 1. Validation ---
        if (!jogoAtivo || !eventoOrcamentoAtivo || !propostaOrcamento) {
            console.warn("submeterOrcamentoAoCongresso chamado em estado inv√°lido.");
            // Ensure flags are reset if something went wrong
            eventoOrcamentoAtivo = false;
            jogoPausado = false;
            propostaOrcamento = null;
            fecharModal('modal-orcamento');
            return;
        }

        // --- 2. Calculate Required Support ---
        // Recalculate one last time to be sure it reflects the final proposal
        const suporteNecessario = calculateBudgetSupportNeeded(propostaOrcamento, orcamentoAlocado);
        console.log(`Apoio Atual: ${congresso}%, Suporte Necess√°rio: ${suporteNecessario}%`);

        // --- 3. Determine Approval Chance & Outcome ---
        // Add a small element of chance, influenced by the gap and maybe leader skills
        let chanceAprovacaoBase = 0.5; // Start at 50/50 if support is exactly met
        const diffSuporte = congresso - suporteNecessario;

        // Adjust base chance based on support difference (non-linear?)
        // Example: More likely to pass if support is higher, more likely to fail if lower
        chanceAprovacaoBase += diffSuporte * 0.03; // +/- 3% chance per % point difference

        // Leader Skill Modifier (Negociador / Articulador)
        if (lider.habilidades?.includes('negociador_experiente')) chanceAprovacaoBase += 0.05;
        if (lider.habilidades?.includes('articulador_partidario')) chanceAprovacaoBase += 0.03;

        // Clamp probability
        const chanceAprovacaoFinal = clamp(chanceAprovacaoBase, 0.05, 0.95); // 5% to 95% chance

        const roll = Math.random();
        const aprovado = roll < chanceAprovacaoFinal;

        console.log(`Chance Aprova√ß√£o Base: ${chanceAprovacaoBase.toFixed(2)}, Final: ${chanceAprovacaoFinal.toFixed(2)}, Roll: ${roll.toFixed(2)} -> Aprovado: ${aprovado}`);

        // --- 4. Apply Outcome ---
        let feedbackMsg = "";
        let feedbackClass = "";
        let efeitosResultado = {};

        if (aprovado) {
            feedbackMsg = "Or√ßamento Anual APROVADO pelo Congresso!";
            feedbackClass = "sucesso";
            console.log("Or√ßamento Aprovado.");

            // Adopt the new budget
            orcamentoAlocado = { ...propostaOrcamento }; // Adopt the proposal

            // Apply small positive effects for success
            efeitosResultado = { popGeral: +2, popEmpresarios: +1, congresso_mod: +1 }; // Slight congress boost for success

            // Check achievement
            checkAchievement('orcamento_aprovado');

        } else { // Rejected
            feedbackMsg = "Or√ßamento Anual REJEITADO pelo Congresso! O or√ßamento anterior ser√° mantido.";
            feedbackClass = "perigo";
            console.log("Or√ßamento Rejeitado.");

            // Keep the old `orcamentoAlocado`

            // Apply penalties for failure
            efeitosResultado = { popGeral: -5, congresso: -5 }; // Direct hit to congress support

            // Apply relation hit to coalition partners
             coalizao.forEach(pid => {
                  if (pid !== liderAtual.partidoId) {
                      efeitosResultado[`relacoesPartidos_${pid}`] = -5; // Penalty with allies
                  }
             });
            adicionarNoticia("A falha na aprova√ß√£o do or√ßamento abalou a confian√ßa da coaliz√£o.", "sistema", "aviso");
        }

        // --- 5. Cleanup State & UI ---
        eventoOrcamentoAtivo = false; // End budget event
        jogoPausado = false; // Resume game loop potential
        propostaOrcamento = null; // Clear proposal state
        fecharModal('modal-orcamento'); // Close the modal

        // --- 6. Provide Feedback & Apply Effects ---
        adicionarNoticia(feedbackMsg, "sistema", feedbackClass);
        aplicarEfeitos(efeitosResultado);

        // --- 7. Update UI & Resume Game ---
        calcularApoioCongresso(); // Recalculate support after potential hits
        atualizarUI(); // Refresh the entire UI

        // Schedule the next turn (important!)
        setTimeout(proximoTurno, 150);
    }
    
    /**
     * Cancels the annual budget definition process.
     * Resets budget event flags, closes the modal, provides feedback,
     * and resumes the game loop with the existing budget unchanged.
     */
     function cancelarOrcamento() {
        console.log("Cancelando defini√ß√£o do or√ßamento anual...");

        // --- 1. Validation (Optional but good practice) ---
        // Check if we are actually in the budget event
        if (!eventoOrcamentoAtivo) {
            console.warn("cancelarOrcamento chamado quando o evento de or√ßamento n√£o estava ativo.");
            // Might still want to ensure modal is closed and flags are reset
        }

        // --- 2. Reset Flags & State ---
        eventoOrcamentoAtivo = false; // Signal budget event is over
        jogoPausado = false; // Allow game loop to resume fully
        propostaOrcamento = null; // Discard any changes made in the modal

        // --- 3. Close Modal ---
        fecharModal('modal-orcamento');

        // --- 4. Provide Feedback ---
        adicionarNoticia("Defini√ß√£o do or√ßamento cancelada. O or√ßamento atual ser√° mantido para o pr√≥ximo ano.", "sistema", "aviso");

        // --- 5. Update UI & Resume Game ---
        // Update UI mainly to re-enable any buttons disabled by the budget event
        atualizarUI();

        // Schedule the next turn (important!)
        console.log("Or√ßamento cancelado, agendando pr√≥ximo turno.");
        setTimeout(proximoTurno, 150);
    }

    // --- Foreign Policy --- (Defined before game loop/actions)
    /**
     * Initializes the `relacoesPaises` state object.
     * Sets the starting relationship value for each defined foreign country
     * based on a default value plus modifiers according to the player's
     * leader type/ideology defined in `paises[id].relacaoInicialMod`.
     */
    function initializeForeignRelations() {
        console.log("Inicializando rela√ß√µes internacionais...");

        // --- 1. Reset Relations Object ---
        relacoesPaises = {}; // Clear any previous data

        // --- 2. Safety Checks ---
        if (!liderAtual || !liderAtual.tipo || !liderAtual.partidoId) {
            console.error("initializeForeignRelations: liderAtual n√£o definido corretamente. Usando rela√ß√µes padr√£o (50).");
            // Proceed with default 50 for all if leader info is missing
        }
        if (!paises || Object.keys(paises).length === 0) {
            console.warn("initializeForeignRelations: Nenhum pa√≠s estrangeiro definido em 'paises'. Rela√ß√µes estar√£o vazias.");
            return; // Nothing to initialize
        }

        // --- 3. Get Player Ideology ---
        // Use party ideology if available, otherwise fall back to leader type
        const playerIdeology = partidos[liderAtual?.partidoId]?.ideologia || liderAtual?.tipo || 'Pragm√°tico'; // Default if needed
        console.log(`Ideologia do jogador para rela√ß√µes iniciais: ${playerIdeology}`);

        // --- 4. Iterate Through Defined Countries ---
        for (const paisId in paises) {
            const pais = paises[paisId];
            let initialRelation = 50; // Default starting relation

            // Check if this country has modifiers defined
            if (pais.relacaoInicialMod && typeof pais.relacaoInicialMod === 'object') {
                // Check if there's a specific modifier for the player's ideology
                if (pais.relacaoInicialMod[playerIdeology] !== undefined) {
                    initialRelation += pais.relacaoInicialMod[playerIdeology];
                    console.log(` -> Modificador para ${pais.nome} (${paisId}) baseado em ${playerIdeology}: ${pais.relacaoInicialMod[playerIdeology]}`);
                } else {
                    // Optional: Apply a generic modifier if ideology doesn't match exactly?
                    // e.g., if player is CenterLeft and country mods only have Left/Right?
                    // For now, we only use exact matches or the default 50.
                    console.log(` -> Sem modificador espec√≠fico para ${playerIdeology} com ${pais.nome}. Usando base.`);
                }
            } else {
                 console.log(` -> Sem modificadores definidos para ${pais.nome}. Usando base.`);
            }

            // --- 5. Set Clamped Relation Value ---
            relacoesPaises[paisId] = clamp(initialRelation, 10, 90); // Clamp initial relations (e.g., 10-90 range)

        } // End for each country

        console.log("Rela√ß√µes internacionais iniciais definidas:", relacoesPaises);

        // --- 6. Initialize Active Blocs (Optional) ---
        // Can check here if player starts in any blocs based on initial relations/ideology
        blocosAtivos = {}; // Reset active blocs
        for (const blocId in blocos) {
             // Example: Automatically join if initial relation with all members is high enough?
             // Simple version: Just copy initial members from definition
             blocosAtivos[blocId] = {
                  nome: blocos[blocId].nome,
                  membros: [...(blocos[blocId].membrosIniciais || [])] // Copy initial members
             };
             // Check if player meets conditions to start *in* the bloc (more complex)
        }
        console.log("Blocos ativos inicializados (base):", blocosAtivos);


    }
    
    /**
     * Populates and displays the Foreign Policy / Diplomacy modal.
     * Shows relations with countries, active blocs/treaties, and action buttons.
     */
     function mostrarModalDiplomacia() {
        console.log("Mostrando modal de Diplomacia...");

        // --- 1. Get Elements & Validate ---
        const modal = document.getElementById("modal-diplomacia");
        const divPaises = document.getElementById("diplomacia-paises");
        const divBlocos = document.getElementById("diplomacia-blocos");
        const divTratados = document.getElementById("diplomacia-tratados");
        // Close button listener is usually attached globally or via class 'btn-fechar-modal'

        if (!modal || !divPaises || !divBlocos || !divTratados) {
            console.error("Erro: Elementos do modal de Diplomacia n√£o encontrados!");
            return;
        }
         if (typeof relacoesPaises !== 'object' || typeof blocos !== 'object' || !Array.isArray(tratadosAtivos)) {
             console.error("Erro: Estado de pol√≠tica externa n√£o inicializado corretamente.");
             alert("Erro ao carregar dados de diplomacia.");
             return;
         }

        // --- 2. Clear Previous Content ---
        divPaises.innerHTML = '';
        divBlocos.innerHTML = '';
        divTratados.innerHTML = '';

        // --- 3. Populate Countries List & Actions ---
        const paisIds = Object.keys(paises || {});
        if (paisIds.length === 0) {
             divPaises.innerHTML = '<p>Nenhum pa√≠s estrangeiro definido.</p>';
        } else {
            paisIds.forEach(paisId => {
                const pais = paises[paisId];
                const relacao = relacoesPaises[paisId] || 50;
                let relationClass = 'valor-neutro';
                if (relacao > 65) relationClass = 'valor-positivo';
                else if (relacao < 35) relationClass = 'valor-negativo';

                const div = document.createElement('div');
                div.className = 'diplomacia-item'; // Consistent styling class
                div.innerHTML = `
                    <div style="flex-grow: 1;">
                        <strong>${pais.nome}</strong> (${pais.ideologia})<br>
                        <small class="${relationClass}">Rela√ß√£o: ${relacao}% | Econ: ${pais.forcaEconomica}/10 | Mil: ${pais.forcaMilitar}/10</small>
                    </div>
                    <div class="painel-acoes" style="margin-top: 0; flex-direction: column; align-items: flex-end;">
                        <button class="botao botao-pequeno info" onclick="proporAcordoDiplomatico('${paisId}', 'Comercial')" title="Propor Acordo Comercial">Com√©rcio</button>
                        <button class="botao botao-pequeno info" onclick="proporAcordoDiplomatico('${paisId}', 'Militar')" title="Propor Acordo Militar">Militar</button>
                        <button class="botao botao-pequeno sucesso" onclick="melhorarRelacao('${paisId}')" title="Melhorar Rela√ß√µes (-${10}M)">Diplomacia</button>
                        <button class="botao botao-pequeno perigo" onclick="criticarPais('${paisId}')" title="Criticar Publicamente">Criticar</button>
                    </div>
                `;
                divPaises.appendChild(div);
            });
        }

        // --- 4. Populate Blocs List & Actions ---
        const blocIds = Object.keys(blocos || {});
        if (blocIds.length === 0) {
             divBlocos.innerHTML = '<p>Nenhum bloco/alian√ßa definido.</p>';
        } else {
            blocIds.forEach(blocoId => {
                 const bloco = blocos[blocoId];
                 const membrosAtuais = blocosAtivos[blocoId]?.membros || bloco.membrosIniciais || [];
                 const isMember = membrosAtuais.includes("jogador"); // Using "jogador" as placeholder ID for player's nation
                 const eligible = !isMember && checkEligibilityBloco(blocoId); // Check if player can join

                 let btnHTML = '';
                 if (isMember) {
                     btnHTML = `<span style="color: lightgreen;">(Membro)</span>`;
                 } else {
                     btnHTML = `<button class="botao botao-pequeno ${eligible ? 'sucesso' : 'aviso'}" onclick="pedirAdesaoBloco('${blocoId}')" ${!eligible ? 'disabled title="Condi√ß√µes n√£o atendidas (Rela√ß√£o/Ideologia?)"' : 'title="Pedir Ades√£o"'}>Aderir</button>`;
                 }

                 const div = document.createElement('div');
                 div.className = 'diplomacia-item';
                 div.innerHTML = `
                     <div style="flex-grow: 1;">
                         <strong>${bloco.nome}</strong> (${bloco.tipo})<br>
                         <small>Membros: ${membrosAtuais.map(mId => paises[mId]?.nome || capitalize(mId)).join(', ')}</small>
                     </div>
                     <div class="painel-acoes" style="margin-top: 0;">${btnHTML}</div>
                 `;
                 divBlocos.appendChild(div);
            });
        }

        // --- 5. Populate Active Treaties List ---
        if (tratadosAtivos.length === 0) {
             divTratados.innerHTML = '<p>Nenhum tratado ativo.</p>';
        } else {
             tratadosAtivos.forEach((tratado, index) => {
                 const paisNome = paises[tratado.paisAlvoId]?.nome || tratado.paisAlvoId;
                 const div = document.createElement('div');
                 div.className = 'diplomacia-item';
                 div.innerHTML = `
                     <div style="flex-grow: 1;">
                         <strong>${tratado.tipo} com ${paisNome}</strong><br>
                         <small>Dura√ß√£o: ${tratado.duracao} Rodadas | Custo/Rd: ${formatCurrency(tratado.custoManutencao || 0)}</small>
                         <!-- Add display for specific benefits if needed -->
                     </div>
                     <button class="botao botao-pequeno perigo" onclick="cancelarTratado(${index})" title="Cancelar Tratado">Cancelar</button>
                 `;
                 divTratados.appendChild(div);
             });
        }

        // --- 6. Display Modal ---
        modal.style.display = "block";
    }
    
    /**
     * Attempts to propose a diplomatic agreement (Comercial or Militar) with a specific country.
     * Calculates a success chance based on relations, ideology, leader skills, etc.
     * If successful, adds a treaty object to `tratadosAtivos`.
     * Applies immediate costs and feedback.
     * @param {string} paisId - The ID of the target country.
     * @param {'Comercial'|'Militar'} tipo - The type of agreement proposed.
     */
     function proporAcordoDiplomatico(paisId, tipo) {
        console.log(`Propondo acordo ${tipo} com ${paisId}...`);

        // --- 1. Validation ---
        if (!jogoAtivo || jogoPausado) { console.warn("A√ß√£o diplom√°tica bloqueada."); return; }
        if (!paises[paisId]) { console.error(`Pa√≠s alvo inv√°lido: ${paisId}`); return; }
        if (tipo !== 'Comercial' && tipo !== 'Militar') { console.error(`Tipo de acordo inv√°lido: ${tipo}`); return; }

        // Check if a similar treaty already exists
        const existeTratado = tratadosAtivos.some(t => t.paisAlvoId === paisId && t.tipo === tipo);
        if (existeTratado) {
            alert(`Voc√™ j√° possui um acordo ${tipo.toLowerCase()} ativo com ${paises[paisId].nome}.`);
            console.log(`Acordo ${tipo} com ${paisId} j√° existe.`);
            return;
        }

        // --- 2. Calculate Cost & Success Chance ---
        const custoProposta = 25; // Cost to even propose (diplomatic effort)
        let chanceSucessoBase = 0.35; // Base chance isn't super high

        if (tesouro < custoProposta) {
            alert(`Or√ßamento insuficiente (${formatCurrency(tesouro)}) para iniciar negocia√ß√µes (Custo: ${formatCurrency(custoProposta)})!`);
            return;
        }

        // --- Modifiers ---
        const relacaoAtual = relacoesPaises[paisId] || 50;
        let chanceSucesso = chanceSucessoBase;

        // Relation Modifier (Significant impact)
        // Chance increases significantly above 50 rel, decreases below
        chanceSucesso += (relacaoAtual - 50) * 0.008; // +/- 0.8% chance per relation point diff from 50

        // Ideology Modifier (Simplified check)
        const playerIdeology = partidos[liderAtual?.partidoId]?.ideologia || liderAtual?.tipo;
        const targetIdeology = paises[paisId].ideologia;
         if (playerIdeology === targetIdeology) {
             chanceSucesso += 0.10; // Bonus for same ideology
         } else if (
             (playerIdeology.includes('Liberal') && targetIdeology.includes('Liberal')) ||
             (playerIdeology.includes('Esquerda') && targetIdeology.includes('Social')) ||
             (playerIdeology.includes('Conservador') && targetIdeology.includes('Autorit√°rio')) // Example compatible pairs
         ) {
              chanceSucesso += 0.05; // Smaller bonus for compatible
         } else {
              chanceSucesso -= 0.05; // Small penalty for incompatible
         }


        // Leader Skill Modifier
        if (lider.habilidades?.includes('diplomata_habil')) {
            chanceSucesso += 0.10;
        }
        if (lider.atributos?.estrategia > 6) {
             chanceSucesso += (lider.atributos.estrategia - 6) * 0.02;
        }

        // Target Country Strength Modifier (Harder to ally with much stronger/weaker nations?)
        // Simplified: Penalty if economic forces differ too much for Trade deal
        if (tipo === 'Comercial') {
             const playerEcon = 6; // Placeholder for player's relative economic strength (needs calculation)
             const targetEcon = paises[paisId].forcaEconomica || 5;
             if (Math.abs(playerEcon - targetEcon) > 3) chanceSucesso -= 0.05;
        }
         // Simplified: Penalty if military forces differ too much for Military deal
         if (tipo === 'Militar') {
              const playerMil = 5; // Placeholder for player's relative military strength
              const targetMil = paises[paisId].forcaMilitar || 5;
              if (Math.abs(playerMil - targetMil) > 3) chanceSucesso -= 0.05;
         }


        // Clamp final chance
        chanceSucesso = clamp(chanceSucesso, 0.05, 0.90); // 5% to 90%

        console.log(`Proposta Acordo ${tipo} com ${paisId}: Custo ${custoProposta}, Rel ${relacaoAtual}%, Chance Final ${formatPercent(chanceSucesso*100)}`);

        // --- 3. Apply Cost ---
        tesouro -= custoProposta;
        adicionarNoticia(`Negocia√ß√µes para acordo ${tipo.toLowerCase()} com ${paises[paisId].nome} iniciadas (Custo: ${formatCurrency(custoProposta)}).`, "diplomacia");

        // --- 4. Determine Outcome ---
        const sucesso = Math.random() < chanceSucesso;
        let feedbackMsg = "";
        let feedbackClass = "";
        let efeitosResultado = {};

        if (sucesso) {
            feedbackMsg = `SUCESSO! Um acordo ${tipo.toLowerCase()} foi firmado com ${paises[paisId].nome}!`;
            feedbackClass = "sucesso";
            console.log(`Acordo ${tipo} com ${paisId} bem-sucedido.`);

            // Define treaty benefits/costs (Examples)
            let beneficios = {};
            let custoManutencao = 0;
            let duracao = 20; // Rounds

            if (tipo === 'Comercial') {
                 beneficios = { receitaPorRodadaMod: 8 + Math.round(paises[paisId].forcaEconomica / 2) }; // Higher benefit with stronger economy partner
                 custoManutencao = 1;
                 duracao = 25;
            } else if (tipo === 'Militar') {
                 beneficios = { defesaBonus: 5 + Math.round(paises[paisId].forcaMilitar / 2), relacaoPaisAlvo: +1 }; // Bonus defense stat? And slow relation gain
                 custoManutencao = 2;
                 duracao = 30;
            }

            // Create and add treaty object
            const novoTratado = {
                id: `trat_${tipo.slice(0,3)}_${paisId}_${Date.now()}`, // Unique ID
                tipo: tipo,
                paisAlvoId: paisId,
                beneficios: beneficios,
                duracao: duracao,
                custoManutencao: custoManutencao
            };
            tratadosAtivos.push(novoTratado);
            console.log("Novo tratado adicionado:", novoTratado);

            // Apply immediate effects (e.g., relation boost)
            efeitosResultado[`relacao_${paisId}`] = +5; // Small immediate boost for signing
            efeitosResultado.popNacionalista = (tipo === 'Militar') ? +2 : 0; // Military deals boost nationalists?

            // Increment achievement counter
            incrementAchievementCounter('diplomata');

        } else { // Failure
            feedbackMsg = `FALHA. As negocia√ß√µes para um acordo ${tipo.toLowerCase()} com ${paises[paisId].nome} n√£o tiveram sucesso.`;
            feedbackClass = "aviso";
            console.log(`Acordo ${tipo} com ${paisId} falhou.`);

            // Apply small penalty for failure?
            efeitosResultado[`relacao_${paisId}`] = -3; // Small relation hit for failed attempt
        }

        // --- 5. Apply Effects & Feedback ---
        aplicarEfeitos(efeitosResultado); // Apply immediate relation changes etc.
        adicionarNoticia(feedbackMsg, "diplomacia", feedbackClass);

        // --- 6. Update UI ---
        // No need to close modal here usually, player might try other actions
        // Full UI update will happen in next proximoTurno, but update budget now
        atualizarPainelOrcamento(calcularReceitaAtual(), calcularDespesaAtual(), calcularReceitaAtual() - calcularDespesaAtual());
        // Could update world panel immediately too if desired
        // atualizarPainelMundo();
    }
    
    /**
     * Improves relations with a specific country by spending budget.
     * Applies a fixed cost and a small, guaranteed relationship boost.
     * @param {string} paisId - The ID of the target country.
     */
     function melhorarRelacao(paisId) {
        console.log(`Tentando melhorar rela√ß√µes com ${paisId}...`);

        // --- 1. Validation ---
        if (!jogoAtivo || jogoPausado) { console.warn("A√ß√£o diplom√°tica bloqueada."); return; }
        if (!paises[paisId]) { console.error(`Pa√≠s alvo inv√°lido: ${paisId}`); return; }
        if (relacoesPaises[paisId] === undefined) { console.warn(`Rela√ß√£o com ${paisId} n√£o inicializada?`); } // Continue anyway, will use default

        // --- 2. Define Cost & Check Affordability ---
        const custoMelhoria = 10; // Cost in millions (adjust as needed)
        const boostRelacaoBase = 3; // Base points increase

        if (tesouro < custoMelhoria) {
            alert(`Or√ßamento insuficiente (${formatCurrency(tesouro)}) para investir em diplomacia (Custo: ${formatCurrency(custoMelhoria)})!`);
            console.log("Or√ßamento insuficiente para melhorar rela√ß√£o.");
            return;
        }

        // --- 3. Apply Cost ---
        tesouro -= custoMelhoria;
        console.log(`Custo de ${formatCurrency(custoMelhoria)} aplicado. Novo tesouro: ${formatCurrency(tesouro)}`);

        // --- 4. Calculate Relation Boost (Apply Modifiers) ---
        let boostFinal = boostRelacaoBase;

        // Leader Skill/Attribute Modifiers
        if (lider.habilidades?.includes('articulador_partidario')) { // Re-using party skill for general diplomacy boost? Or needs specific diplomacy skill? Using 'diplomata_habil' is better.
             // boostFinal += 1; // Small bonus if using party skill
        }
        if (lider.habilidades?.includes('diplomata_habil')) {
             boostFinal += 2; // Specific diplomacy skill bonus
        }
        if (lider.atributos?.carisma) {
            boostFinal += Math.round((lider.atributos.carisma - 5) * 0.2); // Small boost/penalty based on charisma diff from 5
        }

        // Ensure boost isn't negative
        boostFinal = Math.max(1, boostFinal); // Guarantee at least 1 point increase

        console.log(`Boost de rela√ß√£o calculado: ${boostFinal} (Base: ${boostRelacaoBase})`);

        // --- 5. Apply Effect ---
        // Use the specific effect key format for aplicarEfeitos if desired,
        // or update directly here for simplicity since it's guaranteed.
        const relacaoAntes = relacoesPaises[paisId] || 50;
        relacoesPaises[paisId] = clamp(relacaoAntes + boostFinal, 0, 100); // Update and clamp

        // --- 6. Feedback ---
        adicionarNoticia(`üí∏ Investimento em diplomacia melhorou rela√ß√µes com ${paises[paisId].nome} (+${relacoesPaises[paisId] - relacaoAntes}%).`, "diplomacia", "sucesso");

        // --- 7. Update UI ---
        // Update budget immediately, full update on next turn
        atualizarPainelOrcamento(calcularReceitaAtual(), calcularDespesaAtual(), calcularReceitaAtual() - calcularDespesaAtual());
        // Optionally update the World Panel immediately within the modal if needed
         atualizarPainelMundo(); // Refresh world panel state shown in main UI
         // Refresh the diplomacy modal content if it's open
         if (document.getElementById('modal-diplomacia').style.display === 'block') {
              mostrarModalDiplomacia(); // Re-populate the modal to show new relation value
         }
    }
    
    /**
     * Publicly criticizes another country.
     * Damages relations with the target country and may boost domestic nationalist support.
     * @param {string} paisId - The ID of the target country.
     */
     function criticarPais(paisId) {
        console.log(`Criticando publicamente o pa√≠s: ${paisId}...`);

        // --- 1. Validation ---
        if (!jogoAtivo || jogoPausado) { console.warn("A√ß√£o diplom√°tica bloqueada."); return; }
        if (!paises[paisId]) { console.error(`Pa√≠s alvo inv√°lido: ${paisId}`); return; }
        // No cost associated usually, but could add a small political capital cost if implemented

        // --- 2. Calculate Effects ---
        let efeitosCritica = {};

        // 2a. Relation Hit (Significant)
        const relationHitBase = -8;
        // Modify based on current relation? Criticizing an ally hurts more? Criticizing rival is expected?
        const relacaoAtual = relacoesPaises[paisId] || 50;
        let relationHitFinal = relationHitBase;
        if (relacaoAtual > 60) { relationHitFinal *= 1.5; } // Criticizing someone you have good relations with hurts more
        else if (relacaoAtual < 40) { relationHitFinal *= 0.7; } // Criticizing a rival has slightly less *additional* impact
        relationHitFinal = Math.round(relationHitFinal);

        efeitosCritica[`relacao_${paisId}`] = relationHitFinal; // Using dynamic key for aplicarEfeitos is tricky, better handle directly
        // Direct Update:
        relacoesPaises[paisId] = clamp((relacoesPaises[paisId] || 50) + relationHitFinal, 0, 100);
        console.log(`Rela√ß√£o com ${paisId} modificada em ${relationHitFinal} para ${relacoesPaises[paisId]}`);


        // 2b. Domestic Nationalist Boost
        // Check if 'Nacionalistas' group exists
        const nacionalistaKey = getGrupoKey('Nacionalistas');
        if (popularidadeGrupos[nacionalistaKey] !== undefined) {
             const nationalistBoost = 2 + Math.max(0, Math.round((50 - relacaoAtual) / 20)); // More boost if criticizing unpopular country
             efeitosCritica[`pop${capitalize(nacionalistaKey)}`] = nationalistBoost; // Target specific group
             console.log(`Boost Nacionalista: ${nationalistBoost}`);
        } else {
             // Fallback: Small general pop boost? Or no boost if group undefined?
             // efeitosCritica.popGeral = 1;
        }

        // 2c. Potential small negative impact on other relations? (Optional complexity)
        // e.g., Allies of the criticized nation might disapprove slightly
         for (const otherPaisId in paises) {
              if (otherPaisId !== paisId && relacoesPaises[otherPaisId] > 65 && relacoesPaises[paisId] > 50) { // If criticizing someone who is friendly with your other friends
                   // efeitosCritica[`relacao_${otherPaisId}`] = -1; // Apply via aplicarEfeitos
                    relacoesPaises[otherPaisId] = clamp((relacoesPaises[otherPaisId] || 50) - 1, 0, 100); // Or apply directly
              }
         }

        // --- 3. Apply Effects (Mainly for Pop boost now) ---
        aplicarEfeitos(efeitosCritica); // Apply the pop boost etc.

        // --- 4. Feedback ---
        adicionarNoticia(`üì¢ Voc√™ criticou publicamente ${paises[paisId].nome}. Rela√ß√µes foram afetadas (${relationHitFinal}%).`, "diplomacia", "aviso");

        // --- 5. Update UI ---
        // Full UI update on next turn, but update world panel/modal immediately
        atualizarPainelMundo();
        if (document.getElementById('modal-diplomacia').style.display === 'block') {
            mostrarModalDiplomacia(); // Refresh modal content
        }
    }
    
    /**
     * Checks if the player's nation is currently eligible to join a specific bloc.
     * Verifies conditions like minimum relations with existing members,
     * ideological compatibility, and potentially minimum military/economic strength.
     * @param {string} blocoId - The ID of the bloc to check eligibility for.
     * @returns {boolean} - True if eligible, false otherwise.
     */
     function checkEligibilityBloco(blocoId) {
        // --- 1. Validation ---
        const bloco = blocos[blocoId];
        if (!bloco) {
            console.warn(`checkEligibilityBloco: Bloco com ID ${blocoId} n√£o encontrado.`);
            return false; // Cannot join if bloc doesn't exist
        }

        const condicoes = bloco.condicoesEntrada;
        if (!condicoes) {
            // console.log(`Bloco ${blocoId} n√£o possui condi√ß√µes de entrada definidas. Permitindo ades√£o por padr√£o?`);
            return true; // If no conditions specified, assume eligible? Or return false? Let's assume true for now.
        }

        // --- 2. Check Minimum Relations ---
        if (condicoes.relacaoMinPais && typeof condicoes.relacaoMinPais === 'object') {
            for (const requiredPaisId in condicoes.relacaoMinPais) {
                const minRelation = condicoes.relacaoMinPais[requiredPaisId];
                const currentRelation = relacoesPaises[requiredPaisId] || 0; // Default to 0 if relation undefined

                if (currentRelation < minRelation) {
                    // console.log(`Elegibilidade falhou para ${blocoId}: Rela√ß√£o com ${requiredPaisId} √© ${currentRelation}%, necess√°rio ${minRelation}%.`);
                    return false; // Relation too low with a required country
                }
            }
        }
        // Could add: Check minimum average relation with *all* current members?

        // --- 3. Check Ideological Compatibility ---
        if (Array.isArray(condicoes.ideologiaCompativeis) && condicoes.ideologiaCompativeis.length > 0) {
            const playerIdeology = partidos[liderAtual?.partidoId]?.ideologia || liderAtual?.tipo || 'Pragm√°tico';
            if (!condicoes.ideologiaCompativeis.includes(playerIdeology)) {
                // console.log(`Elegibilidade falhou para ${blocoId}: Ideologia '${playerIdeology}' n√£o √© compat√≠vel. Requer: ${condicoes.ideologiaCompativeis.join(', ')}`);
                return false; // Player's ideology is not compatible
            }
        }

        // --- 4. Check Minimum Military Strength (for Military blocs) ---
        if (bloco.tipo === 'Militar' && condicoes.forcaMilitarMin) {
            // We need a way to calculate player's current military strength
            // Placeholder: Use a fixed value or derive from defense budget/tech level?
            const playerForcaMilitar = calcularForcaMilitarAtual(); // Needs helper function
            if (playerForcaMilitar < condicoes.forcaMilitarMin) {
                // console.log(`Elegibilidade falhou para ${blocoId}: For√ßa militar ${playerForcaMilitar} insuficiente, necess√°rio ${condicoes.forcaMilitarMin}.`);
                return false;
            }
        }

        // --- 5. Check Minimum Economic Strength (for Economic blocs) ---
        if (bloco.tipo === 'Economico' && condicoes.forcaEconomicaMin) {
            // Placeholder: Use GDP? Or a calculated index?
            const playerForcaEconomica = calcularForcaEconomicaAtual(); // Needs helper function
            if (playerForcaEconomica < condicoes.forcaEconomicaMin) {
                // console.log(`Elegibilidade falhou para ${blocoId}: For√ßa econ√¥mica ${playerForcaEconomica} insuficiente, necess√°rio ${condicoes.forcaEconomicaMin}.`);
                return false;
            }
        }

        // --- 6. Check Other Conditions (e.g., not currently at war with member) ---
        // Add more checks as needed...

        // --- 7. If all checks passed ---
        // console.log(`Elegibilidade confirmada para ${blocoId}.`);
        return true; // Eligible to join
    }

    // --- Helper Functions (Placeholders - Need Implementation) ---

    /**
     * Calculates the player's current relative military strength.
     * Placeholder - Needs actual implementation based on game factors.
     * @returns {number} - A numerical representation of military strength (e.g., 1-10).
     */
    function calcularForcaMilitarAtual() {
        // Example implementation: Based on Defense Budget + Military Pop Support + Tech Level?
        let strength = 5; // Base
        if (orcamentoAlocado.defesa) {
             strength += (orcamentoAlocado.defesa / 15) - 1; // Bonus/penalty based on funding vs baseline (~15M)
        }
        if (popularidadeGrupos[getGrupoKey('Militares')]) {
            strength += (popularidadeGrupos[getGrupoKey('Militares')] - 50) / 20; // Bonus/penalty from military support
        }
        // Add bonus from technology research if implemented
        return clamp(Math.round(strength), 1, 10); // Return value clamped 1-10
    }

    /**
     * Calculates the player's current relative economic strength.
     * Placeholder - Needs actual implementation based on game factors.
     * @returns {number} - A numerical representation of economic strength (e.g., 1-10).
     */
    function calcularForcaEconomicaAtual() {
        // Example implementation: Based on GDP Growth + Treasury Size + Business Pop Support?
         let strength = 5; // Base
         if (indicadoresSociaisEconomicos.crescimentoPIB) {
              strength += clamp(indicadoresSociaisEconomicos.crescimentoPIB * 0.5, -2, 3); // Capped impact from GDP growth
         }
          if (tesouro) {
               strength += clamp(tesouro / 500, -1, 2); // Capped impact from treasury size relative to ~500M
          }
         if (popularidadeGrupos[getGrupoKey('Empres√°rios')]) {
             strength += (popularidadeGrupos[getGrupoKey('Empres√°rios')] - 50) / 25; // Bonus/penalty from business support
         }
        return clamp(Math.round(strength), 1, 10); // Return value clamped 1-10
    }
    
    /**
     * Handles the player's request to join a specific economic bloc or military alliance.
     * Checks eligibility, calculates success chance, applies outcome, updates state.
     * @param {string} blocoId - The ID of the bloc the player wants to join.
     */
     function pedirAdesaoBloco(blocoId) {
        console.log(`Tentando pedir ades√£o ao bloco: ${blocoId}`);

        // --- 1. Validation ---
        if (!jogoAtivo || jogoPausado) { console.warn("A√ß√£o diplom√°tica bloqueada."); return; }

        const bloco = blocos[blocoId];
        if (!bloco) { console.error(`Bloco alvo inv√°lido: ${blocoId}`); return; }

        // Is player already a member?
        const membrosAtuais = blocosAtivos[blocoId]?.membros || bloco.membrosIniciais || [];
        if (membrosAtuais.includes("jogador")) {
             alert(`Voc√™ j√° √© membro do bloco ${bloco.nome}.`);
             console.log(`J√° √© membro do bloco ${blocoId}.`);
             return;
        }

        // --- 2. Re-check Eligibility ---
        if (!checkEligibilityBloco(blocoId)) {
            alert(`Voc√™ n√£o cumpre os requisitos para aderir ao bloco ${bloco.nome} neste momento (verifique rela√ß√µes, ideologia, for√ßa militar/econ√¥mica).`);
            console.log(`Elegibilidade falhou para ${blocoId}.`);
            return;
        }

        // --- 3. Calculate Cost & Success Chance ---
        const custoPedido = 20; // Cost for diplomatic processing of the request
        let chanceSucessoBase = 0.50; // Base chance assuming eligibility is met

        if (tesouro < custoPedido) {
            alert(`Or√ßamento insuficiente (${formatCurrency(tesouro)}) para processar o pedido de ades√£o (Custo: ${formatCurrency(custoPedido)})!`);
            return;
        }

        // --- Modifiers ---
        let chanceSucesso = chanceSucessoBase;

        // Relation Modifier (Average relation with *current* members?)
        let avgRelationWithMembers = 50;
        const currentMemberIds = membrosAtuais.filter(id => id !== "jogador"); // Exclude potential placeholder
        if (currentMemberIds.length > 0) {
            let totalRelation = 0;
            currentMemberIds.forEach(memberId => {
                 totalRelation += (relacoesPaises[memberId] || 50); // Use 50 if relation undefined
            });
            avgRelationWithMembers = totalRelation / currentMemberIds.length;
             chanceSucesso += (avgRelationWithMembers - 55) * 0.01; // +/- 1% chance per point diff from 55 avg rel
             console.log(`M√©dia de rela√ß√£o com membros (${currentMemberIds.join(', ')}): ${avgRelationWithMembers.toFixed(1)}%`);
        }


        // Leader Skill/Attribute Modifier
        if (lider.habilidades?.includes('diplomata_habil')) chanceSucesso += 0.10;
        if (lider.atributos?.estrategia > 5) chanceSucesso += (lider.atributos.estrategia - 5) * 0.02;
        if (lider.atributos?.carisma > 5) chanceSucesso += (lider.atributos.carisma - 5) * 0.01;


        // Bloc Type Modifier (Slightly easier for economic?)
        if (bloco.tipo === 'Economico') chanceSucesso += 0.05;

        // Clamp final chance
        chanceSucesso = clamp(chanceSucesso, 0.10, 0.90); // 10% to 90%

        console.log(`Pedido Ades√£o Bloco ${blocoId}: Custo ${custoPedido}, Chance Final ${formatPercent(chanceSucesso*100)}`);

        // --- 4. Apply Cost ---
        tesouro -= custoPedido;
        adicionarNoticia(`Pedido de ades√£o ao bloco ${bloco.nome} enviado (Custo: ${formatCurrency(custoPedido)}).`, "diplomacia");

        // --- 5. Determine Outcome ---
        const sucesso = Math.random() < chanceSucesso;
        let feedbackMsg = "";
        let feedbackClass = "";
        let efeitosResultado = {};

        if (sucesso) {
            feedbackMsg = `ACEITO! Sua na√ß√£o foi aceita como membro do bloco ${bloco.nome}!`;
            feedbackClass = "sucesso";
            console.log(`Ades√£o ao bloco ${blocoId} bem-sucedida.`);

            // Add player to the active bloc state
            if (!blocosAtivos[blocoId]) { // If bloc wasn't active before (only initial members)
                 blocosAtivos[blocoId] = { nome: bloco.nome, membros: [...(bloco.membrosIniciais || [])] };
            }
            if (!blocosAtivos[blocoId].membros.includes("jogador")) {
                blocosAtivos[blocoId].membros.push("jogador");
            }
            console.log("Blocos ativos atualizados:", blocosAtivos);

            // Apply immediate effects (e.g., relation boost with members)
            currentMemberIds.forEach(memberId => {
                 // efeitosResultado[`relacao_${memberId}`] = +5; // Apply via aplicarEfeitos
                 relacoesPaises[memberId] = clamp((relacoesPaises[memberId] || 50) + 5, 0, 100); // Or apply directly
            });
             efeitosResultado.popGeral = +2; // Small boost for successful diplomacy

            // Increment achievement counter
            incrementAchievementCounter('construtor_blocos');

        } else { // Failure
            feedbackMsg = `REJEITADO. Seu pedido de ades√£o ao bloco ${bloco.nome} n√£o foi aceito pelos membros atuais.`;
            feedbackClass = "aviso";
            console.log(`Ades√£o ao bloco ${blocoId} falhou.`);

            // Apply small penalty for failure?
            currentMemberIds.forEach(memberId => {
                 // efeitosResultado[`relacao_${memberId}`] = -2; // Apply via aplicarEfeitos
                 relacoesPaises[memberId] = clamp((relacoesPaises[memberId] || 50) - 2, 0, 100); // Or apply directly
            });
            efeitosResultado.popGeral = -1;
        }

        // --- 6. Apply Effects & Feedback ---
        aplicarEfeitos(efeitosResultado); // Apply pop changes etc.
        adicionarNoticia(feedbackMsg, "diplomacia", feedbackClass);

        // --- 7. Update UI ---
        atualizarPainelOrcamento(calcularReceitaAtual(), calcularDespesaAtual(), calcularReceitaAtual() - calcularDespesaAtual());
        atualizarPainelMundo(); // Refresh world panel state shown in main UI
        if (document.getElementById('modal-diplomacia').style.display === 'block') {
            mostrarModalDiplomacia(); // Refresh modal content if open
        }
    }
    
    /**
     * Cancels an active treaty based on its index in the `tratadosAtivos` array.
     * Removes the treaty and applies potential negative consequences.
     * @param {number} index - The index of the treaty to cancel in the `tratadosAtivos` array.
     */
     function cancelarTratado(index) {
        console.log(`Tentando cancelar tratado no √≠ndice: ${index}`);

        // --- 1. Validation ---
        if (!jogoAtivo || jogoPausado) { console.warn("A√ß√£o diplom√°tica bloqueada."); return; }

        if (index < 0 || index >= tratadosAtivos.length || !tratadosAtivos[index]) {
            console.error(`√çndice de tratado inv√°lido ou tratado n√£o encontrado: ${index}`);
            alert("Erro: Tratado inv√°lido selecionado para cancelamento.");
            return;
        }

        const tratado = tratadosAtivos[index];
        const paisId = tratado.paisAlvoId;
        const paisNome = paises[paisId]?.nome || capitalize(paisId);

        // --- 2. Confirmation (Optional but recommended) ---
        const confirmar = confirm(`Tem certeza que deseja cancelar o acordo ${tratado.tipo} com ${paisNome}? Isso pode prejudicar suas rela√ß√µes.`);
        if (!confirmar) {
            console.log("Cancelamento de tratado abortado pelo usu√°rio.");
            return; // User cancelled
        }

        // --- 3. Remove Treaty from Active List ---
        // Remove the treaty at the specified index
        tratadosAtivos.splice(index, 1);
        console.log(`Tratado com ${paisNome} removido da lista ativa.`);

        // --- 4. Apply Consequences ---
        adicionarNoticia(`üìâ ACORDO CANCELADO: Voc√™ encerrou o tratado ${tratado.tipo} com ${paisNome}.`, "diplomacia", "aviso");

        let efeitosCancelamento = {};

        // 4a. Significant Relation Hit with the Partner Country
        const relationHit = -15; // Penalty for breaking agreement
        // Effects object cannot use dynamic key easily here, apply directly
        relacoesPaises[paisId] = clamp((relacoesPaises[paisId] || 50) + relationHit, 0, 100);
        console.log(`Rela√ß√£o com ${paisNome} afetada (${relationHit}%) ap√≥s cancelamento. Nova rela√ß√£o: ${relacoesPaises[paisId]}%`);
        adicionarNoticia(`Rela√ß√µes com ${paisNome} pioraram significativamente devido ao cancelamento do acordo.`, "sistema", "perigo");


        // 4b. Small Hit to General Diplomatic Reputation / Trust?
        // Could affect relations with *other* countries slightly, or future negotiation chances
        efeitosCancelamento.satisfacaoMidiaInternacional = -5; // Example effect if this stat exists
        // Or a small general pop hit if perceived negatively domestically
        efeitosCancelamento.popGeral = -1;


        // 4c. Apply Effects (for pop hit, international reputation etc.)
        aplicarEfeitos(efeitosCancelamento);

        // --- 5. Update UI ---
        // Full UI update on next turn, but update relevant panels immediately
        atualizarPainelMundo(); // Refresh world panel state shown in main UI
        if (document.getElementById('modal-diplomacia').style.display === 'block') {
            mostrarModalDiplomacia(); // Refresh modal content if open
        }
    }

    // --- AI Opposition --- (Defined before game loop)
    /**
     * Selects the main AI opponent leader at the start of the game
     * or when a replacement is needed. Chooses based on opposition
     * party strength and relationship with the player. Handles satire mode names.
     * @returns {Object|null} The selected opponent object (a copy) or null if none suitable.
     */
    function selectOpponent() {
        console.log("Selecionando oponente principal...");

        // --- 1. Validation ---
        if (!oponentesPool || oponentesPool.length === 0) {
            console.warn("selectOpponent: Pool de oponentes est√° vazio.");
            return null; // No opponents defined
        }
        if (!liderAtual || !liderAtual.partidoId || !partidos || !relacoesPartidos) {
             console.error("selectOpponent: Estado do jogador/partidos n√£o inicializado.");
             return null; // Cannot select without player info
        }

        let bestOpponent = null;
        let highestThreat = -1;

        // --- 2. Iterate Through Potential Opponents ---
        for (const op of oponentesPool) {
            // Ensure opponent is not from the player's own party
            if (op.partidoId === liderAtual.partidoId) {
                continue; // Skip candidates from player's party
            }

            const opponentParty = partidos[op.partidoId];
            if (!opponentParty) {
                 console.warn(`selectOpponent: Partido ${op.partidoId} para oponente ${op.nome} n√£o encontrado.`);
                 continue; // Skip if party data missing
            }

            // Get player's relationship TO the opponent's party
            const playerRelationToOppParty = relacoesPartidos[op.partidoId] || 50; // Default 50 if undefined

            // --- 3. Calculate Threat Level (Example Formula) ---
            // Considers party strength, low player relation, and opponent's base popularity
            const partyStrength = opponentParty.forcaBaseCongresso || 0;
            const relationFactor = (100 - playerRelationToOppParty) / 100; // Higher threat if player relation is low (0 to 1)
            const basePopFactor = (op.popularidadeBase || 0) / 100; // Opponent's inherent appeal (0 to 1)

            // Weighted threat calculation - Adjust weights as needed
            const threat = (partyStrength * 0.5) + // Weight for party base
                           (relationFactor * 30) +   // Weight for bad relationship
                           (basePopFactor * 20);      // Weight for opponent's base popularity

            console.log(` - Avaliando ${op.nome} (${op.partidoId}): For√ßa ${partyStrength}, Rel ${playerRelationToOppParty} -> Amea√ßa ${threat.toFixed(1)}`);

            // --- 4. Track Best Candidate ---
            if (threat > highestThreat) {
                highestThreat = threat;
                bestOpponent = op; // Store the *definition* object for now
            }
        } // End loop through opponents

        // --- 5. Handle Satire Mode Naming ---
        if (gameMode === 'satire' && nomesOponentesSatira && nomesOponentesSatira.length > 0) {
            const randomSatireName = getRandomElement(nomesOponentesSatira);
            if (bestOpponent) {
                // Overwrite the selected opponent's name but keep other stats/tactics
                bestOpponent = { ...bestOpponent, nome: randomSatireName }; // Create a new object with modified name
                console.log(`Modo S√°tira: Oponente renomeado para ${randomSatireName}`);
            } else {
                // If no suitable opponent found, create a default satire one
                bestOpponent = {
                    id: "op_satire",
                    nome: randomSatireName,
                    partidoId: Object.keys(partidos).find(p => p !== liderAtual.partidoId && p !== "partido_independente") || "partido_fantasma", // Pick first available opposition party ID
                    personalidade: ["Ca√≥tico", "Incompetente"],
                    foco: ["Absurdo"],
                    taticas: ["FakeNewsLight", "AtaquePessoal"],
                    popularidadeBase: 30
                };
                console.log(`Modo S√°tira: Criado oponente padr√£o ${randomSatireName}`);
            }
        }

        // --- 6. Log and Return ---
        if (bestOpponent) {
            console.log(`Oponente principal selecionado: ${bestOpponent.nome} (${bestOpponent.partidoId}) com Amea√ßa ${highestThreat.toFixed(1)}`);
            return { ...bestOpponent }; // Return a *copy* of the selected opponent's data
        } else {
            console.warn("Nenhum oponente adequado encontrado.");
            return null;
        }
    }
    
    /**
     * Simulates the AI opponent's actions for the current turn.
     * Assesses player weaknesses and chooses a tactic based on opponent profile.
     * Can launch fake news, personal attacks, or propose alternatives.
     */
     function aiOponenteTurno() {
        // --- 1. Validation ---
        if (!oponentePrincipal || !jogoAtivo || jogoPausado || eventoOrcamentoAtivo || debateAtual) {
            // console.log("Turno da IA pulado: Sem oponente ou jogo n√£o permite.");
            return; // Skip if no opponent or game state prevents AI action
        }

        console.log(`--- Turno da IA: ${oponentePrincipal.nome} ---`);
        let actionTaken = false;
        const tactics = oponentePrincipal.taticas || [];
        const personality = oponentePrincipal.personalidade || [];
        const focus = oponentePrincipal.foco || [];

        // --- 2. Assess Player State (Simplified) ---
        const playerPopGeral = calcularPopularidadeGeral();
        const playerWeakestGroup = Object.keys(popularidadeGrupos).reduce((lowest, key) => {
             return (!lowest || popularidadeGrupos[key] < lowest.value) ? { key: key, value: popularidadeGrupos[key] } : lowest;
        }, null);
        const worstIndicator = Object.keys(indicadoresSociaisEconomicos).reduce((worst, key) => {
            let score = 0; // Higher score = worse indicator state
            const value = indicadoresSociaisEconomicos[key];
            if (['inflacao', 'desemprego', 'criminalidade', 'dividaPublica'].includes(key)) score = value / 10; // Normalize roughly
            else if (['educacao', 'saude'].includes(key)) score = (100 - value) / 10; // Invert score
            else if (key === 'crescimentoPIB') score = Math.max(0, 1 - value); // Penalty for low/negative growth
            return (!worst || score > worst.score) ? { key: key, value: value, score: score } : worst;
        }, null);
        const playerHonesty = lider.atributos?.honestidade || 5;
        const recentScandal = campaignState?.flags['escandalo_resolvido_recentemente']; // Needs flag set by crisis resolution

        // --- 3. Choose Tactic based on Profile & Weakness ---

        // 3a. Prioritize Focus Areas?
        let preferredTactics = [];
        if (focus.includes("Corrup√ß√£o") && (playerHonesty < 5 || recentScandal) && (tactics.includes("AtaquePessoal") || tactics.includes("FakeNewsLight"))) {
            preferredTactics.push('AttackHonesty', 'FakeNewsCorruption');
        }
        if (focus.includes("Economia") && worstIndicator?.key && ['inflacao', 'desemprego', 'crescimentoPIB', 'dividaPublica'].includes(worstIndicator.key) && worstIndicator.score > 5) {
             preferredTactics.push('AttackEconomy', 'ProposeEconomy');
             if (tactics.includes("FakeNewsSofisticada")) preferredTactics.push('FakeNewsEconomy');
        }
        if (focus.includes("Social") && playerWeakestGroup?.key === getGrupoKey('Trabalhadores') && playerWeakestGroup.value < 40) {
             preferredTactics.push('AttackSocial', 'ProposeSocial');
        }
        // Add more focus-based preferences...

        // 3b. Select Tactic (Prioritize preferred, fallback based on personality/available)
        let chosenTactic = null;
        if (preferredTactics.length > 0 && Math.random() < 0.7) { // 70% chance to use preferred tactic
             chosenTactic = getRandomElement(preferredTactics);
        } else { // Fallback
             if (personality.includes("Agressivo") && tactics.includes("AtaquePessoal") && Math.random() < 0.6) chosenTactic = 'AttackGeneral';
             else if (personality.includes("Populista") && tactics.includes("PropostaAlternativa") && Math.random() < 0.5) chosenTactic = 'ProposeGeneral';
             else if (tactics.includes("FakeNewsLight") && Math.random() < 0.3) chosenTactic = 'FakeNewsGeneral';
             else if (tactics.includes("CriticaConstrutiva") && Math.random() < 0.4) chosenTactic = 'CritiqueGeneral';
             else chosenTactic = 'PassiveGain'; // Default if no specific tactic chosen
        }

        console.log(`IA decidiu usar a t√°tica: ${chosenTactic}`);

        // --- 4. Execute Chosen Tactic ---
        switch (chosenTactic) {
            case 'FakeNewsCorruption':
            case 'FakeNewsEconomy':
            case 'FakeNewsGeneral':
                 if (lancarFakeNews(chosenTactic)) actionTaken = true; // Pass context to select template
                 break;

            case 'AttackHonesty':
            case 'AttackEconomy':
            case 'AttackSocial':
            case 'AttackGeneral':
                 let target = "a gest√£o geral do governo"; // Default attack
                 if (chosenTactic === 'AttackHonesty' || (chosenTactic === 'AttackGeneral' && (playerHonesty < 5 || recentScandal))) target = "a falta de transpar√™ncia e poss√≠veis irregularidades";
                 else if (chosenTactic === 'AttackEconomy' || (chosenTactic === 'AttackGeneral' && worstIndicator?.score > 5)) target = `os p√©ssimos resultados econ√¥micos (${capitalize(worstIndicator.key)}: ${indicadoresSociaisEconomicos[worstIndicator.key]})`;
                 else if (chosenTactic === 'AttackSocial' || (chosenTactic === 'AttackGeneral' && playerWeakestGroup?.value < 40)) target = `o abandono das pol√≠ticas sociais para ${capitalize(playerWeakestGroup.key)}`;
                 else if (playerPopGeral < 40) target = "a baix√≠ssima popularidade do governo";

                 adicionarNoticia(`${oponentePrincipal.nome} ataca duramente ${target}!`, "oposicao", "aviso");
                 popularidadeOponente = clamp(popularidadeOponente + (personality.includes("Agressivo") ? 3 : 2), 0, 100);
                 aplicarEfeitos({ popGeral: -1 }); // Small direct hit
                 actionTaken = true;
                 break;

            case 'ProposeEconomy':
            case 'ProposeSocial':
            case 'ProposeGeneral':
                let proposal = "uma nova pol√≠tica econ√¥mica para gerar empregos"; // Default
                if(chosenTactic === 'ProposeSocial' || (chosenTactic === 'ProposeGeneral' && orcamentoAlocado.social < 25)) proposal = "um aumento significativo nos programas sociais";
                else if(chosenTactic === 'ProposeEconomy' || (chosenTactic === 'ProposeGeneral' && indicadoresSociaisEconomicos.crescimentoPIB < 1)) proposal = "cortes de impostos para estimular o crescimento";

                adicionarNoticia(`${oponentePrincipal.nome} apresenta ${proposal} como alternativa.`, "oposicao");
                popularidadeOponente = clamp(popularidadeOponente + (personality.includes("Populista") ? 4 : 3), 0, 100);
                 // Maybe small hit to player pop if proposal is popular?
                 aplicarEfeitos({ popGeral: -1 });
                actionTaken = true;
                break;

            case 'CritiqueGeneral':
                adicionarNoticia(`${oponentePrincipal.nome} critica a condu√ß√£o do governo, mas se diz aberto ao di√°logo.`, "oposicao");
                 popularidadeOponente = clamp(popularidadeOponente + 1, 0, 100);
                 actionTaken = true;
                 break;

            case 'PassiveGain':
            default:
                 // Opponent gains a little bit just by existing and player not being perfect
                 const passiveGain = Math.max(0, Math.round((55 - playerPopGeral) / 10)); // Gain more if player pop is low
                 popularidadeOponente = clamp(popularidadeOponente + passiveGain, 0, 100);
                 // console.log("IA: Ganho passivo de popularidade.");
                 actionTaken = true; // Counts as an action
                 break;
        }

        console.log(`Popularidade do Oponente ap√≥s a√ß√£o: ${popularidadeOponente}%`);
        // UI Update happens in main loop
    }
    
    /**
     * Selects, personalizes, and launches a fake news item against the player.
     * Adds the item to the `fakeNewsAtivas` list to apply effects over time.
     * Called by AI opponent or specific events.
     * @param {string|null} [contextHint=null] - Optional hint (e.g., 'FakeNewsCorruption', 'FakeNewsEconomy') to guide template selection.
     * @returns {boolean} - True if fake news was successfully launched, false otherwise.
     */
     function lancarFakeNews(contextHint = null) {
        console.log(`Tentando lan√ßar Fake News. Contexto: ${contextHint || 'Geral'}`);

        // --- 1. Validation ---
        if (!fakeNewsTemplates || fakeNewsTemplates.length === 0) {
            console.warn("lancarFakeNews: Nenhum template de fake news definido.");
            return false; // Cannot launch if no templates exist
        }

        // --- 2. Select Template ---
        let templatePool = fakeNewsTemplates;

        // Filter pool based on context hint, if provided
        if (contextHint) {
            let potentialMatches = [];
            if (contextHint.includes('Corruption') || contextHint.includes('Honesty')) {
                 potentialMatches = templatePool.filter(t => t.tipo === 'Corrup√ß√£oPessoal' || t.tipo === 'EscandaloFamiliarFake');
            } else if (contextHint.includes('Economy')) {
                 potentialMatches = templatePool.filter(t => t.tipo === 'IncompetenciaEconomica');
            } else if (contextHint.includes('Social')) {
                 // Add relevant template types if created, e.g., 'PromessaQuebradaSocial'
                 potentialMatches = templatePool.filter(t => t.tipo === 'PromessaQuebradaSocial');
            } else if (contextHint.includes('Diplomacy') || contextHint.includes('Nationalism')) {
                potentialMatches = templatePool.filter(t => t.tipo === 'AliancaSecreta');
            }
            // Use filtered pool if matches found, otherwise fallback to full pool
            if (potentialMatches.length > 0) {
                templatePool = potentialMatches;
                console.log(`Selecionando template de Fake News do pool filtrado (${contextHint})`);
            } else {
                 console.log(`Nenhum template espec√≠fico para ${contextHint}, usando pool geral.`);
            }
        }

        if (templatePool.length === 0) {
             console.warn("Pool de templates de Fake News ficou vazio ap√≥s filtragem.");
             return false; // Cannot launch if filter removed all options
        }

        const template = getRandomElement(templatePool);
        if (!template) {
             console.error("Erro ao selecionar template de Fake News aleat√≥rio.");
             return false;
        }
        console.log(`Template selecionado: ${template.id} (${template.tipo})`);


        // --- 3. Personalize Text ---
        let textoGerado = template.texto;
        try { // Add try-catch for safety during personalization
            // Replace placeholders using current game state
            if (textoGerado.includes('[AREA_RECENTE]')) {
                // Find an area with significant recent spending changes? Or just random? Random is simpler.
                textoGerado = textoGerado.replace('[AREA_RECENTE]', capitalize(getRandomElement(AREAS_ORCAMENTO)));
            }
            if (textoGerado.includes('[INDICADOR_RUIM]')) {
                // Find a genuinely poorly performing indicator
                const worstIndicator = Object.keys(indicadoresSociaisEconomicos).reduce((worst, key) => { /* ... same logic as in aiOponenteTurno ... */ }, null);
                textoGerado = textoGerado.replace('[INDICADOR_RUIM]', worstIndicator ? capitalize(worstIndicator.key) : 'a economia'); // Fallback
            }
            if (textoGerado.includes('[NOME_FAMILIAR]')) {
                const familiar = lider.familia ? getRandomElement(lider.familia.filter(f => f.tipo !== 'parente_distante')) : null; // Prioritize close family
                textoGerado = textoGerado.replace('[NOME_FAMILIAR]', familiar ? familiar.nome : 'um parente pr√≥ximo'); // Fallback
            }
            if (textoGerado.includes('[PAIS_RELACAO_BAIXA]')) {
                const lowRelPaisId = Object.keys(relacoesPaises).find(p => relacoesPaises[p] < 40);
                textoGerado = textoGerado.replace('[PAIS_RELACAO_BAIXA]', lowRelPaisId ? (paises[lowRelPaisId]?.nome || capitalize(lowRelPaisId)) : 'pot√™ncias estrangeiras'); // Fallback
            }
             // Add more placeholder replacements as needed
        } catch (personalizationError) {
             console.error("Erro ao personalizar texto da Fake News:", personalizationError);
             // Use template text directly if personalization fails?
             textoGerado = template.texto.replace(/\[.*?\]/g, '(detalhes omitidos)'); // Replace placeholders generically
        }


        // --- 4. Prepare Active Fake News Object ---
        // Define the impact to be applied over time
        const impactoPendente = {
            popGeral: template.impactoPopGeral || 0,
            popGrupo: { ...(template.impactoPopGrupo || {}) } // Copy group impacts
            // Could add other impact types: specific indicator hits, relation hits?
        };

        const novaFakeNews = {
            id: template.id,
            textoGerado: textoGerado,
            impactoPendente: impactoPendente,
            rodadasRestantes: template.duracao || 3, // Default duration 3 rounds
            rodadaLancamento: (mandatoAtual - 1) * RODADAS_POR_MANDATO + rodada // Track when launched
        };

        // --- 5. Add to Active List & Provide Feedback ---
        fakeNewsAtivas.push(novaFakeNews);
        adicionarNoticia(`‚ùì FAKE NEWS? ${textoGerado}`, "oposicao", "aviso");
        console.log("Fake News lan√ßada:", novaFakeNews);

        // --- 6. Optional: Trigger Player Response Dilemma ---
        // if (Math.random() < 0.3) { // 30% chance to allow player response
        //     scheduleFutureEffects([{ eventoId: 'dilema_resposta_fakenews', delayMin: 0, delayMax: 1, chance: 1 }], template.id);
        // }

        return true; // Successfully launched
    }

    /**
     * Applies the negative effects of active fake news items each round.
     * Called at the beginning of `proximoTurno`.
     */
    function applyFakeNewsEffects() {
        if (!fakeNewsAtivas || fakeNewsAtivas.length === 0) return; // Skip if none active

        // console.log(`Aplicando efeitos de ${fakeNewsAtivas.length} fake news ativas...`); // Can be noisy
        let newsParaRemover = [];

        for (let i = 0; i < fakeNewsAtivas.length; i++) {
            const news = fakeNewsAtivas[i];
            const impactoRodada = {};

            // Apply a fraction of the total impact each round (simple linear decay)
            // A better model might have stronger initial impact fading over time.
            const fraction = 1 / (news.rodadasRestantes || 1); // Avoid division by zero

            // Calculate impact for this round
            if (news.impactoPendente.popGeral) {
                impactoRodada.popGeral = Math.round(news.impactoPendente.popGeral * fraction);
            }
            if (news.impactoPendente.popGrupo) {
                for (const grupoKey in news.impactoPendente.popGrupo) {
                    const effectKey = `pop${capitalize(grupoKey)}`; // Assumes keys like 'empresarios', 'trabalhadores'
                    impactoRodada[effectKey] = Math.round(news.impactoPendente.popGrupo[grupoKey] * fraction);
                }
            }

            // Apply the calculated effects for this round
            if (Object.keys(impactoRodada).length > 0) {
                 console.log(`Aplicando impacto da fake news ${news.id}:`, impactoRodada);
                 aplicarEfeitos(impactoRodada);
            }

            // Decrement duration and mark for removal if finished
            news.rodadasRestantes--;
            if (news.rodadasRestantes <= 0) {
                newsParaRemover.push(i);
                adicionarNoticia(`Boato sobre "${truncateText(news.textoGerado, 40)}" parece ter perdido for√ßa.`, "sistema");
            }
        } // End loop through active news

        // Remove finished news (iterate backwards)
        if (newsParaRemover.length > 0) {
            console.log(`Removendo ${newsParaRemover.length} fake news expiradas.`);
            for (let i = newsParaRemover.length - 1; i >= 0; i--) {
                fakeNewsAtivas.splice(newsParaRemover[i], 1);
            }
        }
    }
    
    /**
     * Applies the negative effects of active fake news items for the current round.
     * Calculates the impact fraction for each active item, applies it via `aplicarEfeitos`,
     * decrements the remaining duration, and removes expired items.
     * Should be called once per turn (e.g., at the start of `proximoTurno`).
     */
     function applyFakeNewsEffects() {
        // --- 1. Check if Any Fake News Active ---
        if (!Array.isArray(fakeNewsAtivas) || fakeNewsAtivas.length === 0) {
            // console.log("Nenhuma fake news ativa para aplicar efeitos."); // Normal log, can be noisy
            return; // Skip if none active
        }

        console.log(`Aplicando efeitos de ${fakeNewsAtivas.length} fake news ativas...`);
        let newsParaRemover = []; // Store indices of news items to remove

        // --- 2. Iterate Through Active Fake News ---
        for (let i = 0; i < fakeNewsAtivas.length; i++) {
            const news = fakeNewsAtivas[i];

            // Safety check for valid data structure
            if (!news || typeof news.rodadasRestantes !== 'number' || !news.impactoPendente) {
                console.warn(`Item de fake news inv√°lido no √≠ndice ${i}, marcando para remo√ß√£o:`, news);
                newsParaRemover.push(i);
                continue; // Skip to the next item
            }

            // --- 3. Calculate Impact for This Round ---
            const impactoRodada = {};
            // Simple linear decay: apply 1/remaining rounds of the total impact each turn.
            // Example: If impact is -10 over 5 rounds, apply -2 each round.
            // Avoid division by zero if rodadasRestantes somehow becomes 0 before removal.
            const fraction = 1 / Math.max(1, news.rodadasRestantes);

            // Calculate popGeral impact for this round
            if (news.impactoPendente.popGeral) {
                // Use Math.floor for negative impacts, Math.ceil for positive to ensure it trends towards zero
                const change = news.impactoPendente.popGeral * fraction;
                impactoRodada.popGeral = change < 0 ? Math.floor(change) : Math.ceil(change);
            }

            // Calculate popGrupo impact for this round
            if (news.impactoPendente.popGrupo) {
                for (const grupoKey in news.impactoPendente.popGrupo) {
                    const effectKey = `pop${capitalize(grupoKey)}`; // Assumes keys like 'empresarios'
                    const change = news.impactoPendente.popGrupo[grupoKey] * fraction;
                     if (change !== 0) { // Only add if there's an actual effect
                        impactoRodada[effectKey] = change < 0 ? Math.floor(change) : Math.ceil(change);
                     }
                }
            }
             // Add calculations for other potential effect types (indicators, relations?) if needed

            // --- 4. Apply Calculated Effects ---
            if (Object.keys(impactoRodada).length > 0) {
                console.log(`Aplicando impacto da fake news ${news.id} (Rodada ${news.rodadasRestantes} restantes):`, impactoRodada);
                aplicarEfeitos(impactoRodada); // Call main effect function
            } else {
                 // console.log(`Nenhum impacto calculado para fake news ${news.id} nesta rodada.`); // Optional log
            }

            // --- 5. Decrement Duration & Check for Expiry ---
            news.rodadasRestantes--;

            if (news.rodadasRestantes <= 0) {
                newsParaRemover.push(i); // Mark for removal
                adicionarNoticia(`Boato sobre "${truncateText(news.textoGerado, 40)}" parece ter perdido for√ßa.`, "sistema");
                console.log(`Fake news ${news.id} expirou.`);
            }
        } // End loop through active news

        // --- 6. Remove Expired Fake News ---
        if (newsParaRemover.length > 0) {
            console.log(`Removendo ${newsParaRemover.length} fake news expiradas.`);
            // Remove items by index, iterating backwards to avoid index shifting issues
            for (let i = newsParaRemover.length - 1; i >= 0; i--) {
                fakeNewsAtivas.splice(newsParaRemover[i], 1);
            }
        }
    }


    // --- Debate System --- (Defined before game loop/events)
    /**
     * Initiates the Debate event.
     * Selects the opponent, sets up the debate state, pauses the game,
     * displays the debate modal, and presents the first question.
     * Typically triggered by campaign events or periodically.
     * @returns {boolean} - True if the debate was successfully initiated, false otherwise.
     */
    function dispararEventoDebate() {
        console.log("--- Disparando Evento de Debate ---");

        // --- 1. Validation ---
        if (!jogoAtivo || jogoPausado || eventoOrcamentoAtivo || debateAtual) {
             console.warn("Debate bloqueado: Jogo n√£o ativo, pausado, ou outro evento em andamento.");
             // If called by campaign, maybe add flag retry later?
             return false; // Cannot start debate now
        }
        if (!oponentePrincipal) {
            console.warn("Tentativa de debate sem oponente principal selecionado.");
            // Optionally select an opponent now if missing?
            oponentePrincipal = selectOpponent();
            if (!oponentePrincipal) {
                 adicionarNoticia("Debate cancelado: Nenhum oponente claro definido.", "sistema", "aviso");
                 return false; // Still no opponent
            }
             adicionarNoticia(`Oponente ${oponentePrincipal.nome} definido para o debate.`, "sistema");
        }
        if (!debateQuestoes || debateQuestoes.length < NUM_DEBATE_QUESTIONS) {
             console.error("Erro: N√£o h√° quest√µes suficientes definidas para o debate!");
             alert("Erro interno: Falha ao carregar quest√µes do debate.");
             return false;
        }

        // --- 2. Initialize Debate State ---
        debateAtual = {
            oponente: oponentePrincipal, // Store reference to current opponent
            questaoAtual: 0, // Counter for current question number (will be incremented before display)
            pontuacaoJogador: 0,
            pontuacaoOponente: 0,
            questoesUsadas: [] // Keep track of question IDs used in this debate
        };
        jogoPausado = true; // PAUSE the main game loop

        // --- 3. Feedback & UI Setup ---
        adicionarNoticia(`üéôÔ∏è DEBATE PRESIDENCIAL com ${oponentePrincipal.nome} vai come√ßar! Prepare seus argumentos!`, "evento", "aviso");
        console.log("Estado do debate inicializado. Jogo pausado.", debateAtual);

        // Show the modal (ensure it's hidden initially if needed)
        mostrarModalDebate();

        // --- 4. Present First Question ---
        // Use setTimeout to allow modal transition animation before content appears
        setTimeout(apresentarQuestaoDebate, 300); // Delay slightly

        // --- 5. Update Main UI (to disable other actions) ---
        atualizarUI();

        return true; // Indicate debate event successfully started and took over the turn
    }

    /** Helper to show the debate modal */
    function mostrarModalDebate() {
        const modal = document.getElementById('modal-debate');
        if (modal) modal.style.display = 'block';
        else console.error("Elemento #modal-debate n√£o encontrado!");
    }

    /** Helper to hide the debate modal */
    function fecharModalDebate() {
        const modal = document.getElementById('modal-debate');
        if (modal) modal.style.display = 'none';
        // Note: jogoPausado is reset within finalizarDebate
    }
    
    /**
     * Helper function to show the debate modal (#modal-debate)
     * by setting its display style to 'block'. Includes basic error check.
     */
     function mostrarModalDebate() {
        const modal = document.getElementById('modal-debate');

        if (modal) {
            modal.style.display = 'block';
            console.log("Modal de debate (#modal-debate) exibido.");
        } else {
            // Log an error if the modal element doesn't exist in the HTML
            console.error("Elemento #modal-debate n√£o encontrado no HTML! N√£o √© poss√≠vel exibir o debate.");
            // Optionally show an alert to the user
            // alert("Erro cr√≠tico: Interface do debate n√£o encontrada.");
        }
    }
    
    /**
     * Helper function to hide the debate modal (#modal-debate)
     * by setting its display style to 'none'. Includes basic error check.
     * Note: This only hides the modal. Resetting debate state and
     * unpausing the game should be handled by `finalizarDebate`.
     */
     function fecharModalDebate() {
        const modal = document.getElementById('modal-debate');

        if (modal) {
            modal.style.display = 'none';
            console.log("Modal de debate (#modal-debate) ocultado.");
        } else {
            // Log an error if the modal element doesn't exist in the HTML
            // This might happen if called erroneously when the modal was never opened.
            console.warn("Elemento #modal-debate n√£o encontrado para ocultar.");
        }
        // IMPORTANT: This function intentionally DOES NOT reset jogoPausado or debateAtual.
        // That state management should happen in the function that logically concludes the debate (finalizarDebate).
    }
    
    /**
     * Selects, personalizes, and displays the next debate question and response options
     * within the debate modal (#modal-debate).
     * Called by `dispararEventoDebate` and `responderDebate`.
     */
     function apresentarQuestaoDebate() {
        // --- 1. Validation & Check Completion ---
        if (!debateAtual) {
             console.error("apresentarQuestaoDebate chamada sem debate ativo.");
             return; // Should not happen
        }
        if (debateAtual.questaoAtual >= NUM_DEBATE_QUESTIONS) {
            console.log("N√∫mero m√°ximo de quest√µes atingido. Finalizando debate...");
            finalizarDebate(); // Debate is over
            return;
        }

        console.log(`Apresentando quest√£o ${debateAtual.questaoAtual + 1} do debate...`);

        // --- 2. Select Next Question ---
        // Filter out questions already used in this specific debate instance
        const questaoPool = debateQuestoes.filter(q => !debateAtual.questoesUsadas.includes(q.id));

        if (questaoPool.length === 0) {
            console.warn("N√£o h√° mais quest√µes de debate in√©ditas dispon√≠veis. Finalizando debate.");
            finalizarDebate(); // Ran out of unique questions
            return;
        }

        // Optional: Prioritize questions relevant to current game state (e.g., bad economy -> economic questions)
        let questaoSelecionada = null;
        // --- Relevance Check (Example) ---
        const worstIndicator = Object.keys(indicadoresSociaisEconomicos).reduce((worst, key) => { /* ... logic from aiOponenteTurno to find worst ... */ }, null);
        const relevantPool = questaoPool.filter(q =>
             (q.tema === 'Economia' && worstIndicator?.key && ['inflacao', 'desemprego', 'crescimentoPIB'].includes(worstIndicator.key) && worstIndicator.score > 4) ||
             (q.tema === 'Social' && (popularidadeGrupos[getGrupoKey('Trabalhadores')] < 40 || popularidadeGrupos[getGrupoKey('Progressistas')] < 40)) ||
              (q.tema === 'Corrup√ß√£o' && (lider.atributos?.honestidade < 5 || campaignState?.flags['escandalo_resolvido_recentemente']))
              // Add more relevance checks
        );
        if (relevantPool.length > 0 && Math.random() < 0.7) { // 70% chance to pick relevant question
             questaoSelecionada = getRandomElement(relevantPool);
             console.log(`Quest√£o relevante selecionada: ${questaoSelecionada.id} (Tema: ${questaoSelecionada.tema})`);
        } else {
             questaoSelecionada = getRandomElement(questaoPool); // Fallback to random from remaining pool
             console.log(`Quest√£o aleat√≥ria selecionada: ${questaoSelecionada.id} (Tema: ${questaoSelecionada.tema})`);
        }
        // --- End Relevance Check ---

        if (!questaoSelecionada) { // Should not happen if pool wasn't empty
             console.error("Falha ao selecionar a pr√≥xima quest√£o do debate.");
             finalizarDebate(); return;
        }

        // Mark question as used for *this* debate instance
        debateAtual.questoesUsadas.push(questaoSelecionada.id);
        debateAtual.questaoAtual++; // Increment *before* display

        // --- 3. Personalize Question Text ---
        let textoPergunta = questaoSelecionada.pergunta;
        try {
             if (textoPergunta.includes('[INDICADOR_RUIM]')) {
                // Find a specific bad indicator or use a relevant one
                 const badIndicators = Object.entries(indicadoresSociaisEconomicos)
                     .filter(([key, val]) => (['inflacao', 'desemprego', 'criminalidade'].includes(key) && val > 60) || (key === 'crescimentoPIB' && val < 1))
                     .map(([key, val]) => capitalize(key));
                 textoPergunta = textoPergunta.replace('[INDICADOR_RUIM]', badIndicators.length > 0 ? getRandomElement(badIndicators) : 'a economia');
             }
             if (textoPergunta.includes('[PROGRAMA_SOCIAL]')) {
                 // Pick a relevant social program based on budget or events? Or random.
                 textoPergunta = textoPergunta.replace('[PROGRAMA_SOCIAL]', getRandomElement(['Bolsa Fam√≠lia', 'a reforma agr√°ria', 'o sistema de sa√∫de']));
             }
             if (textoPergunta.includes('[MINISTRO_ESCANDALO') || textoPergunta.includes('seu governo')) {
                 // Find a minister with low loyalty or high risk? Simple approach: Use generic.
                 textoPergunta = textoPergunta.replace('[MINISTRO_ESCANDALO || \'seu governo\']', 'seu governo');
             }
             if (textoPergunta.includes('[PAIS_RELACAO_BAIXA]')) {
                 const lowRelPaisId = Object.keys(relacoesPaises).sort((a, b) => relacoesPaises[a] - relacoesPaises[b])[0]; // Find country with lowest relation
                 textoPergunta = textoPergunta.replace('[PAIS_RELACAO_BAIXA]', lowRelPaisId ? (paises[lowRelPaisId]?.nome || capitalize(lowRelPaisId)) : 'pot√™ncias estrangeiras');
             }
              if (textoPergunta.includes('[REGIAO_ALEATORIA]')) {
                   textoPergunta = textoPergunta.replace('[REGIAO_ALEATORIA]', getRandomElement(REGIOES));
              }
             // Add more personalization...
         } catch (e) { console.error("Erro ao personalizar pergunta do debate:", e); }


        // --- 4. Update Modal Display ---
        const elTitulo = document.getElementById('debate-titulo');
        const elOponente = document.getElementById('debate-oponente-nome');
        const elQuestaoNum = document.getElementById('debate-questao-num');
        const elQuestaoTotal = document.getElementById('debate-questao-total');
        const elPergunta = document.getElementById('debate-pergunta-texto');
        const elFeedback = document.getElementById('debate-feedback');

        if(elTitulo) elTitulo.innerText = `Debate - Quest√£o ${debateAtual.questaoAtual}/${NUM_DEBATE_QUESTIONS}: ${questaoSelecionada.tema}`;
        if(elOponente) elOponente.innerText = debateAtual.oponente.nome;
        if(elQuestaoNum) elQuestaoNum.innerText = debateAtual.questaoAtual;
        if(elQuestaoTotal) elQuestaoTotal.innerText = NUM_DEBATE_QUESTIONS;
        if(elPergunta) elPergunta.innerText = textoPergunta;
        if(elFeedback) elFeedback.innerText = `Aguardando sua resposta... (Oponente: ${debateAtual.oponente.nome})`; // Clear previous feedback

        // --- 5. Generate Player Response Options ---
        const painelRespostas = document.getElementById('debate-opcoes-resposta');
        if(!painelRespostas) { console.error("Painel de op√ß√µes de resposta do debate n√£o encontrado!"); return; }
        painelRespostas.innerHTML = ''; // Clear previous buttons

        // Define potential responses (could be dynamically generated based on question/leader)
        const respostas = [
            { texto: "Defender minhas pol√≠ticas com veem√™ncia.", tipo: 'carisma', condicaoAttr: 'carisma', minValor: 5, ptsBase: 2, modPos: 0.5, modNeg: 0.2 },
            { texto: "Apresentar dados e planos detalhados.", tipo: 'estrategia', condicaoAttr: 'estrategia', minValor: 5, ptsBase: 2, modPos: 0.6, modNeg: 0.3 },
            { texto: "Apelar para a compreens√£o do povo.", tipo: 'carisma', condicaoAttr: 'carisma', minValor: 4, ptsBase: 1, modPos: 0.7, modNeg: 0.1, traitBonus: 'Populista'},
            { texto: "Desviar e atacar a credibilidade do oponente.", tipo: 'ataque', condicaoAttr: 'honestidade', minValor: 0, ptsBase: 0, modPos: 0.1, modNeg: 0.5, requiresLowHonesty: true } // Risky
        ];

        respostas.forEach((resp, index) => {
             let isEnabled = true;
             let title = "";
             // Check conditions (Attribute requirement)
             if (resp.condicaoAttr && (lider.atributos?.[resp.condicaoAttr] || 0) < resp.minValor) {
                 isEnabled = false;
                 title = `Requer ${capitalize(resp.condicaoAttr)} >= ${resp.minValor}`;
             }
             // Check low honesty requirement for attack
              if (resp.requiresLowHonesty && (lider.atributos?.honestidade || 5) >= 5) {
                  isEnabled = false;
                  title = `Sua honestidade impede este tipo de ataque.`;
              }


             const button = document.createElement("button");
             button.className = `botao ${resp.tipo === 'ataque' ? 'perigo' : ''}`;
             button.innerHTML = resp.texto; // Use innerHTML if needed
             button.disabled = !isEnabled;
             button.title = title;
             button.onclick = () => responderDebate(index, resp); // Pass index and response definition
             painelRespostas.appendChild(button);
        });
    }
    
    /**
     * Selects, personalizes, and displays the next debate question and response options
     * within the debate modal (#modal-debate).
     * Called by `dispararEventoDebate` and `responderDebate`.
     */
     function apresentarQuestaoDebate() {
        // --- 1. Validation & Check Completion ---
        if (!debateAtual) {
             console.error("apresentarQuestaoDebate chamada sem debate ativo.");
             return; // Should not happen
        }
        if (debateAtual.questaoAtual >= NUM_DEBATE_QUESTIONS) {
            console.log("N√∫mero m√°ximo de quest√µes atingido. Finalizando debate...");
            finalizarDebate(); // Debate is over
            return;
        }

        console.log(`Apresentando quest√£o ${debateAtual.questaoAtual + 1} do debate...`);

        // --- 2. Select Next Question ---
        // Filter out questions already used in this specific debate instance
        const questaoPool = debateQuestoes.filter(q => !debateAtual.questoesUsadas.includes(q.id));

        if (questaoPool.length === 0) {
            console.warn("N√£o h√° mais quest√µes de debate in√©ditas dispon√≠veis. Finalizando debate.");
            finalizarDebate(); // Ran out of unique questions
            return;
        }

        // Optional: Prioritize questions relevant to current game state (e.g., bad economy -> economic questions)
        let questaoSelecionada = null;
        // --- Relevance Check (Example) ---
        const worstIndicator = Object.keys(indicadoresSociaisEconomicos).reduce((worst, key) => { /* ... logic from aiOponenteTurno to find worst ... */ }, null);
        const relevantPool = questaoPool.filter(q =>
             (q.tema === 'Economia' && worstIndicator?.key && ['inflacao', 'desemprego', 'crescimentoPIB'].includes(worstIndicator.key) && worstIndicator.score > 4) ||
             (q.tema === 'Social' && (popularidadeGrupos[getGrupoKey('Trabalhadores')] < 40 || popularidadeGrupos[getGrupoKey('Progressistas')] < 40)) ||
              (q.tema === 'Corrup√ß√£o' && (lider.atributos?.honestidade < 5 || campaignState?.flags['escandalo_resolvido_recentemente']))
              // Add more relevance checks
        );
        if (relevantPool.length > 0 && Math.random() < 0.7) { // 70% chance to pick relevant question
             questaoSelecionada = getRandomElement(relevantPool);
             console.log(`Quest√£o relevante selecionada: ${questaoSelecionada.id} (Tema: ${questaoSelecionada.tema})`);
        } else {
             questaoSelecionada = getRandomElement(questaoPool); // Fallback to random from remaining pool
             console.log(`Quest√£o aleat√≥ria selecionada: ${questaoSelecionada.id} (Tema: ${questaoSelecionada.tema})`);
        }
        // --- End Relevance Check ---

        if (!questaoSelecionada) { // Should not happen if pool wasn't empty
             console.error("Falha ao selecionar a pr√≥xima quest√£o do debate.");
             finalizarDebate(); return;
        }

        // Mark question as used for *this* debate instance
        debateAtual.questoesUsadas.push(questaoSelecionada.id);
        debateAtual.questaoAtual++; // Increment *before* display

        // --- 3. Personalize Question Text ---
        let textoPergunta = questaoSelecionada.pergunta;
        try {
             if (textoPergunta.includes('[INDICADOR_RUIM]')) {
                // Find a specific bad indicator or use a relevant one
                 const badIndicators = Object.entries(indicadoresSociaisEconomicos)
                     .filter(([key, val]) => (['inflacao', 'desemprego', 'criminalidade'].includes(key) && val > 60) || (key === 'crescimentoPIB' && val < 1))
                     .map(([key, val]) => capitalize(key));
                 textoPergunta = textoPergunta.replace('[INDICADOR_RUIM]', badIndicators.length > 0 ? getRandomElement(badIndicators) : 'a economia');
             }
             if (textoPergunta.includes('[PROGRAMA_SOCIAL]')) {
                 // Pick a relevant social program based on budget or events? Or random.
                 textoPergunta = textoPergunta.replace('[PROGRAMA_SOCIAL]', getRandomElement(['Bolsa Fam√≠lia', 'a reforma agr√°ria', 'o sistema de sa√∫de']));
             }
             if (textoPergunta.includes('[MINISTRO_ESCANDALO') || textoPergunta.includes('seu governo')) {
                 // Find a minister with low loyalty or high risk? Simple approach: Use generic.
                 textoPergunta = textoPergunta.replace('[MINISTRO_ESCANDALO || \'seu governo\']', 'seu governo');
             }
             if (textoPergunta.includes('[PAIS_RELACAO_BAIXA]')) {
                 const lowRelPaisId = Object.keys(relacoesPaises).sort((a, b) => relacoesPaises[a] - relacoesPaises[b])[0]; // Find country with lowest relation
                 textoPergunta = textoPergunta.replace('[PAIS_RELACAO_BAIXA]', lowRelPaisId ? (paises[lowRelPaisId]?.nome || capitalize(lowRelPaisId)) : 'pot√™ncias estrangeiras');
             }
              if (textoPergunta.includes('[REGIAO_ALEATORIA]')) {
                   textoPergunta = textoPergunta.replace('[REGIAO_ALEATORIA]', getRandomElement(REGIOES));
              }
             // Add more personalization...
         } catch (e) { console.error("Erro ao personalizar pergunta do debate:", e); }


        // --- 4. Update Modal Display ---
        const elTitulo = document.getElementById('debate-titulo');
        const elOponente = document.getElementById('debate-oponente-nome');
        const elQuestaoNum = document.getElementById('debate-questao-num');
        const elQuestaoTotal = document.getElementById('debate-questao-total');
        const elPergunta = document.getElementById('debate-pergunta-texto');
        const elFeedback = document.getElementById('debate-feedback');

        if(elTitulo) elTitulo.innerText = `Debate - Quest√£o ${debateAtual.questaoAtual}/${NUM_DEBATE_QUESTIONS}: ${questaoSelecionada.tema}`;
        if(elOponente) elOponente.innerText = debateAtual.oponente.nome;
        if(elQuestaoNum) elQuestaoNum.innerText = debateAtual.questaoAtual;
        if(elQuestaoTotal) elQuestaoTotal.innerText = NUM_DEBATE_QUESTIONS;
        if(elPergunta) elPergunta.innerText = textoPergunta;
        if(elFeedback) elFeedback.innerText = `Aguardando sua resposta... (Oponente: ${debateAtual.oponente.nome})`; // Clear previous feedback

        // --- 5. Generate Player Response Options ---
        const painelRespostas = document.getElementById('debate-opcoes-resposta');
        if(!painelRespostas) { console.error("Painel de op√ß√µes de resposta do debate n√£o encontrado!"); return; }
        painelRespostas.innerHTML = ''; // Clear previous buttons

        // Define potential responses (could be dynamically generated based on question/leader)
        const respostas = [
            { texto: "Defender minhas pol√≠ticas com veem√™ncia.", tipo: 'carisma', condicaoAttr: 'carisma', minValor: 5, ptsBase: 2, modPos: 0.5, modNeg: 0.2 },
            { texto: "Apresentar dados e planos detalhados.", tipo: 'estrategia', condicaoAttr: 'estrategia', minValor: 5, ptsBase: 2, modPos: 0.6, modNeg: 0.3 },
            { texto: "Apelar para a compreens√£o do povo.", tipo: 'carisma', condicaoAttr: 'carisma', minValor: 4, ptsBase: 1, modPos: 0.7, modNeg: 0.1, traitBonus: 'Populista'},
            { texto: "Desviar e atacar a credibilidade do oponente.", tipo: 'ataque', condicaoAttr: 'honestidade', minValor: 0, ptsBase: 0, modPos: 0.1, modNeg: 0.5, requiresLowHonesty: true } // Risky
        ];

        respostas.forEach((resp, index) => {
             let isEnabled = true;
             let title = "";
             // Check conditions (Attribute requirement)
             if (resp.condicaoAttr && (lider.atributos?.[resp.condicaoAttr] || 0) < resp.minValor) {
                 isEnabled = false;
                 title = `Requer ${capitalize(resp.condicaoAttr)} >= ${resp.minValor}`;
             }
             // Check low honesty requirement for attack
              if (resp.requiresLowHonesty && (lider.atributos?.honestidade || 5) >= 5) {
                  isEnabled = false;
                  title = `Sua honestidade impede este tipo de ataque.`;
              }


             const button = document.createElement("button");
             button.className = `botao ${resp.tipo === 'ataque' ? 'perigo' : ''}`;
             button.innerHTML = resp.texto; // Use innerHTML if needed
             button.disabled = !isEnabled;
             button.title = title;
             button.onclick = () => responderDebate(index, resp); // Pass index and response definition
             painelRespostas.appendChild(button);
        });
    }
    
    /**
     * Finalizes the debate event after all questions are answered.
     * Calculates the winner based on final scores, applies game effects
     * (popularity changes), provides feedback, resets debate state,
     * unpauses the game, and schedules the next turn.
     */
     function finalizarDebate() {
        console.log("--- Finalizando Debate ---");

        // --- 1. Validation ---
        if (!debateAtual) {
             console.warn("finalizarDebate chamado sem debate ativo.");
             // Ensure game is unpaused if called erroneously
             jogoPausado = false;
             fecharModalDebate(); // Ensure modal is closed
             return;
        }

        // --- 2. Determine Outcome & Effects ---
        const playerPts = debateAtual.pontuacaoJogador;
        const opponentPts = debateAtual.pontuacaoOponente;
        const diff = playerPts - opponentPts;
        let resultadoTexto = "";
        let efeitosResultado = {};
        let feedbackClass = "neutro"; // Use neutro for tie

        console.log(`Pontua√ß√£o Final: Jogador ${playerPts}, Oponente ${opponentPts} (Dif: ${diff})`);

        // Define outcomes based on score difference thresholds
        if (diff > 6) { // Decisive Win Threshold
            resultadoTexto = "VIT√ìRIA DECISIVA! Voc√™ dominou completamente o debate, deixando seu oponente sem respostas.";
            // Significant Pop boost, Opponent Pop hit
            efeitosResultado = { popGeral: +8, popularidadeOponente: -6 };
            feedbackClass = "sucesso";
            lider.experiencia += 5; // Bonus XP for decisive win
        } else if (diff > 2) { // Clear Win Threshold
            resultadoTexto = "VIT√ìRIA! Seus argumentos prevaleceram e voc√™ saiu por cima no debate.";
            // Moderate Pop boost, small Opponent Pop hit
            efeitosResultado = { popGeral: +4, popularidadeOponente: -3 };
            feedbackClass = "sucesso";
            lider.experiencia += 3; // Bonus XP
        } else if (diff >= -2) { // Draw Threshold (Includes diff 0, -1, -2)
            resultadoTexto = "EMPATE T√âCNICO. O debate foi acirrado e n√£o houve um vencedor claro na percep√ß√£o p√∫blica.";
            // Minimal effect, maybe slight boost for surviving
            efeitosResultado = { popGeral: +1 };
            feedbackClass = "aviso"; // Use aviso for neutral outcome visually?
            lider.experiencia += 1;
        } else if (diff >= -6) { // Clear Loss Threshold
            resultadoTexto = "DERROTA. Seu oponente conseguiu explorar suas fraquezas e saiu fortalecido do debate.";
            // Moderate Pop penalty, Opponent Pop boost
            efeitosResultado = { popGeral: -4, popularidadeOponente: +4 };
            feedbackClass = "perigo";
        } else { // Decisive Loss Threshold
            resultadoTexto = "DERROTA HUMILHANTE! O debate foi um desastre, sua imagem foi severamente prejudicada.";
            // Significant Pop penalty, large Opponent Pop boost
            efeitosResultado = { popGeral: -8, popularidadeOponente: +7 };
            feedbackClass = "perigo";
        }

        // Add opponent popularity effect directly to the state variable
        if (efeitosResultado.popularidadeOponente) {
            popularidadeOponente = clamp(popularidadeOponente + efeitosResultado.popularidadeOponente, 0, 100);
            delete efeitosResultado.popularidadeOponente; // Remove from effects object as it's handled directly
            console.log(`Popularidade do oponente ajustada para: ${popularidadeOponente}%`);
        }

        // --- 3. Apply Game Effects ---
        aplicarEfeitos(efeitosResultado); // Apply popGeral changes, etc.
        checkLevelUp(); // Check if bonus XP caused level up

        // --- 4. Provide Feedback ---
        adicionarNoticia(`Debate conclu√≠do! ${resultadoTexto}`, "evento", feedbackClass);

        // --- 5. Cleanup State & UI ---
        fecharModalDebate(); // Hide the modal
        debateAtual = null; // Clear the debate state object
        jogoPausado = false; // IMPORTANT: Resume the game loop
        console.log("Estado do debate limpo. Jogo resumido.");

        // --- 6. Update Main UI & Schedule Next Turn ---
        atualizarUI(); // Refresh the main UI to reflect changes
        setTimeout(proximoTurno, 150); // Schedule the next game turn
    }

    // --- Apply Effects (Main Logic) --- (Defined before actions)
    /**
     * Applies a set of effects to the game state variables.
     * Handles changes to popularity, indicators, budget, relations, loyalty, flags, etc.
     * Includes clamping values within reasonable bounds.
     * @param {Object|null} efeitos - An object where keys represent state variables or special actions,
     *                             and values represent the change to apply. e.g., { popGeral: -5, inflacao: +0.2 }
     */
    function aplicarEfeitos(efeitos) {
        // --- 1. Validation ---
        if (!efeitos || typeof efeitos !== 'object' || Object.keys(efeitos).length === 0) {
            // console.log("aplicarEfeitos chamado sem efeitos v√°lidos."); // Can be noisy
            return; // No effects to apply
        }

        console.log("--- Aplicando Efeitos ---", JSON.stringify(efeitos)); // Log effects being applied

        // --- 2. Handle Immediate Game Over / Special Flags First ---
        if (efeitos.gameOver === true) {
            console.log("Efeito 'gameOver' encontrado. Finalizando jogo...");
            gameOver(efeitos.mensagemFim || "Um evento causou o fim abrupto do seu governo!");
            return; // Stop processing further effects if game ended
        }
        if (efeitos.setFlag) {
            if (campaignState && campaignState.flags) {
                campaignState.flags[efeitos.setFlag] = true;
                console.log(`Flag de campanha '${efeitos.setFlag}' definida como true.`);
            } else {
                console.warn(`Tentativa de definir flag '${efeitos.setFlag}' sem estado de campanha ativo.`);
            }
        }
         // Handle direct boolean state changes like pandemic ending
         if (efeitos.pandemiaAtiva === false) {
             pandemiaAtiva = false;
             console.log("Flag 'pandemiaAtiva' definida como false.");
         }
         // Add other flag handlers as needed

        // --- 3. Apply Chance-Based Major Failures ---
        // Check these before applying regular stat changes as they might end the game
        if (efeitos.chanceGuerraCivil && Math.random() < efeitos.chanceGuerraCivil) { gameOver("A resist√™ncia falhou! O pa√≠s mergulhou em Guerra Civil."); return; }
        if (efeitos.chanceGuerraCivilRegional && Math.random() < efeitos.chanceGuerraCivilRegional) { adicionarNoticia("CONFLITO ARMADO irrompe na regi√£o rebelde!", "sistema", "perigo"); aplicarEfeitos({popGeral: -20, tesouro: -200, indicador_criminalidade: +15}); } // Apply immediate severe penalty
        if (efeitos.chanceEventoCaos && Math.random() < efeitos.chanceEventoCaos) { adicionarNoticia("A situa√ß√£o saiu de controle! Saques e viol√™ncia se espalham.", "sistema", "perigo"); aplicarEfeitos({popGeral: -15, crescimentoPIB: -1.0, indicador_criminalidade: +10}); }
        if (efeitos.chancePerdaTerritorio && Math.random() < efeitos.chancePerdaTerritorio && (dilemaAtual?.regiaoAlvo || regiaoEmRevolta)) { gameOver(`A regi√£o ${capitalize(dilemaAtual?.regiaoAlvo || regiaoEmRevolta)} declarou independ√™ncia e voc√™ perdeu o controle!`); return; }
        if (efeitos.chanceSancoes && Math.random() < efeitos.chanceSancoes) { adicionarNoticia("San√ß√µes econ√¥micas foram impostas por pot√™ncias estrangeiras!", "sistema", "perigo"); aplicarEfeitos({receitaPorRodadaMod: -15, crescimentoPIB: -0.5}); } // Apply via dedicated keys if possible, or direct state change
        if (efeitos.chanceFuturaCriseAgravada && Math.random() < efeitos.chanceFuturaCriseAgravada) { scheduleFutureEffects([{ eventoId: 'crise_investigacao_falhou', delayMin: 3, delayMax: 6, chance: 1 }], dilemaAtual?.id); /* Define 'crise_investigacao_falhou' */ console.log("Crise agravada agendada."); }
        if (efeitos.chanceFuturaVazamento && Math.random() < efeitos.chanceFuturaVazamento) { scheduleFutureEffects([{ eventoId: 'ev_vazamento_abafado', delayMin: 5, delayMax: 10, chance: 1 }], dilemaAtual?.id); console.log("Vazamento futuro agendado."); }
        if (efeitos.chanceFuturaVacina && Math.random() < efeitos.chanceFuturaVacina) { scheduleFutureEffects([{ eventoId: 'ev_vacina_descoberta', delayMin: 8, delayMax: 15, chance: 1 }], dilemaAtual?.id); console.log("Descoberta de vacina agendada."); }
         if (efeitos.chanceResolucaoOMC && Math.random() < efeitos.chanceResolucaoOMC) { adicionarNoticia("OMC interveio favoravelmente, resolvendo a disputa comercial.", "diplomacia", "sucesso"); /* Remove negative effects related to trade war? */ }
         if (efeitos.chanceAbafarSucesso && Math.random() < efeitos.chanceAbafarSucesso) { adicionarNoticia("Sua tentativa de abafar o esc√¢ndalo familiar parece ter funcionado... por enquanto.", "sistema"); /* Avoid negative consequences for now */ }
         else if (efeitos.chanceAbafarSucesso) { adicionarNoticia("A tentativa de abafar o esc√¢ndalo familiar falhou, gerando mais repercuss√£o negativa.", "sistema", "perigo"); aplicarEfeitos({ popGeral: -4 }); } // Apply penalty if abafar failed


        // --- 4. Apply Stat Changes ---
        // Use temporary variables to track cumulative changes if needed, or apply directly

        // 4a. Popularidade Grupos (including popGeral distribution)
        let popGeralMod = efeitos.popGeral || 0;
        for (const grupoKey in popularidadeGrupos) {
            const key = `pop${capitalize(grupoKey)}`; // Match keys like popEmpresarios etc.
            let change = (efeitos[key] || 0);
             // Distribute popGeral evenly - may dilute intended specific group changes
             // Alternative: Apply specific group changes FIRST, then apply popGeral on top?
             // Let's try applying specific first:
            if (efeitos[key] !== undefined) {
                popularidadeGrupos[grupoKey] = clamp(popularidadeGrupos[grupoKey] + efeitos[key], 0, 100);
            }
        }
         // Now apply popGeral modification on top of existing values
         if (popGeralMod !== 0) {
             const boostPerGroup = popGeralMod / (Object.keys(popularidadeGrupos).length || 1);
             for (const grupoKey in popularidadeGrupos) {
                  popularidadeGrupos[grupoKey] = clamp(popularidadeGrupos[grupoKey] + boostPerGroup, 0, 100);
             }
         }


        // 4b. Apoio Regional (including popNacionalMedia and specific targets)
        let popNacionalMediaMod = efeitos.popNacionalMedia || 0;
        const targetRegionKey = dilemaAtual?.regiaoAlvo || efeitos.regiaoAfetada; // Explicit target region

        for (const regiaoKey in apoioRegional) {
            const key = `reg${capitalize(regiaoKey)}`; // Keys like regSul, regNordeste etc.
            let change = (efeitos[key] || 0) + (popNacionalMediaMod / (Object.keys(apoioRegional).length || 1)); // Specific + Distributed National
            // Apply explicit target effects LAST to ensure they take precedence
            if (regiaoKey === targetRegionKey) {
                 if(efeitos.popRegiaoAlvo !== undefined) change += efeitos.popRegiaoAlvo;
                 if(efeitos.popRegiaoAfetada !== undefined) change += efeitos.popRegiaoAfetada;
            }
            apoioRegional[regiaoKey] = clamp(apoioRegional[regiaoKey] + change, 0, 100);
        }


        // 4c. Indicadores Sociais/Econ√¥micos (direct changes and _mod keys)
        for (const ind in indicadoresSociaisEconomicos) {
            let change = (efeitos[ind] || 0);
            // Check for modifier keys (e.g., crescimentoPIB_mod)
            if (efeitos[`${ind}_mod`] !== undefined) change += efeitos[`${ind}_mod`];

            if (change !== 0) {
                 indicadoresSociaisEconomicos[ind] += change;
                 // Clamping and Formatting applied AFTER calculation
                 if (['inflacao', 'desemprego', 'crescimentoPIB'].includes(ind)) indicadoresSociaisEconomicos[ind] = parseFloat(clamp(indicadoresSociaisEconomicos[ind], -10, 25).toFixed(1)); // Wider bounds?
                 else if (ind === 'dividaPublica') indicadoresSociaisEconomicos[ind] = parseFloat(Math.max(0, indicadoresSociaisEconomicos[ind]).toFixed(1));
                 else indicadoresSociaisEconomicos[ind] = clamp(indicadoresSociaisEconomicos[ind], 0, 100); // Indices 0-100
            }
        }

        // 4d. Or√ßamento (tesouro direct changes, costs from events)
        // Direct changes to tesouro
        if (efeitos.tesouro !== undefined) tesouro = Math.round(tesouro + efeitos.tesouro);
        // Costs associated with events/disasters
        const eventCosts = (efeitos.custoRecuperacao || 0) + (efeitos.custoAjudaEmergencial || 0) + (efeitos.custoCombateIncendio || 0);
        if (eventCosts > 0) {
             tesouro -= eventCosts;
             console.log(`Custos de evento/desastre aplicados: -${formatCurrency(eventCosts)}`);
        }
         // Apply permanent budget allocation modifiers (these should be done by choice handler, not generally here)
         // if (efeitos.orcamentoAreaMod) { /* Handled in escolherOpcao */ }
         // if (efeitos.orcamentoTotalModPercent) { /* Handled in escolherOpcao */ }
         // Apply permanent modifiers to base revenue/fixed costs (if using those state vars)
         // if (efeitos.receitaPorRodadaMod) { /* Modify base revenue state var */ }
         // if (efeitos.despesaFixasMod) { despesasFixasPorRodada += efeitos.despesaFixasMod; }


        // 4e. Rela√ß√µes com Partidos (specific keys like relacoesPartidos_partido_b)
        for (const key in efeitos) {
            if (key.startsWith("relacoesPartidos_")) {
                const partidoId = key.substring(17); // Get party ID from key
                if (relacoesPartidos[partidoId] !== undefined) {
                    relacoesPartidos[partidoId] = clamp(relacoesPartidos[partidoId] + (efeitos[key] || 0), 0, 100);
                } else {
                     console.warn(`Tentativa de modificar rela√ß√£o com partido desconhecido: ${partidoId}`);
                }
            }
        }


        // 4f. Satisfa√ß√£o da M√≠dia (specific keys like satisfacaoMidia_jornal_conservador, and Geral)
        let midiaGeralMod = efeitos.satisfacaoMidiaGeral || 0;
        for (const midiaId in satisfacaoMidia) {
            const key = `satisfacaoMidia_${midiaId}`;
            let change = (efeitos[key] || 0) + midiaGeralMod; // Apply specific + general
            if (change !== 0) {
                 satisfacaoMidia[midiaId] = clamp(satisfacaoMidia[midiaId] + change, 0, 100);
            }
        }
        // Handle international media separately if state exists
         if(efeitos.satisfacaoMidiaInternacional && typeof satisfacaoMidiaInternacional === 'number') { // Check if var exists
              satisfacaoMidiaInternacional = clamp(satisfacaoMidiaInternacional + efeitos.satisfacaoMidiaInternacional, 0, 100);
         }


        // 4g. Lealdade de Ministros (specific keys like lealdadeMinistro_min001, aleatorio, alvo)
        // Specific targets are handled by keys e.g. { lealdadeMinistro_min001: -10 }
        for (const key in efeitos) {
            if (key.startsWith("lealdadeMinistro_")) {
                const ministroId = key.substring(17);
                if (ministrosAtivos[ministroId]) {
                    ministrosAtivos[ministroId].lealdade = clamp(ministrosAtivos[ministroId].lealdade + (efeitos[key] || 0), 0, 100);
                } else {
                     // console.warn(`Tentativa de modificar lealdade de ministro inativo/desconhecido: ${ministroId}`);
                }
            }
        }
        // Random target
        if (efeitos.lealdadeMinistroAleatorio) {
            const ministroIds = Object.keys(ministrosAtivos);
            if (ministroIds.length > 0) {
                const randomMinistroId = getRandomElement(ministroIds);
                ministrosAtivos[randomMinistroId].lealdade = clamp(ministrosAtivos[randomMinistroId].lealdade + efeitos.lealdadeMinistroAleatorio, 0, 100);
                adicionarNoticia(`A lealdade do Ministro ${ministrosAtivos[randomMinistroId].nome} foi afetada (${efeitos.lealdadeMinistroAleatorio}%).`, "sistema");
            }
        }
        // Target from current dilemma/crisis (already handled in escolherOpcao before calling this?)
        // If not, add check: if (efeitos.lealdadeMinistroAlvo && dilemaAtual?.ministroAlvoId && ministrosAtivos[dilemaAtual.ministroAlvoId]) { ... }


        // 4h. Rela√ß√µes com Pa√≠ses (specific keys like relacao_pais_a, or relacaoPaisAlvo handled elsewhere)
        for (const key in efeitos) {
            if (key.startsWith("relacao_") && paises[key.substring(8)]) { // Check if key matches 'relacao_' + valid paisId
                const paisId = key.substring(8);
                relacoesPaises[paisId] = clamp((relacoesPaises[paisId] || 50) + (efeitos[key] || 0), 0, 100);
            }
        }
        // Note: relacaoPaisAlvo is typically handled directly by the calling function (e.g., criticarPais, proporAcordo)


        // 4i. Congresso (Direct % point changes - USE SPARINGLY)
        if (efeitos.congresso !== undefined) {
             congresso = clamp(congresso + efeitos.congresso, 0, 100);
             console.log(`Apoio direto ao congresso modificado em ${efeitos.congresso} para ${congresso}%`);
        }
        // Note: congresso_mod is handled differently - it modifies relations before recalculation


        // 4j. Leader XP
        if (efeitos.xpGain !== undefined && typeof lider.experiencia === 'number') {
             lider.experiencia += efeitos.xpGain;
             console.log(`L√≠der ganhou ${efeitos.xpGain} XP.`);
             // checkLevelUp(); // Check level up immediately after XP gain? Or let main loop handle it? Let main loop handle.
        }

        console.log("--- Efeitos Aplicados ---");
        // No need to call atualizarUI here, it's called after effects are applied by the calling function or game loop.
    }
    
    /**
     * Modifies a base effects object based on the leader's attributes, traits, and skills.
     * Applies bonuses or penalties to effects like popularity change, negotiation outcomes,
     * crisis impact, economic results, etc.
     * @param {Object} efeitos - The base effects object to modify (e.g., { popGeral: -5, inflacao: +0.2 }).
     * @param {string} tipoDilema - The type of the dilemma/event triggering the effects (e.g., 'economia', 'social', 'gabinete').
     * @returns {Object} - The modified effects object.
     */
     function modificarEfeitosPorLider(efeitos, tipoDilema) {
        // --- 1. Safety Check & Clone ---
        if (!lider || !lider.atributos) {
            // console.warn("modificarEfeitosPorLider: Leader data not available.");
            return { ...efeitos }; // Return original effects if leader data is missing
        }
        // Create a copy to avoid modifying the original object passed in
        let modifiedEffects = { ...efeitos };

        // --- 2. Get Leader Stats ---
        const carisma = lider.atributos.carisma || 5;
        const honestidade = lider.atributos.honestidade || 5;
        const estrategia = lider.atributos.estrategia || 5;
        const traits = lider.tracos || [];
        const skills = lider.habilidades || [];

        // --- 3. Apply Attribute Modifiers ---

        // 3a. Carisma Effects (Popularity, Media, Diplomacy?)
        const carismaDiff = carisma - 5; // Difference from baseline 5
        if (carismaDiff !== 0) {
            // Modify General Popularity changes
            if (modifiedEffects.popGeral > 0) { // Positive changes amplified/reduced
                modifiedEffects.popGeral = Math.round(modifiedEffects.popGeral * (1 + carismaDiff * 0.06)); // 6% per point
            } else if (modifiedEffects.popGeral < 0) { // Negative changes mitigated/amplified
                modifiedEffects.popGeral = Math.round(modifiedEffects.popGeral * (1 - carismaDiff * 0.05)); // 5% mitigation per point > 5, 5% amplification per point < 5
            }
            // Modify Media Satisfaction changes
            if (modifiedEffects.satisfacaoMidiaGeral > 0) modifiedEffects.satisfacaoMidiaGeral = Math.round(modifiedEffects.satisfacaoMidiaGeral * (1 + carismaDiff * 0.05));
            if (modifiedEffects.satisfacaoMidiaGeral < 0) modifiedEffects.satisfacaoMidiaGeral = Math.round(modifiedEffects.satisfacaoMidiaGeral * (1 - carismaDiff * 0.04));
            // Modify specific diplomatic relation changes? (Could be complex)
            // if (tipoDilema === 'diplomacia' && modifiedEffects.relacaoPaisAlvo) { ... }
        }

        // 3b. Honestidade Effects (Scandals, Trust, Corruption Risk?)
        const honestidadeDiff = honestidade - 5;
        if (honestidadeDiff !== 0) {
             // Reduce negative impact of corruption/scandal related events
             if ((tipoDilema === 'gabinete' || tipoDilema === 'pessoal') && modifiedEffects.popGeral < 0) {
                  modifiedEffects.popGeral = Math.round(modifiedEffects.popGeral * (1 - honestidadeDiff * 0.07)); // Higher honesty mitigates more (7% per point > 5)
             }
             // Affect relation changes with certain parties/countries?
             // if (honestidade < 4 && modifiedEffects.relacao_pais_b) { modifiedEffects.relacao_pais_b -= 2; } // Low honesty annoys certain countries?
        }
        // Low honesty might enable certain 'corrupt' choices, handled by 'verificarCondicao'

        // 3c. Estrategia Effects (Economy, Diplomacy, Crisis Management, Negotiations)
        const estrategiaDiff = estrategia - 5;
        if (estrategiaDiff !== 0) {
             // Improve positive economic outcomes / mitigate negative
             if (tipoDilema === 'economia') {
                  if (modifiedEffects.crescimentoPIB > 0) modifiedEffects.crescimentoPIB = parseFloat((modifiedEffects.crescimentoPIB * (1 + estrategiaDiff * 0.05)).toFixed(2));
                  if (modifiedEffects.crescimentoPIB < 0) modifiedEffects.crescimentoPIB = parseFloat((modifiedEffects.crescimentoPIB * (1 - estrategiaDiff * 0.04)).toFixed(2));
                  if (modifiedEffects.inflacao < 0) modifiedEffects.inflacao = parseFloat((modifiedEffects.inflacao * (1 + estrategiaDiff * 0.05)).toFixed(2)); // Better reduction
                  if (modifiedEffects.inflacao > 0) modifiedEffects.inflacao = parseFloat((modifiedEffects.inflacao * (1 - estrategiaDiff * 0.04)).toFixed(2)); // Better control
             }
             // Improve success chance of future events scheduled by strategic decisions? (Harder to implement here)
             // Affect Congress negotiation (applied in calculateBudgetSupportNeeded or amendment logic)
             // Affect Diplomacy success (applied in proposal/negotiation functions)
             // Mitigate negative crisis impact (applied by Gestor de Crise skill below, or directly here)
              if (['golpe_estado', 'regional_conflito', 'pandemia', 'desastre'].includes(tipoDilema) && modifiedEffects.popGeral < 0) {
                   modifiedEffects.popGeral = Math.round(modifiedEffects.popGeral * (1 - estrategiaDiff * 0.03)); // Small mitigation based on strategy
              }
        }


        // --- 4. Apply Trait Modifiers ---
        if (traits.includes('Populista')) {
            if (modifiedEffects.popTrabalhadores > 0) modifiedEffects.popTrabalhadores = Math.round((modifiedEffects.popTrabalhadores || 0) * 1.15);
            if (modifiedEffects.popClasseMedia > 0) modifiedEffects.popClasseMedia = Math.round((modifiedEffects.popClasseMedia || 0) * 1.10);
            if (modifiedEffects.popEmpresarios < 0) modifiedEffects.popEmpresarios = Math.round((modifiedEffects.popEmpresarios || 0) * 1.1); // Amplify negative effect on opponents
        }
        if (traits.includes('Idealista')) {
            if (modifiedEffects.popProgressistas > 0) modifiedEffects.popProgressistas = Math.round((modifiedEffects.popProgressistas || 0) * 1.1);
            // Maybe small penalty if compromising? If effect involves negative hit to principles?
            if (tipoDilema === 'negociacao_compromisso' && modifiedEffects.popGeral !== undefined) modifiedEffects.popGeral -= 1; // Example
        }
        if (traits.includes('Pragm√°tico')) {
            if (modifiedEffects.congresso_mod > 0) modifiedEffects.congresso_mod = (modifiedEffects.congresso_mod || 0) + 1; // Bonus to congress deals
             // Small penalty to pop if action was unpopular but effective?
             if (modifiedEffects.popGeral < -3 && (modifiedEffects.crescimentoPIB > 0 || modifiedEffects.inflacao < 0)) modifiedEffects.popGeral -= 1;
        }
        if (traits.includes('Leal')) {
             // Bonus to coalition stability / relation gain with allies?
             if (modifiedEffects.relacoesPartidosCoalizao > 0) modifiedEffects.relacoesPartidosCoalizao += 2;
        }
         if (traits.includes('Tecnocrata')) {
              // Bonus to research success / project efficiency (costs)?
               if (modifiedEffects.custoOrcamentoImediato > 0 && ['economia', 'ciencia_tecnologia', 'infraestrutura'].includes(tipoDilema)) {
                    modifiedEffects.custoOrcamentoImediato = Math.round(modifiedEffects.custoOrcamentoImediato * 0.95); // 5% cost reduction
               }
         }
        // Add more trait interactions...


        // --- 5. Apply Skill Modifiers ---
        if (skills.includes('mestre_oratoria')) {
             // Handled within Carisma calculation above or in specific speech/debate events
        }
        if (skills.includes('gestor_crise')) {
            // Check if the current situation IS a crisis
            const isCrisis = crises.some(c => c.id === dilemaAtual?.id) || desastresRegionais.some(d => d.id === dilemaAtual?.id); // Extend check if needed
            if (isCrisis) {
                 console.log("Aplicando b√¥nus 'Gestor de Crise'...");
                 // Reduce negative impacts across the board
                 for (const key in modifiedEffects) {
                     if (typeof modifiedEffects[key] === 'number' && modifiedEffects[key] < 0) {
                          // Reduce negative impact by 15% (multiply by 0.85)
                           if (key !== 'tesouro' && !key.startsWith('custo')) { // Don't reduce costs, only negative stat hits
                                modifiedEffects[key] = Math.round(modifiedEffects[key] * 0.85);
                           }
                     }
                 }
            }
        }
        if (skills.includes('integridade_reconhecida')) {
            // Reduces chance of *triggering* scandals (handled elsewhere)
            // May also slightly improve relation gains based on honesty?
            if (honestidade > 7 && modifiedEffects.popGeral > 0) modifiedEffects.popGeral += 1;
        }
        if (skills.includes('economista_astuto')) {
             // Apply passive bonus *each round* (handled in applyOngoingEffects or similar)
             // Or add a small bonus to positive economic outcomes here?
              if (tipoDilema === 'economia') {
                  if (modifiedEffects.crescimentoPIB > 0) modifiedEffects.crescimentoPIB = parseFloat((modifiedEffects.crescimentoPIB + 0.1).toFixed(2));
                  if (modifiedEffects.inflacao < 0) modifiedEffects.inflacao = parseFloat((modifiedEffects.inflacao - 0.1).toFixed(2));
              }
        }
        // Add effects for 'negociador_experiente', 'articulador_partidario', 'diplomata_habil' where relevant
        // (e.g., modifying chance rolls or specific relation changes - might be better applied in those specific functions)


        // --- 6. Final Check & Return ---
        // Ensure numeric values are rounded appropriately
        for (const key in modifiedEffects) {
            if (typeof modifiedEffects[key] === 'number') {
                // Avoid rounding percentages too early if precision needed downstream
                if (!key.includes('PIB') && !key.includes('inflacao')) { // Keep decimals for these
                    modifiedEffects[key] = Math.round(modifiedEffects[key]);
                }
            }
        }

        // console.log("Efeitos ap√≥s modifica√ß√£o pelo l√≠der:", modifiedEffects); // Can be noisy
        return modifiedEffects;
    }
    
    /**
     * Modifies a base effects object based on the active ministers in the cabinet.
     * Considers minister's area relevance, personality, bonuses, and loyalty.
     * @param {Object} efeitos - The base effects object to modify.
     * @param {string} tipoDilema - The type of the dilemma/event triggering the effects.
     * @returns {Object} - The modified effects object.
     */
     function modificarEfeitosPorMinistros(efeitos, tipoDilema) {
        // --- 1. Safety Check & Clone ---
        if (!ministrosAtivos || Object.keys(ministrosAtivos).length === 0) {
            // console.log("modificarEfeitosPorMinistros: Nenhum ministro ativo.");
            return { ...efeitos }; // Return original if no ministers
        }
        let modifiedEffects = { ...efeitos };

        // --- 2. Iterate Through Active Ministers ---
        for (const ministroId in ministrosAtivos) {
            const ministro = ministrosAtivos[ministroId];
            const ministroDef = poolMinistros.find(m => m.id === ministroId); // Get static def for area/bonus

            if (!ministro || !ministroDef) {
                console.warn(`Dados inv√°lidos para ministro ativo ${ministroId}`);
                continue; // Skip if data is missing
            }

            const areaMinistro = ministroDef.area;
            const personalidades = ministro.personalidade || [];
            const bonus = ministro.bonus || {};
            const lealdade = ministro.lealdade || 50;
            let isRelevantArea = false; // Flag if minister's area matches dilemma type

            // --- 3. Check Area Relevance ---
            // Simple matching - could be more nuanced (e.g., Economy affects Social spending sometimes)
            if (areaMinistro === tipoDilema) {
                 isRelevantArea = true;
            }
             // Broader relevance checks (examples)
             else if (areaMinistro === 'economia' && ['social', 'infraestrutura', 'comercial'].includes(tipoDilema)) isRelevantArea = true;
             else if (areaMinistro === 'social' && ['economia', 'saude', 'educacao'].includes(tipoDilema)) isRelevantArea = true;
             else if (areaMinistro === 'defesa' && ['seguranca', 'regional_conflito', 'golpe_estado', 'diplomacia_militar'].includes(tipoDilema)) isRelevantArea = true; // Added more types
             else if (areaMinistro === 'seguranca' && ['defesa', 'regional_conflito'].includes(tipoDilema)) isRelevantArea = true;
             // Add more cross-area relevance rules


            // --- 4. Apply Modifiers if Relevant (or generally applicable) ---

            // 4a. Based on Area & Personality/Bonus (Apply mainly if relevant area)
            if (isRelevantArea) {
                console.log(` -> Ministro relevante encontrado: ${ministro.nome} (${areaMinistro}) para dilema ${tipoDilema}`);

                // --- Personality Effects ---
                if (personalidades.includes("Tecnocrata") && tipoDilema === 'economia') {
                    if (modifiedEffects.crescimentoPIB > 0) modifiedEffects.crescimentoPIB = parseFloat((modifiedEffects.crescimentoPIB * 1.05).toFixed(2)); // Small boost
                     if (modifiedEffects.custoOrcamentoImediato > 0) modifiedEffects.custoOrcamentoImediato = Math.round(modifiedEffects.custoOrcamentoImediato * 0.95); // Cost reduction
                }
                if (personalidades.includes("Populista") && tipoDilema === 'social') {
                    if (modifiedEffects.popTrabalhadores > 0) modifiedEffects.popTrabalhadores = Math.round((modifiedEffects.popTrabalhadores || 0) * 1.1); // Amplify positive
                    if (modifiedEffects.popTrabalhadores < 0) modifiedEffects.popTrabalhadores = Math.round((modifiedEffects.popTrabalhadores || 0) * 0.9); // Mitigate negative
                }
                if (personalidades.includes("Idealista") && tipoDilema === 'social') {
                     if (modifiedEffects.popProgressistas < 0) modifiedEffects.popProgressistas = Math.round((modifiedEffects.popProgressistas || 0) * 0.8); // Mitigate negative
                }
                 if (personalidades.includes("Austero") && (tipoDilema === 'defesa' || tipoDilema === 'seguranca')) {
                     if (modifiedEffects.custoOrcamentoImediato > 0) modifiedEffects.custoOrcamentoImediato = Math.round(modifiedEffects.custoOrcamentoImediato * 0.9); // 10% cost reduction
                 }
                 if (personalidades.includes("Linha Dura") && tipoDilema === 'seguranca') {
                      if (modifiedEffects.indicador_criminalidade < 0) modifiedEffects.indicador_criminalidade = Math.round((modifiedEffects.indicador_criminalidade || 0) * 1.1); // Amplify crime reduction
                 }

                // --- Specific Bonus Effects ---
                 if (bonus.custoProjetosEconomia && tipoDilema === 'economia' && modifiedEffects.custoOrcamentoImediato > 0) {
                     modifiedEffects.custoOrcamentoImediato = Math.round(modifiedEffects.custoOrcamentoImediato * (1 + bonus.custoProjetosEconomia));
                 }
                 if (bonus.popMilitares && (tipoDilema === 'defesa' || tipoDilema === 'seguranca')) {
                      modifiedEffects.popMilitares = (modifiedEffects.popMilitares || 0) + bonus.popMilitares;
                 }
                 // Add checks for all other defined bonus types (popProgressistas, crescimentoPIB_mod, etc.)
                 if (bonus.crescimentoPIB_mod && tipoDilema === 'economia') modifiedEffects.crescimentoPIB = (modifiedEffects.crescimentoPIB || 0) + bonus.crescimentoPIB_mod;
                 if (bonus.inflacao_mod && tipoDilema === 'economia') modifiedEffects.inflacao = (modifiedEffects.inflacao || 0) + bonus.inflacao_mod;


            } // End if Relevant Area

            // 4b. Based on Loyalty (Apply generally, stronger if relevant area?)
            const lealdadeFactor = (lealdade - 50) / 50; // Scale from -1 (0 loyalty) to +1 (100 loyalty)

            if (lealdade < 35 && Math.random() < 0.15) { // Chance of low loyalty causing problems
                console.warn(`Ministro ${ministro.nome} (Lealdade: ${lealdade}) pode estar sabotando...`);
                adicionarNoticia(`Rumores de que o Ministro ${ministro.nome} est√° trabalhando contra a proposta nos bastidores...`, "gabinete", "perigo");
                 // Apply small general negative effect
                 if (modifiedEffects.popGeral === undefined) modifiedEffects.popGeral = 0;
                 modifiedEffects.popGeral -= 1;
                 if (modifiedEffects.congresso_mod === undefined) modifiedEffects.congresso_mod = 0;
                 modifiedEffects.congresso_mod -= 1; // Harder to pass things
            } else if (lealdade > 70) { // High loyalty helps
                 // Slightly amplify positive effects or mitigate negative ones
                 if (modifiedEffects.popGeral > 0) modifiedEffects.popGeral = Math.round(modifiedEffects.popGeral * (1 + lealdadeFactor * 0.1)); // Up to +10% boost
                 if (modifiedEffects.popGeral < 0) modifiedEffects.popGeral = Math.round(modifiedEffects.popGeral * (1 - lealdadeFactor * 0.1)); // Up to 10% mitigation
                 // Stronger effect if relevant area?
                 if (isRelevantArea) {
                      if (modifiedEffects.congresso_mod > 0) modifiedEffects.congresso_mod = (modifiedEffects.congresso_mod || 0) + Math.round(lealdadeFactor * 2); // Help push through congress
                 }
            }

            // 4c. Corruption Risk (Doesn't usually modify effects directly, but influences event triggers elsewhere)
            // Could potentially add a small chance here for a highly corrupt minister to skim funds if effect involves budget cost/gain?
            if (personalidades.includes("Corrupt√≠vel") && ministro.riscoCorrupcao > 70 && modifiedEffects.tesouro > 0 && Math.random() < 0.05) {
                 const skimAmount = Math.round(modifiedEffects.tesouro * 0.1); // Skim 10%
                 modifiedEffects.tesouro -= skimAmount;
                 tesouro -= skimAmount; // Apply directly to state too? Or let aplicarEfeitos handle? Let aplicar handle modified value.
                 console.warn(`Ministro corrupto ${ministro.nome} desviou ${formatCurrency(skimAmount)}!`);
                 adicionarNoticia(`Fundos parecem ter desaparecido durante a implementa√ß√£o... (${ministro.nome})`, "gabinete", "perigo");
                  // Increase chance of future scandal event? Schedule one?
                  scheduleFutureEffects([{ eventoId: `escandalo_ministro_${ministroId}`, delayMin: 3, delayMax: 8, chance: 0.7 }], dilemaAtual?.id || 'corrupcao');
            }


        } // End for each minister

        // --- 5. Final Rounding & Return ---
        // Round effects after all ministers have had their influence
        for (const key in modifiedEffects) {
            if (typeof modifiedEffects[key] === 'number') {
                if (!key.includes('PIB') && !key.includes('inflacao')) {
                    modifiedEffects[key] = Math.round(modifiedEffects[key]);
                } else {
                     // Keep precision for GDP/Inflation
                     modifiedEffects[key] = parseFloat(modifiedEffects[key].toFixed(2));
                }
            }
        }

        // console.log("Efeitos ap√≥s modifica√ß√£o por ministros:", modifiedEffects); // Can be noisy
        return modifiedEffects;
    }
    
    /**
     * Modifies an effects object to simulate the outcome of a successfully
     * negotiated amendment (called only if `emendaSugerida` is true).
     * Typically lessens negative impacts and slightly reduces positive ones.
     * @param {Object} efeitos - The original effects object for the chosen option.
     * @returns {Object} - The modified effects object reflecting the amendment.
     */
     function modificarEfeitosPorEmenda(efeitos) {
        console.log("--- Modificando efeitos devido √† emenda negociada ---");
        // console.log("Efeitos Originais:", JSON.stringify(efeitos)); // Optional: Log original

        // Create a copy to avoid modifying the object passed in
        const modifiedEffects = { ...efeitos };

        // --- Define Amendment Impact ---
        // Example Strategy:
        // - Reduce negative effects significantly (e.g., by 50-60%)
        // - Reduce positive effects slightly (e.g., by 20-30%)
        // - Maybe slightly increase budget costs? (Cost of compromise)
        const negativeImpactMultiplier = 0.5; // Reduce negative effects by 50% (closer to 0)
        const positiveImpactMultiplier = 0.75; // Reduce positive effects by 25%
        const costIncreaseFactor = 1.05; // Increase immediate costs by 5%? (Optional)

        // --- Iterate and Modify Effects ---
        for (const key in modifiedEffects) {
            const value = modifiedEffects[key];

            // Only modify numerical effects
            if (typeof value === 'number' && value !== 0) {
                if (value < 0) {
                    // --- Lessen Negative Effects ---
                    // Don't modify costs this way, only negative stat hits
                    if (key !== 'tesouro' && !key.startsWith('custo') && !key.includes('ModPercent')) {
                        modifiedEffects[key] = Math.round(value * negativeImpactMultiplier);
                        // Ensure it doesn't accidentally become positive if close to zero
                        if (modifiedEffects[key] > 0) modifiedEffects[key] = 0;
                    } else if (key === 'tesouro' && value < 0) { // Negative treasury effect (cost)
                         // Optionally increase costs slightly due to compromise?
                         // modifiedEffects[key] = Math.round(value * costIncreaseFactor);
                         // Or just leave costs as they were? Leave for simplicity now.
                    }
                } else {
                    // --- Reduce Positive Effects ---
                     if (key !== 'tesouro' && !key.startsWith('custo')) { // Don't reduce potential treasury gains or cost reductions
                        modifiedEffects[key] = Math.round(value * positiveImpactMultiplier);
                     }
                }
            }
            // Keep non-numeric effects (booleans, strings, effect keys like orcamentoAreaMod) unchanged
        }

        // --- Specific Adjustment Example: Compromise Cost ---
        // If there was an initial cost, slightly increase it
        if (modifiedEffects.custoOrcamentoImediato > 0) {
            modifiedEffects.custoOrcamentoImediato = Math.round(modifiedEffects.custoOrcamentoImediato * costIncreaseFactor);
             console.log(`Custo ajustado pela emenda para: ${formatCurrency(modifiedEffects.custoOrcamentoImediato)}`);
        }

        console.log("Efeitos ap√≥s emenda:", JSON.stringify(modifiedEffects));
        return modifiedEffects;
    }
    
    /**
     * Applies the recurring, gradual effects of the allocated budget on indicators
     * and potentially population group support. Called once per round.
     * Simulates how funding levels influence health, education, crime, etc. over time.
     */
     function aplicarEfeitosOrcamentoRecorrentes() {
        // --- 1. Safety Check ---
        if (!orcamentoAlocado || !indicadoresSociaisEconomicos || !popularidadeGrupos) {
            console.warn("aplicarEfeitosOrcamentoRecorrentes: Estado de or√ßamento, indicadores ou grupos n√£o dispon√≠vel.");
            return;
        }

        console.log("Aplicando efeitos recorrentes do or√ßamento...");
        let effectsLog = []; // For debugging

        // --- 2. Define Target/Baseline Spending Levels (Crucial for Balancing!) ---
        // These represent the approximate spending per round needed to *maintain* the current indicator level (around 50-60 index)
        // Spending above the target improves the indicator, spending below degrades it.
        const targetSpending = {
            saude: 35,
            educacao: 35,
            defesa: 25, // Affects military pop? Or a hidden 'military readiness' stat?
            infraestrutura: 25, // Affects GDP growth?
            seguranca: 30, // Affects crime
            social: 25, // Affects workers/progressives? Or unemployment impact?
            cultura: 10,
            meio_ambiente: 12,
            ciencia_tecnologia: 15
        };

        // --- 3. Calculate & Apply Effects for Each Area ---
        for (const area in targetSpending) {
            const allocated = orcamentoAlocado[area] || 0; // Current spending
            const target = targetSpending[area];
            const difference = allocated - target; // How much above/below the target baseline
            const sensitivity = 0.04 + Math.random() * 0.02; // Base sensitivity + small randomness (e.g., 0.04 to 0.06)

            let effectValue = difference * sensitivity; // Calculate the raw change

            // Apply effect to the relevant indicator/stat
            switch (area) {
                case 'saude':
                    indicadoresSociaisEconomicos.saude = clamp(indicadoresSociaisEconomicos.saude + effectValue, 0, 100);
                    effectsLog.push(`Sa√∫de: ${effectValue.toFixed(2)}`);
                    break;
                case 'educacao':
                    indicadoresSociaisEconomicos.educacao = clamp(indicadoresSociaisEconomicos.educacao + effectValue, 0, 100);
                    effectsLog.push(`Educa√ß√£o: ${effectValue.toFixed(2)}`);
                    break;
                case 'infraestrutura':
                    // Infrastructure affects GDP growth more slowly? Apply smaller direct effect or use future event?
                    // Simple direct effect:
                    const gdpEffect = difference * 0.008; // Lower sensitivity for GDP impact
                    indicadoresSociaisEconomicos.crescimentoPIB += gdpEffect;
                    // Clamp GDP Growth after potential changes
                    indicadoresSociaisEconomicos.crescimentoPIB = parseFloat(clamp(indicadoresSociaisEconomicos.crescimentoPIB, -5, 10).toFixed(1));
                    effectsLog.push(`Infra->PIB: ${gdpEffect.toFixed(3)}`);
                    break;
                case 'seguranca':
                    // Higher spending DECREASES crime index
                    indicadoresSociaisEconomicos.criminalidade = clamp(indicadoresSociaisEconomicos.criminalidade - effectValue, 0, 100);
                    effectsLog.push(`Seguran√ßa->Crime: ${(-effectValue).toFixed(2)}`);
                    break;
                case 'social':
                    // Affects worker/progressive popularity? Or helps mitigate unemployment impact?
                    const workerKey = getGrupoKey('Trabalhadores');
                    const progKey = getGrupoKey('Progressistas');
                    const socialPopEffect = difference * 0.03; // Sensitivity for pop effect
                    if (popularidadeGrupos[workerKey]) popularidadeGrupos[workerKey] = clamp(popularidadeGrupos[workerKey] + socialPopEffect, 0, 100);
                    if (popularidadeGrupos[progKey]) popularidadeGrupos[progKey] = clamp(popularidadeGrupos[progKey] + socialPopEffect * 0.5, 0, 100); // Smaller effect on progressives
                    effectsLog.push(`Social->Pop: ${socialPopEffect.toFixed(2)}`);
                    // Could also affect unemployment slightly:
                    // indicadoresSociaisEconomicos.desemprego = clamp(indicadoresSociaisEconomicos.desemprego - difference * 0.01, 0, 100);
                    break;
                case 'defesa':
                    // Affects military population group support
                    const milKey = getGrupoKey('Militares');
                    const defensePopEffect = difference * 0.04;
                    if (popularidadeGrupos[milKey]) popularidadeGrupos[milKey] = clamp(popularidadeGrupos[milKey] + defensePopEffect, 0, 100);
                    effectsLog.push(`Defesa->MilPop: ${defensePopEffect.toFixed(2)}`);
                    // Could affect a hidden 'military readiness' or foreign relations later
                    break;
                case 'cultura':
                     // Affects class media / progressives slightly?
                     const cmKey = getGrupoKey('Classe M√©dia');
                     const cultPopEffect = difference * 0.02;
                     if (popularidadeGrupos[cmKey]) popularidadeGrupos[cmKey] = clamp(popularidadeGrupos[cmKey] + cultPopEffect, 0, 100);
                     if (popularidadeGrupos[progKey]) popularidadeGrupos[progKey] = clamp(popularidadeGrupos[progKey] + cultPopEffect, 0, 100);
                     effectsLog.push(`Cultura->Pop: ${cultPopEffect.toFixed(2)}`);
                     break;
                case 'meio_ambiente':
                     // Affects progressives / international relations? Or a hidden environment index?
                     // Simple effect on progressives for now
                      const envPopEffect = difference * 0.03;
                      if (popularidadeGrupos[progKey]) popularidadeGrupos[progKey] = clamp(popularidadeGrupos[progKey] + envPopEffect, 0, 100);
                      // Affect relations with Green party / certain countries?
                      const verdeId = Object.keys(partidos).find(id => partidos[id].ideologia === 'Ambientalista');
                      if (verdeId && relacoesPartidos[verdeId]) relacoesPartidos[verdeId] = clamp(relacoesPartidos[verdeId] + difference * 0.1, 0, 100);
                      effectsLog.push(`Ambiente->ProgPop: ${envPopEffect.toFixed(2)}`);
                      break;
                case 'ciencia_tecnologia':
                      // Affects GDP growth long term? Or specific events? Small immediate boost for simplicity
                      const techGdpEffect = difference * 0.006;
                      indicadoresSociaisEconomicos.crescimentoPIB += techGdpEffect;
                      indicadoresSociaisEconomicos.crescimentoPIB = parseFloat(clamp(indicadoresSociaisEconomicos.crescimentoPIB, -5, 10).toFixed(1));
                       // Boost education slightly?
                       indicadoresSociaisEconomicos.educacao = clamp(indicadoresSociaisEconomicos.educacao + difference * 0.01, 0, 100);
                       effectsLog.push(`Ci√™ncia->PIB/Edu: ${techGdpEffect.toFixed(3)}`);
                       break;
                // Add cases for other budget areas...
            }

        } // End for each area

        console.log("Efeitos recorrentes aplicados:", effectsLog.join(' | '));
        // No need to call atualizarUI here, it happens after proximoTurno completes.
    }
    
    /**
     * Schedules future events or direct effects based on an array of definitions.
     * Calculates the execution round based on delay and adds valid entries
     * to the `eventosAgendados` queue.
     * @param {Array<Object>} efeitosFuturos - An array of future effect definitions.
     *        Each object should have: { delayMin, delayMax, chance (optional, default 1.0),
     *        eventoId (optional), efeitoDireto (optional, object) }
     * @param {string} origemId - The ID of the dilemma/event that triggered these future effects (for logging/context).
     */
     function scheduleFutureEffects(efeitosFuturos, origemId) {
        // --- 1. Validation ---
        if (!Array.isArray(efeitosFuturos) || efeitosFuturos.length === 0) {
            // console.log("Nenhum efeito futuro para agendar."); // Normal, not an error
            return;
        }
        if (!origemId) {
            console.warn("scheduleFutureEffects chamado sem origemId.");
            origemId = 'desconhecida'; // Use a placeholder
        }

        console.log(`Agendando ${efeitosFuturos.length} potenciais efeitos futuros de ${origemId}...`);
        const rodadaGlobalAtual = (mandatoAtual - 1) * RODADAS_POR_MANDATO + rodada;
        let scheduledCount = 0;

        // --- 2. Iterate Through Future Effect Definitions ---
        efeitosFuturos.forEach((futuro, index) => {
            // Validate basic structure
            if (!futuro || typeof futuro.delayMin !== 'number' || typeof futuro.delayMax !== 'number' || futuro.delayMin > futuro.delayMax) {
                console.error(`Defini√ß√£o de efeito futuro inv√°lida no √≠ndice ${index} de ${origemId}:`, futuro);
                return; // Skip invalid definition
            }
            if (!futuro.eventoId && (!futuro.efeitoDireto || typeof futuro.efeitoDireto !== 'object')) {
                 console.error(`Efeito futuro inv√°lido no √≠ndice ${index} de ${origemId}: Deve ter eventoId ou efeitoDireto.`, futuro);
                 return; // Skip if neither event nor direct effect is defined
            }


            // --- 3. Check Probability ---
            const chance = futuro.chance !== undefined ? futuro.chance : 1.0; // Default to 100% if not specified
            if (chance < 1.0 && Math.random() >= chance) {
                // console.log(` - Efeito futuro ${index} (ID: ${futuro.eventoId || 'Direto'}) n√£o ocorreu (Chance: ${chance * 100}%)`);
                return; // Event didn't happen based on chance roll
            }

            // --- 4. Calculate Execution Round ---
            // Ensure delay is at least 1 round in the future
            const delayMin = Math.max(1, futuro.delayMin);
            const delayMax = Math.max(delayMin, futuro.delayMax);
            const delay = Math.floor(Math.random() * (delayMax - delayMin + 1)) + delayMin;
            const rodadaExecucao = rodadaGlobalAtual + delay;

            // --- 5. Create & Add to Queue ---
            const eventoAgendado = {
                rodadaExecucao: rodadaExecucao,
                eventoId: futuro.eventoId || null, // Store null if it's a direct effect
                efeitoDireto: futuro.efeitoDireto ? { ...futuro.efeitoDireto } : null, // Store a copy, or null
                origemId: origemId, // Track the source decision
                // Add other info if needed, like specific targets if effect is contextual
            };

            eventosAgendados.push(eventoAgendado);
            scheduledCount++;
            console.log(` - Efeito futuro agendado para rodada ${rodadaExecucao}:`, eventoAgendado);

        }); // End forEach

        console.log(`${scheduledCount} efeitos futuros foram efetivamente agendados.`);
    }

    // --- Event Handling --- (Defined before game loop)
    /**
     * Applies passive, ongoing effects that occur each round based on
     * current game state flags (e.g., pandemic) or potentially active
     * treaties/blocs with recurring effects.
     * Called once per turn, typically at the start of `proximoTurno`.
     */
    function applyOngoingEffects() {
        // --- 1. Check for Active States/Flags ---

        let ongoingEffectsToApply = {}; // Collect effects to apply once
        let activeEffectSources = []; // Track sources for logging

        // 1a. Pandemic Effects
        if (pandemiaAtiva) {
            const pandemiaDef = crises.find(c => c.id === 'crise_pandemia');
            if (pandemiaDef?.efeitoContinuo) {
                console.log("Aplicando efeitos cont√≠nuos da pandemia...");
                activeEffectSources.push("Pandemia");
                // Merge effects from definition into the collection object
                for (const key in pandemiaDef.efeitoContinuo) {
                     ongoingEffectsToApply[key] = (ongoingEffectsToApply[key] || 0) + pandemiaDef.efeitoContinuo[key];
                }
                 // Chance for pandemic to end naturally (if not ended by player action/vaccine event)
                 if (Math.random() < 0.05 && rodada > 3) { // Lower chance early on?
                     // Use setFlag effect to be handled by aplicarEfeitos
                     ongoingEffectsToApply.setFlag = "pandemia_controlada"; // Use same flag as vaccine event
                      // Note: Setting pandemiaAtiva = false directly here might cause issues if aplicarEfeitos hasn't run yet. Using a flag is safer.
                     adicionarNoticia("A pandemia parece ter perdido for√ßa naturalmente.", "sistema", "sucesso");
                 }
            }
        }

        // 1b. Treaty Recurring Effects (Revenue/Costs handled in budget cycle, apply other passive effects here)
        if (tratadosAtivos && tratadosAtivos.length > 0) {
            tratadosAtivos.forEach(tratado => {
                if (tratado.beneficios) {
                    let treatySource = `Tratado (${tratado.tipo} ${paises[tratado.paisAlvoId]?.nome || '?'})`;
                    let appliedEffect = false;
                    // Example: Passive relation gain from military treaty
                    if (tratado.beneficios.relacaoPaisAlvo && tratado.paisAlvoId) {
                         // Use specific key format
                         const key = `relacao_${tratado.paisAlvoId}`;
                         ongoingEffectsToApply[key] = (ongoingEffectsToApply[key] || 0) + tratado.beneficios.relacaoPaisAlvo;
                         appliedEffect = true;
                    }
                    // Example: Passive defense bonus from military treaty
                    if (tratado.beneficios.defesaBonus) {
                        // How to apply? Maybe temporary modifier? For now, log it.
                         // console.log(`B√¥nus de defesa passivo (+${tratado.beneficios.defesaBonus}) ativo do tratado ${tratado.id}`);
                         // Need a state variable or modifier system for this type of bonus
                          appliedEffect = true; // Even if only logged
                    }
                    // Add other passive non-budget benefits here...

                    if(appliedEffect && !activeEffectSources.includes(treatySource)) activeEffectSources.push(treatySource);
                }
                 // Decrement treaty duration (if applicable)
                 if (tratado.duracao && typeof tratado.duracao === 'number') {
                      tratado.duracao--;
                      if (tratado.duracao <= 0) {
                           // Mark for removal? Need a separate cleanup step like fake news.
                           // For now, just log expiry. Cleanup needs to be added.
                           console.log(`Tratado ${tratado.id} expirou.`);
                           adicionarNoticia(`O acordo ${tratado.tipo} com ${paises[tratado.paisAlvoId]?.nome} expirou.`, "diplomacia", "aviso");
                           // TODO: Implement removal of expired treaties
                      }
                 }
            });
             // Cleanup expired treaties (similar to fake news removal)
              let treatiesToRemove = [];
              for (let i = tratadosAtivos.length - 1; i >= 0; i--) { // Iterate backwards
                  if (tratadosAtivos[i].duracao !== undefined && tratadosAtivos[i].duracao <= 0) {
                      treatiesToRemove.push(i);
                  }
              }
              if(treatiesToRemove.length > 0) {
                   console.log(`Removendo ${treatiesToRemove.length} tratados expirados.`);
                   treatiesToRemove.forEach(index => tratadosAtivos.splice(index, 1));
              }
        }

        // 1c. Bloc Recurring Effects (Non-budget ones)
        if (blocosAtivos && Object.keys(blocosAtivos).length > 0) {
             Object.keys(blocosAtivos).forEach(blocoId => {
                  if (blocosAtivos[blocoId]?.membros?.includes("jogador")) { // Check if player is member
                       const blocoDef = blocos[blocoId];
                       if (blocoDef?.beneficios) {
                            let blocSource = `Bloco (${blocoDef.nome})`;
                            let appliedEffect = false;
                            // Example: Passive relation gain with specific major member
                            if (blocoDef.beneficios.relacao_pais_a && paises['pais_a']) { // Assuming 'pais_a' is the key
                                 ongoingEffectsToApply['relacao_pais_a'] = (ongoingEffectsToApply['relacao_pais_a'] || 0) + (blocoDef.beneficios.relacao_pais_a || 0);
                                 appliedEffect = true;
                            }
                             // Example: Passive defense bonus
                             if (blocoDef.beneficios.defesaBonus) {
                                 // console.log(`B√¥nus de defesa passivo (+${blocoDef.beneficios.defesaBonus}) ativo do bloco ${blocoDef.nome}`);
                                 appliedEffect = true;
                             }
                            // Add other passive non-budget benefits...

                            if(appliedEffect && !activeEffectSources.includes(blocSource)) activeEffectSources.push(blocSource);
                       }
                  }
             });
        }

        // 1d. Leader Skill Passive Effects (Economist?)
        if (lider.habilidades?.includes('economista_astuto')) {
             ongoingEffectsToApply.crescimentoPIB = (ongoingEffectsToApply.crescimentoPIB || 0) + 0.1;
             ongoingEffectsToApply.inflacao = (ongoingEffectsToApply.inflacao || 0) - 0.1;
              if(!activeEffectSources.includes("Habilidade Economista")) activeEffectSources.push("Habilidade Economista");
        }


        // --- 2. Apply Collected Effects ---
        if (Object.keys(ongoingEffectsToApply).length > 0) {
            console.log("Aplicando efeitos cont√≠nuos de:", activeEffectSources.join(', '));
            aplicarEfeitos(ongoingEffectsToApply);
            // Note: aplicarEfeitos handles state changes like pandemiaAtiva = false via flags
        } else {
             // console.log("Nenhum efeito cont√≠nuo a aplicar nesta rodada."); // Normal log
        }
    }
    
    /**
     * Executes scheduled events or applies direct effects from the `eventosAgendados` queue
     * that are due in the current round. Removes executed events from the queue.
     * Called once per turn, usually within `proximoTurno`.
     */
     function executarEventosAgendados() {
        // --- 1. Validation & Check Queue ---
        if (!Array.isArray(eventosAgendados) || eventosAgendados.length === 0) {
            // console.log("Nenhum evento agendado para verificar."); // Normal log
            return; // Nothing to execute
        }

        console.log(`Verificando ${eventosAgendados.length} eventos agendados...`);

        // --- 2. Get Current Global Round ---
        // Ensure consistency with how rounds are calculated when scheduling
        const rodadaGlobalAtual = (mandatoAtual - 1) * RODADAS_POR_MANDATO + rodada;
        let eventosParaRemover = []; // Store indices of events to remove after execution/cleanup
        let executedCount = 0;

        // --- 3. Iterate Through Scheduled Events (Check for Current Round) ---
        // Iterate normally first to execute in order they were added? Or doesn't matter? Normal order is fine.
        for (let i = 0; i < eventosAgendados.length; i++) {
            const evAgendado = eventosAgendados[i];

            // --- Safety Check for valid scheduled event structure ---
             if (!evAgendado || typeof evAgendado.rodadaExecucao !== 'number') {
                 console.warn(`Item inv√°lido encontrado em eventosAgendados no √≠ndice ${i}, removendo:`, evAgendado);
                 eventosParaRemover.push(i);
                 continue;
             }

            // --- Check if Due This Round ---
            if (evAgendado.rodadaExecucao === rodadaGlobalAtual) {
                console.log(`>>> Executando evento agendado (Rodada ${rodadaGlobalAtual}):`, evAgendado);
                executedCount++;

                // --- Provide Context Feedback ---
                // Try to find the original dilemma/event name for context
                const origemDilema = findDilemmaById(evAgendado.origemId);
                const origemTexto = origemDilema ? `"${truncateText(origemDilema.texto, 35)}"` : (evAgendado.origemId || "Decis√£o anterior");
                adicionarNoticia(`‚ö° Consequ√™ncia de ${origemTexto} se manifesta...`, "sistema");

                // --- Execute Event or Apply Direct Effect ---
                let triggeredSuccessfully = false;
                if (evAgendado.eventoId) {
                    // Trigger a specific named event/crisis
                    triggeredSuccessfully = dispararEventoEspecifico(evAgendado.eventoId);
                    if (!triggeredSuccessfully) {
                         console.error(`Falha ao disparar evento agendado com ID: ${evAgendado.eventoId}`);
                         // Apply a generic fallback effect?
                         aplicarEfeitos({popGeral: -1}); // Small penalty for unexpected failure
                    }
                } else if (evAgendado.efeitoDireto) {
                    // Apply direct state changes defined in the scheduled event
                    aplicarEfeitos(evAgendado.efeitoDireto);
                    adicionarNoticia("Impactos econ√¥micos/sociais/pol√≠ticos se concretizam.", "sistema"); // Generic message for direct effects
                    triggeredSuccessfully = true; // Assume direct effects always 'succeed'
                } else {
                    console.warn("Evento agendado n√£o continha eventoId nem efeitoDireto:", evAgendado);
                    // No action defined, but mark for removal
                }

                // Mark for removal after processing
                eventosParaRemover.push(i);

                // --- Check if Game Ended During Execution ---
                if (!jogoAtivo) {
                     console.log("Jogo terminado durante execu√ß√£o de evento agendado.");
                     // Need to remove executed event even if game ended? Yes.
                     // The removal loop below will still run.
                     return; // Stop processing further scheduled events if game ended
                }

            } else if (evAgendado.rodadaExecucao < rodadaGlobalAtual) {
                // --- Cleanup Overdue/Missed Events ---
                console.warn(`Evento agendado perdido encontrado (devia ser na ${evAgendado.rodadaExecucao}, atual ${rodadaGlobalAtual}), removendo:`, evAgendado);
                eventosParaRemover.push(i); // Mark overdue events for removal
            }
            // Else: Event is scheduled for the future, leave it in the queue
        } // End loop

        // --- 4. Remove Executed/Overdue Events from Queue ---
        if (eventosParaRemover.length > 0) {
            console.log(`Removendo ${eventosParaRemover.length} eventos agendados (executados ou perdidos).`);
            // Remove items by index, iterating backwards is crucial to avoid index shifting issues
            for (let i = eventosParaRemover.length - 1; i >= 0; i--) {
                eventosAgendados.splice(eventosParaRemover[i], 1);
            }
        }

        if (executedCount > 0) {
             console.log(`Execu√ß√£o de ${executedCount} eventos agendados conclu√≠da.`);
             // Potentially call atualizarUI immediately if effects were significant?
             // Usually better to let proximoTurno handle the final UI update.
        }
    }
    
    /**
     * Checks for immediate game over conditions (critically low stats, bankruptcy)
     * and also checks if the end of the current mandate has been reached.
     * Calls `gameOver` or `avaliarFimDeMandato` if conditions are met.
     * @returns {boolean} - True if the game ended or mandate evaluation started, false otherwise.
     */
     function verificarCondicoesTermino() {
        // --- 1. Safety Check ---
        if (!jogoAtivo) {
            // console.log("verificarCondicoesTermino: Jogo n√£o est√° ativo."); // Normal if called after game over
            return true; // Indicate termination check isn't needed or already happened
        }

        // console.log("Verificando condi√ß√µes de t√©rmino..."); // Can be noisy

        // --- 2. Check Immediate Game Over Conditions ---
        const popMedia = calcularPopularidadeGeral();
        const LIMITE_POP = 10; // Threshold for collapse due to unpopularity
        const LIMITE_CONG = 10; // Threshold for collapse due to lack of support
        const LIMITE_TESOURO = -1000; // Threshold for bankruptcy

        let gameOverMotivo = null;

        if (popMedia <= LIMITE_POP) {
            gameOverMotivo = `Sua popularidade geral caiu para ${popMedia}%, levando ao colapso do governo!`;
        } else if (congresso <= LIMITE_CONG) {
            gameOverMotivo = `Seu apoio no congresso despencou para ${congresso}%, resultando em impeachment ou paralisia total!`;
        } else if (tesouro <= LIMITE_TESOURO) {
            gameOverMotivo = `O pa√≠s est√° falido (Tesouro: ${formatCurrency(tesouro)})! Seu governo entrou em colapso financeiro.`;
        }
        // Add other potential instant game over conditions (e.g., failed coup resistance?)

        if (gameOverMotivo) {
            console.log("GAME OVER Condition Met:", gameOverMotivo);
            gameOver(gameOverMotivo, "Governo Colapsou"); // Call game over function
            return true; // Game ended
        }

        // --- 3. Check End of Mandate ---
        // Use >= in case a multi-round event somehow skipped the exact round number
        if (rodada >= RODADAS_POR_MANDATO) {
            console.log("Fim do mandato alcan√ßado. Iniciando avalia√ß√£o...");
            avaliarFimDeMandato(); // Call function to handle re-election or end of max terms
            // avaliarFimDeMandato will either call gameOver or set up the next mandate and call proximoTurno eventually
            return true; // Mandate evaluation process started, current turn processing effectively ends here
        }

        // --- 4. If No Conditions Met ---
        // console.log("Nenhuma condi√ß√£o de t√©rmino imediata encontrada."); // Normal log
        return false; // Game continues normally for this turn
    }
    
    /**
     * Manages the progression through campaign chapters if gameMode is 'campaign'.
     * Handles chapter intros, triggering forced events, checking end conditions,
     * and displaying chapter outros. Can pause the game for narrative display.
     * @returns {boolean} - True if the function handled the turn (e.g., showed a modal), false otherwise.
     */
     function checkCampaignProgress() {
        // --- 1. Validation ---
        if (gameMode !== 'campaign' || !campaignState || !campaignState.isActive) {
            return false; // Not in campaign mode or state missing
        }
        if (!Array.isArray(campaignChapters) || campaignChapters.length === 0) {
            console.error("checkCampaignProgress: campaignChapters array is missing or empty!");
            return false; // Cannot proceed without chapter definitions
        }

        const chapterIndex = campaignState.chapter;

        // Check if campaign is already completed
        if (chapterIndex >= campaignChapters.length) {
            // console.log("Campanha j√° conclu√≠da."); // Already finished
            campaignState.isActive = false; // Ensure flag is off
            return false;
        }

        const chapter = campaignChapters[chapterIndex];
        if (!chapter || !chapter.id) {
             console.error(`checkCampaignProgress: Defini√ß√£o inv√°lida para cap√≠tulo no √≠ndice ${chapterIndex}`);
             campaignState.isActive = false; // Stop campaign on error
             return false;
        }

        console.log(`Verificando progresso da Campanha - Cap√≠tulo ${chapterIndex}: ${chapter.title}`);

        // --- 2. Handle Chapter Start ---
        const startFlag = `chapter_${chapter.id}_started`;
        if (!campaignState.flags[startFlag]) {
            console.log(`Iniciando Cap√≠tulo ${chapterIndex}: ${chapter.title}`);
            campaignState.flags[startFlag] = true;
            let intro = chapter.introText || "";
            // Personalize intro text
            if (oponentePrincipal) intro = intro.replace("[NOME_OPONENTE]", oponentePrincipal.nome);
            // Add more personalization placeholders as needed

            mostrarModalNarrativa(chapter.title, intro); // Show intro modal
            jogoPausado = true; // Pause game until modal is closed
            console.log("Jogo pausado para introdu√ß√£o do cap√≠tulo.");
            return true; // Indicate that this function handled the turn by pausing
        }

        // --- 3. Check/Trigger Forced Events ---
        // Trigger ONE forced event per turn if conditions met
        if (Array.isArray(chapter.forcedEvents) && chapter.forcedEvents.length > 0) {
            const forcedEventId = chapter.forcedEvents.find(id => !campaignState.flags[id]); // Find first unmet forced event for this chapter

            if (forcedEventId) {
                console.log(`Tentando disparar evento for√ßado da campanha: ${forcedEventId}`);
                // Mark as attempted immediately BEFORE triggering to avoid potential loops if trigger fails
                campaignState.flags[forcedEventId] = true;

                let eventTriggered = dispararEventoEspecifico(forcedEventId); // Attempt to trigger event/crisis/dilemma

                if (eventTriggered) {
                     console.log(`Evento for√ßado ${forcedEventId} foi disparado e apresentado.`);
                     // If the event presents choices (like a dilemma/crisis), it takes over the turn.
                     // If it was a simple event with direct effects, game loop might continue,
                     // but let's assume forced events generally take the turn's main action slot.
                     return true; // Indicate event handled the turn
                } else {
                     console.warn(`Falha ao disparar evento for√ßado ${forcedEventId}. Verifique defini√ß√£o e condi√ß√µes.`);
                     // Unset flag if trigger failed? Or leave it marked as 'attempted'? Leave marked for now.
                     // campaignState.flags[forcedEventId] = false;
                }
            }
        }


        // --- 4. Check Chapter End Conditions ---
        let chapterEnded = false;
        const currentRodadaGlobal = (mandatoAtual - 1) * RODADAS_POR_MANDATO + rodada;

        if (chapter.endConditions) {
            // Check minimum round (global or chapter-specific?) - Using global here
            if (chapter.endConditions.rodadaMinGlobal && currentRodadaGlobal >= chapter.endConditions.rodadaMinGlobal) {
                chapterEnded = true;
                console.log(`Condi√ß√£o de fim de cap√≠tulo: Rodada m√≠nima ${chapter.endConditions.rodadaMinGlobal} atingida.`);
            }
            // Check if a specific flag was set (usually by resolving a forced event/crisis)
            if (!chapterEnded && chapter.endConditions.flagSet && campaignState.flags[chapter.endConditions.flagSet]) {
                chapterEnded = true;
                console.log(`Condi√ß√£o de fim de cap√≠tulo: Flag '${chapter.endConditions.flagSet}' definida.`);
            }
            // Add checks for other conditions (e.g., stat thresholds)
            if (!chapterEnded && chapter.endConditions.statCheck) {
                 // Example: { statCheck: { stat: 'popularidadeGeral', comparison: '>=', value: 70 } }
                 const check = chapter.endConditions.statCheck;
                 let currentValue;
                 if(check.stat === 'popularidadeGeral') currentValue = calcularPopularidadeGeral();
                 else if (check.stat === 'congresso') currentValue = congresso;
                 else if (check.stat === 'tesouro') currentValue = tesouro;
                 // Add other state variables...
                 if (currentValue !== undefined) {
                      if ((check.comparison === '>=' && currentValue >= check.value) ||
                          (check.comparison === '<=' && currentValue <= check.value) ||
                          (check.comparison === '==' && currentValue == check.value) ){ // Use == for flexibility? Or ===?
                           chapterEnded = true;
                           console.log(`Condi√ß√£o de fim de cap√≠tulo: Stat Check '${check.stat} ${check.comparison} ${check.value}' cumprida.`);
                      }
                 }
            }
        } else {
             // If no end conditions defined, maybe end after a fixed number of rounds? Or rely only on forced events?
             // Default: End after ~RODADAS_PER_MANDATO if no other condition hit? Risky. Needs explicit end.
             console.warn(`Cap√≠tulo ${chapterIndex} n√£o possui endConditions definidas!`);
        }


        // --- 5. Handle Chapter End ---
        if (chapterEnded) {
            console.log(`Finalizando Cap√≠tulo ${chapterIndex}: ${chapter.title}`);
            campaignState.chapter++; // Increment chapter index

            let outro = chapter.outroText || "Voc√™ superou os desafios deste per√≠odo.";
            // Personalize outro text if needed
            if (oponentePrincipal) outro = outro.replace("[NOME_OPONENTE]", oponentePrincipal.nome);

            mostrarModalNarrativa("Fim do Cap√≠tulo: " + chapter.title, outro);
            jogoPausado = true; // Pause for outro modal

            // Check if that was the last chapter
            if (campaignState.chapter >= campaignChapters.length) {
                console.log("Campanha conclu√≠da!");
                campaignState.isActive = false; // Mark campaign as inactive
                // Don't call gameOver here, let the modal closing handle the flow
                // If game should truly END after campaign, gameOver can be called in fecharModalNarrativa based on state.
                // For now, assume game continues in standard mode after campaign.
                 setTimeout(()=> { // Delay slightly after modal likely closed
                      if(!jogoAtivo) return; // Check if game ended somehow
                      adicionarNoticia("üéâ CAMPANHA CONCLU√çDA! O jogo continua em modo de simula√ß√£o padr√£o.", "sistema", "sucesso");
                      gameMode = 'standard'; // Switch back to standard mode
                      atualizarUI(); // Update UI reflecting mode change (if any UI depends on it)
                 }, 500);

            } else {
                 console.log(`Avan√ßando para Cap√≠tulo ${campaignState.chapter}`);
                 // Reset chapter-specific flags? Or keep flags global? Keep global for now.
            }
            return true; // Indicate turn was handled (paused for modal)
        }

        // --- 6. If No Action Taken ---
        return false; // Campaign didn't handle the turn, let main loop proceed
    }
    
    function verificarTriggersCrisesMaiores() { /* ... Implementation from previous answer ... */ }
    function checkCrisisTrigger(crise) { /* ... Implementation from previous answer ... */ }
    function dispararEventoAleatorio() { /* ... Implementation from previous answer ... */ }
    function dispararDesastreRegional() { /* ... Implementation from previous answer ... */ }
    function dispararCriseDiplomatica() { /* ... Implementation from previous answer ... */ }
    function dispararEventoFamiliar() { /* ... Implementation from previous answer ... */ }
    function dispararEventoEspecifico(id) { /* ... Implementation from previous answer ... */ }

    // --- DILEMMA / EVENT PRESENTATION --- (Defined before game loop)
    function getDilemaPool() { /* ... Implementation from previous answer ... */ }
    function apresentarDilema() { /* ... Implementation from previous answer ... */ }
    function apresentarCrise(criseData) { /* ... Implementation from previous answer ... */ }
    function reapresentarDilema(dilemmaData, isCrisis = false) { /* ... Implementation from previous answer ... */ }

    // --- PLAYER ACTION HANDLING --- (Defined before they can be called)
 
    function escolherOpcao(opcaoIndex) {
        // --- 1. Validation and Setup ---
        if (!dilemaAtual || !jogoAtivo || jogoPausado || eventoOrcamentoAtivo) {
            console.warn("escolherOpcao called in invalid state:", { dilema: !!dilemaAtual, ativo: jogoAtivo, pausado: jogoPausado, orcamento: eventoOrcamentoAtivo });
            return; // Don't proceed if no dilemma, not active, or paused
        }
        if (opcaoIndex < 0 || opcaoIndex >= dilemaAtual.opcoes.length) {
             console.error("Invalid option index received:", opcaoIndex, "for dilemma:", dilemaAtual.id);
             return;
        }

        console.log(`>>> Escolher Opcao START - Dilema: ${dilemaAtual.id}, Op√ß√£o Index: ${opcaoIndex}`);
        const opcao = dilemaAtual.opcoes[opcaoIndex];

        // --- 2. Double Check Conditions/Costs ---
        if ((opcao.custoOrcamentoImediato && tesouro < opcao.custoOrcamentoImediato) || (opcao.condicao && !verificarCondicao(opcao.condicao))) {
            alert("Condi√ß√µes para esta op√ß√£o n√£o s√£o mais v√°lidas! (Or√ßamento ou Requisitos)");
            console.warn("Conditions/Cost check failed for option:", opcao);
            return; // Stop if conditions aren't met
        }

        // --- 3. Apply Immediate Costs ---
        if (opcao.custoOrcamentoImediato) {
            tesouro -= opcao.custoOrcamentoImediato;
            console.log(`Custo ${formatCurrency(opcao.custoOrcamentoImediato)} aplicado. Novo tesouro: ${formatCurrency(tesouro)}`);
            // No need to update UI here yet, will happen after all effects
        }

        // --- 4. Prepare & Modify Effects ---
        let efeitosBase = { ...(opcao.efeitosImediatos || {}) }; // Clone base effects

        // 4a. Modify for Amendments
        if (emendaSugerida && dilemaAtual.podeEmendar) { // Check if amendment was attempted and possible
            console.log("Aplicando modifica√ß√µes da emenda...");
            efeitosBase = modificarEfeitosPorEmenda(efeitosBase);
        }

        // 4b. Modify by Ministers
        console.log("Aplicando modifica√ß√µes dos ministros...");
        efeitosBase = modificarEfeitosPorMinistros(efeitosBase, dilemaAtual.tipo);

        // 4c. Modify by Leader Attributes/Traits/Skills
        console.log("Aplicando modifica√ß√µes do l√≠der...");
        efeitosBase = modificarEfeitosPorLider(efeitosBase, dilemaAtual.tipo);

        console.log("Efeitos finais a serem aplicados:", efeitosBase);

        // --- 5. Apply Final Immediate Effects ---
        aplicarEfeitos(efeitosBase); // This function handles all state changes
        if (!jogoAtivo) return; // Stop immediately if applying effects ended the game (e.g., gameOver effect)

        // --- 6. Handle Special Actions Triggered by Effects ---
        if (efeitosBase.demitirMinistroAlvo && dilemaAtual.ministroAlvoId) {
            console.log("Efeito para demitir ministro alvo:", dilemaAtual.ministroAlvoId);
            demitirMinistro(dilemaAtual.ministroAlvoId, false); // false = don't open modal immediately
        }
        if (efeitosBase.demitirMinistroPasta) {
            console.log("Efeito para demitir ministro da pasta:", efeitosBase.demitirMinistroPasta);
            demitirMinistroPorPasta(efeitosBase.demitirMinistroPasta);
        }
         // Handle orcamentoAreaMod (Permanent change to allocated budget)
         if (efeitosBase.orcamentoAreaMod) {
             for (const area in efeitosBase.orcamentoAreaMod) {
                  if (orcamentoAlocado[area] !== undefined) {
                       orcamentoAlocado[area] = Math.max(0, (orcamentoAlocado[area] || 0) + efeitosBase.orcamentoAreaMod[area]);
                       console.log(`Or√ßamento para ${area} permanentemente modificado para ${formatCurrency(orcamentoAlocado[area])}`);
                  }
             }
         }
          // Handle orcamentoTotalModPercent (Permanent % change to all areas)
          if (efeitosBase.orcamentoTotalModPercent) {
               const multiplier = 1 + efeitosBase.orcamentoTotalModPercent;
               console.log(`Modificando or√ßamento total por ${efeitosBase.orcamentoTotalModPercent * 100}%`);
               for (const area in orcamentoAlocado) {
                   orcamentoAlocado[area] = Math.max(0, Math.round((orcamentoAlocado[area] || 0) * multiplier));
               }
          }
         // Handle receitaPorRodadaMod / despesaPorRodadaMod (Permanent change to fixed parts)
         // Note: We don't have these vars directly anymore. Modify budget allocations or fixed costs instead.
         // For simplicity, we'll just log a warning if these legacy keys appear.
          if (efeitosBase.receitaPorRodadaMod) console.warn("Efeito 'receitaPorRodadaMod' obsoleto - ajuste impostos ou economia.");
          if (efeitosBase.despesaPorRodadaMod) console.warn("Efeito 'despesaPorRodadaMod' obsoleto - ajuste orcamentoAlocado.");


        // --- 7. Schedule Future Effects ---
        if (opcao.efeitosFuturos) {
            scheduleFutureEffects(opcao.efeitosFuturos, dilemaAtual.id);
        }

        // --- 8. Generate Headlines ---
        gerarManchetes(dilemaAtual, opcao, efeitosBase);

        // --- 9. Update Counters for Achievements ---
        incrementAchievementCounter('aprovador_leis'); // Any decision counts
        // Check specific conditions
        if (dilemaAtual.tipo === 'gabinete' && !efeitosBase.gameOver && !efeitosBase.demitirMinistroAlvo) {
             // Survived a cabinet crisis *without* firing the target?
             checkAchievement('sobrevivente_escandalo');
        }
         // Increment diplomacy/bloc counts if treaty/bloc was joined via this decision
         // (Need specific effects like 'joinedBloco: true' or 'createdTreaty: true')
         if (efeitosBase.joinedBloco) incrementAchievementCounter('construtor_blocos');
         if (efeitosBase.createdTreaty) incrementAchievementCounter('diplomata');
         if (efeitosBase.xpGain) { // Grant direct XP from choice
              lider.experiencia += efeitosBase.xpGain;
              console.log(`Ganhou ${efeitosBase.xpGain} XP pela decis√£o.`);
              checkLevelUp(); // Check immediately
         }


        // --- 10. Recalculate Dependent Stats ---
        // Congress support might change due to relation shifts in aplicarEfeitos
        calcularApoioCongresso();

        // --- 11. Cleanup UI & State for Next Turn ---
        dilemaAtual = null; // Clear current dilemma/crisis state
        emendaSugerida = false; // Reset amendment flag
        const titleEl = document.getElementById("titulo-dilema");
        const textEl = document.getElementById("dilema-texto");
        const optionsEl = document.getElementById("painel-opcoes");
        const emendarBtn = document.getElementById("botao-emendar");

        if (titleEl) titleEl.innerText = "Processando...";
        if (textEl) textEl.innerText = "Aguarde a pr√≥xima rodada...";
        if (optionsEl) optionsEl.innerHTML = ''; // Clear buttons
        if (emendarBtn) emendarBtn.style.display = 'none'; // Hide amend button

        // --- 12. Update UI to Show Immediate Results ---
        // History is registered *inside* proximoTurno now, after all passive effects
        // Registrar history immediately after action might miss passive changes.
        // registrarHistorico(); // Maybe call here if immediate reflection on chart is desired
        atualizarUI();

        // --- 13. Trigger Next Turn ---
        console.log("<<< Escolher Opcao END - A√ß√£o processada, agendando pr√≥ximo turno.");
        setTimeout(proximoTurno, 150); // Short delay for UI render
    }





    function tentarEmendar() {
        // --- 1. Validation ---
        if (!jogoAtivo || !dilemaAtual || !dilemaAtual.podeEmendar || emendaSugerida || jogoPausado || eventoOrcamentoAtivo) {
            console.warn("Tentativa de emenda inv√°lida:", { ativo: jogoAtivo, dilema: !!dilemaAtual, pode: dilemaAtual?.podeEmendar, sugerida: emendaSugerida, pausado: jogoPausado, orcamentoEv: eventoOrcamentoAtivo });
            return; // Cannot amend if no dilemma, cannot be amended, or already tried
        }

        // --- 2. Determine Cost & Check Affordability ---
        // Cost can be dynamic based on leader skills, relations, dilemma complexity?
        // Simple fixed cost for now:
        const custoEmenda = 15; // Example cost in millions (budget)
        const chanceSucessoBase = 0.6; // Base chance the amendment has *some* effect

        // Modify chance based on Leader Strategy/Skills
        let chanceSucesso = chanceSucessoBase;
        if (lider.atributos?.estrategia) {
            chanceSucesso += (lider.atributos.estrategia - 5) * 0.03; // 3% bonus/penalty per point from 5
        }
        if (lider.habilidades?.includes('negociador_experiente')) {
            chanceSucesso += 0.15; // Flat 15% bonus for skill
        }
        chanceSucesso = clamp(chanceSucesso, 0.1, 0.9); // Clamp probability

        console.log(`Tentando emendar ${dilemaAtual.id}. Custo: ${formatCurrency(custoEmenda)}, Chance Sucesso: ${formatPercent(chanceSucesso * 100)}`);

        if (tesouro < custoEmenda) {
            alert(`Or√ßamento insuficiente (${formatCurrency(tesouro)}) para negociar uma emenda (Custo: ${formatCurrency(custoEmenda)})!`);
            return;
        }

        // --- 3. Apply Cost ---
        tesouro -= custoEmenda;
        console.log(`Custo da emenda aplicado. Novo tesouro: ${formatCurrency(tesouro)}`);

        // --- 4. Determine Outcome & Set Flag ---
        const sucesso = Math.random() < chanceSucesso;
        let feedbackMsg = "";

        if (sucesso) {
            emendaSugerida = true; // Set flag: Effects WILL be modified later
            feedbackMsg = `Voc√™ gastou ${formatCurrency(custoEmenda)} em negocia√ß√µes. Parece que conseguiu algumas concess√µes! Os efeitos da decis√£o final podem ser alterados.`;
            adicionarNoticia(feedbackMsg, "sistema", "sucesso");
            console.log("Emenda bem-sucedida (efeitos ser√£o modificados).");
        } else {
            emendaSugerida = false; // Set flag: Effects will NOT be modified
            feedbackMsg = `Voc√™ gastou ${formatCurrency(custoEmenda)}, mas as negocia√ß√µes n√£o avan√ßaram. A proposta original permanece inalterada.`;
            adicionarNoticia(feedbackMsg, "sistema", "aviso");
            console.log("Emenda falhou (efeitos n√£o ser√£o modificados).");
            // Apply small penalty for failure?
            aplicarEfeitos({ congresso_mod: -1 }); // Small hit for failed negotiation
        }

        // --- 5. UI Update ---
        const btnEmendar = document.getElementById("botao-emendar");
        if (btnEmendar) {
            btnEmendar.disabled = true; // Disable after use (success or fail)
            btnEmendar.innerText = sucesso ? "Emenda Negociada" : "Emenda Falhou";
            // Optionally hide it completely after failure?
            // if (!sucesso) btnEmendar.style.display = 'none';
        }

        // Update other relevant UI elements immediately
        atualizarPainelOrcamento(calcularReceitaAtual(), calcularDespesaAtual(), calcularReceitaAtual() - calcularDespesaAtual()); // Show budget change
        // No need to call full atualizarUI() here, let the normal flow handle it unless specific updates are critical

        // --- 6. No change to game turn ---
        // Attempting an amendment doesn't consume the main choice for the dilemma.
        // The player still needs to click Approve/Reject.
    }

    // --- Helper function called by escolherOpcao ---
    function modificarEfeitosPorEmenda(efeitos) {
        // This function applies the *result* of a successful amendment attempt
        // Simple example: Halve negative effects, reduce positive effects by 25%
        console.log("Modificando efeitos devido √† emenda...");
        const modifiedEffects = {};
        for (const key in efeitos) {
            const value = efeitos[key];
            if (typeof value === 'number') {
                if (value < 0) {
                    // Reduce negative impact (make it closer to zero)
                    modifiedEffects[key] = Math.round(value * 0.5); // Halve negative
                } else if (value > 0) {
                    // Reduce positive impact
                    modifiedEffects[key] = Math.round(value * 0.75); // Reduce positive by 25%
                } else {
                    modifiedEffects[key] = 0;
                }
            } else {
                // Keep non-numeric effects (booleans, strings, object modifications etc.)
                modifiedEffects[key] = value;
            }
        }
        console.log("Efeitos ap√≥s emenda:", modifiedEffects);
        return modifiedEffects;
    }


    function confirmarViagem(regiaoKey) {
        console.log(`Confirmando viagem para: ${regiaoKey}`);

        // --- 1. Validation (Double Check - Although UI should prevent invalid calls) ---
        if (!jogoAtivo || jogoPausado) {
             console.warn("Viagem cancelada - jogo n√£o ativo ou pausado."); return;
        }
        if (!regiaoKey || !apoioRegional[regiaoKey]) {
            console.error(`Regi√£o inv√°lida selecionada para viagem: ${regiaoKey}`);
            alert("Erro: Regi√£o inv√°lida selecionada.");
            fecharModal('modal-viagem'); // Close the selection modal
            return;
        }
        if (cooldownViagem > 0) {
            console.warn(`Tentativa de viagem durante cooldown: ${cooldownViagem} rodadas restantes.`);
            alert(`Aguarde ${cooldownViagem} rodadas para viajar novamente.`);
            fecharModal('modal-viagem');
            return;
        }
        if (tesouro < CUSTO_VIAGEM) {
            console.warn(`Or√ßamento insuficiente para viagem. Tesouro: ${tesouro}, Custo: ${CUSTO_VIAGEM}`);
            alert(`Or√ßamento insuficiente (${formatCurrency(tesouro)}) para a viagem!`);
            fecharModal('modal-viagem');
            return;
        }

        // --- 2. Close Modal & Apply Costs/Cooldown ---
        fecharModal('modal-viagem');
        tesouro -= CUSTO_VIAGEM;
        cooldownViagem = COOLDOWN_VIAGEM;
        console.log(`Viagem custou ${formatCurrency(CUSTO_VIAGEM)}. Novo tesouro: ${formatCurrency(tesouro)}. Cooldown: ${cooldownViagem}r.`);

        // --- 3. Apply Effects ---
        let efeitosViagem = {};

        // 3a. Regional Boost
        const bonusRegionalBase = BENEFICIO_VIAGEM_REGIONAL;
        // Modify bonus based on Leader Charisma?
        const carismaMod = (lider.atributos?.carisma || 5) - 5; // Points above/below 5
        const bonusRegionalFinal = clamp(bonusRegionalBase + carismaMod * 0.5, 3, 12); // Ensure bonus is reasonable
        efeitosViagem[`reg${capitalize(regiaoKey)}`] = bonusRegionalFinal; // Target specific region
        console.log(`B√¥nus regional base: ${bonusRegionalBase}, Mod Carisma: ${carismaMod*0.5}, Final: ${bonusRegionalFinal}`);

        // 3b. National Boost (apply as general popularity)
        efeitosViagem.popGeral = BENEFICIO_VIAGEM_NACIONAL;

        // 3c. Apply Effects
        aplicarEfeitos(efeitosViagem);

        // --- 4. Feedback & Achievement ---
        adicionarNoticia(`‚úàÔ∏è Viagem presidencial para ${capitalize(regiaoKey)} realizada! Apoio local e nacional aumentaram.`, "sistema", "sucesso");
        incrementAchievementCounter('viajante'); // Increment achievement counter

        // --- 5. Update UI ---
        // Full UI update happens in proximoTurno, but update budget/cooldown display immediately if needed
        // (Current atualizarUI updates these, so maybe not strictly necessary here if proximoTurno follows)
        atualizarPainelOrcamento(calcularReceitaAtual(), calcularDespesaAtual(), calcularReceitaAtual() - calcularDespesaAtual());
        // Update travel button state immediately
        const btnViagem = document.getElementById("botao-viagem");
        if (btnViagem) {
            btnViagem.disabled = true; // Disable immediately due to cooldown
            btnViagem.innerText = `Viagem (${cooldownViagem})`;
            btnViagem.title = `Aguarde ${cooldownViagem}r`;
        }

        // --- 6. Consume Turn? ---
        // Decide if travel takes the player's main action for the round.
        // Option A: Travel is INSTANT, player still faces dilemma/event THIS round. (No change needed here)
        // Option B: Travel CONSUMES the round's main action.
        /*
        if (OPTION_B) {
             console.log("Viagem consumiu a a√ß√£o principal da rodada.");
             dilemaAtual = null; // Clear any pending dilemma
             document.getElementById("titulo-dilema").innerText = "Processando...";
             document.getElementById("dilema-texto").innerText = "Voc√™ realizou uma viagem presidencial nesta rodada.";
             document.getElementById("painel-opcoes").innerHTML = '';
             document.getElementById("botao-emendar").style.display = 'none';
             setTimeout(proximoTurno, 150); // Proceed to next turn's calculations
        }
        */
        // Assuming Option A (Instant) for simplicity based on current structure.
        // If Option B is desired, uncomment and adapt the logic flow.
    }

   function iniciarViagemPresidencial() {
        // --- 1. Validation ---
        if (!jogoAtivo || jogoPausado) {
             console.warn("Tentativa de iniciar viagem com jogo inativo ou pausado."); return;
        }
        if (eventoOrcamentoAtivo) {
             alert("Voc√™ n√£o pode viajar durante a negocia√ß√£o do or√ßamento anual."); return;
        }
        if (debateAtual) {
             alert("Voc√™ n√£o pode viajar durante um debate."); return;
        }
        if (cooldownViagem > 0) {
            alert(`Aguarde ${cooldownViagem} rodadas para viajar novamente.`);
            console.log("Tentativa de viagem durante cooldown.");
            return;
        }
        if (tesouro < CUSTO_VIAGEM) {
            alert(`Or√ßamento insuficiente (${formatCurrency(tesouro)} / ${formatCurrency(CUSTO_VIAGEM)}) para a viagem!`);
            console.log("Or√ßamento insuficiente para viagem.");
            return;
        }

        console.log("Iniciando processo de Viagem Presidencial...");

        // --- 2. Prepare and Show Modal ---
        const modal = document.getElementById("modal-viagem");
        const listaRegioes = document.getElementById("lista-regioes-viagem");
        const custoDisplay = document.getElementById("viagem-custo");

        if (!modal || !listaRegioes || !custoDisplay) {
             console.error("Elementos do modal de viagem n√£o encontrados!");
             alert("Erro ao abrir a sele√ß√£o de viagem.");
             return;
        }

        custoDisplay.innerText = formatCurrency(CUSTO_VIAGEM);
        listaRegioes.innerHTML = ''; // Clear previous options

        // Populate with region buttons
        REGIOES.forEach(regiaoNome => {
            const regiaoKey = getRegiaoKey(regiaoNome); // Use helper for consistent key
            const apoioAtual = apoioRegional[regiaoKey] || 50; // Get current support

            const btn = document.createElement("button");
            btn.className = "botao info"; // Use 'info' style or similar
            btn.innerHTML = `${regiaoNome}<br><small>(Apoio: ${apoioAtual}%)</small>`; // Show current support

            // Attach listener to call confirmarViagem with the correct key
            btn.addEventListener('click', function() {
                 confirmarViagem(regiaoKey);
            });

            listaRegioes.appendChild(btn);
        });

        // Add cancel button listener (if not already handled by general modal closing)
        const cancelButton = modal.querySelector('.btn-fechar-modal'); // Assumes cancel button has this class
        if (cancelButton && !cancelButton.dataset.listenerAttached) { // Prevent adding multiple listeners
             cancelButton.addEventListener('click', () => fecharModal('modal-viagem'));
             cancelButton.dataset.listenerAttached = 'true';
        }


        modal.style.display = "block"; // Show the modal
        console.log("Modal de sele√ß√£o de viagem exibido.");

        // --- 3. No change to game turn yet ---
        // The turn proceeds only after confirmarViagem is called (or if cancelled).
    }

    // --- Core Game Loop --- (Defined relatively late, calls many others)
    function proximoTurno() {
    // --- Add Log at Start ---
    console.log(`>>> proximoTurno START - Rodada ${mandatoAtual}.${rodada + 1}`); // Log next round number

    if (!jogoAtivo || jogoPausado || eventoOrcamentoAtivo) {
        console.log(`<<< proximoTurno SKIPPED - Ativo: ${jogoAtivo}, Pausado: ${jogoPausado}, Or√ßamento: ${eventoOrcamentoAtivo}`);
        return;
    }

    try { // --- Wrap in Try-Catch ---
        rodada++;
        console.log(`--- Processando Rodada ${mandatoAtual}.${rodada} ---`); // Linha ~6568
        document.getElementById("mandatoInfo").innerText = `Mandato: ${mandatoAtual} / Rodada: ${rodada}`;
        emendaSugerida = false;

        // 0. Update Cooldowns & Ongoing Effects
        // ... (logic for cooldowns, ongoing effects) ...
        console.log("Cooldowns & ongoing effects applied.");

        // 1. Budget Cycle
        cicloOrcamentario();
        console.log("Budget cycle completed.");

        // 2. Execute Scheduled Events
        executarEventosAgendados();
        if (!jogoAtivo) { console.log("<<< proximoTurno END - Game Over during scheduled events."); return; }
        console.log("Scheduled events executed.");

        // 3. Experience Gain & Level Up Check
        // ... (logic for XP, level up) ...
        console.log("XP & Level Up checked.");

        // 4. Check Immediate Game Over / End Mandate
        if (verificarCondicoesTermino()) { console.log("<<< proximoTurno END - Termination condition met."); return; }
        console.log("Termination conditions checked.");

        // 5. Check Campaign Progression
        let campaignEventHandled = false;
        if (gameMode === 'campaign' && campaignState.isActive) {
            campaignEventHandled = checkCampaignProgress();
            if(jogoPausado) { console.log("<<< proximoTurno END - Paused by campaign."); return; }
        }
        if (campaignEventHandled || !jogoAtivo) { console.log("<<< proximoTurno END - Handled by campaign or ended."); return; }
        console.log("Campaign progress checked.");

        // 5.5 Check for Annual Budget Event
        const rodadaGlobal = (mandatoAtual - 1) * RODADAS_POR_MANDATO + rodada;
        if (!eventoOrcamentoAtivo && rodada > 0 && rodadaGlobal % RODADAS_ANO_ORCAMENTO === 1 && gameMode !== 'satire') {
            console.log("Triggering budget event.");
            iniciarEventoOrcamentoAnual();
            console.log("<<< proximoTurno END - Budget event started.");
            return;
        }
        console.log("Budget event trigger checked.");

        // 6. AI Opponent Turn
        if (rodada % AI_TURN_FREQUENCY === 0) { aiOponenteTurno(); }
        applyFakeNewsEffects();
        console.log("AI Turn & Fake News processed.");

        // 7. Trigger Major Crises
        let crisisTriggered = verificarTriggersCrisesMaiores();
        if (crisisTriggered || !jogoAtivo) { console.log("<<< proximoTurno END - Major crisis triggered or ended game."); return; }
        console.log("Major crisis triggers checked.");

        // 8. Trigger Standard Random Events / Disasters / Etc.
        let eventOcorreu = false;
        // ... (event triggering logic) ...
        console.log(`Standard event check complete. Event occurred: ${eventOcorreu}`);
        if (!jogoAtivo) { console.log("<<< proximoTurno END - Game ended during standard event."); return; }


        // 9. Present Dilemma (if needed)
        if (!dilemaAtual) { // Only present if no crisis/event already did
             apresentarDilema();
             console.log("Standard dilemma presented.");
        } else {
             console.log("Dilemma/Crisis already active, skipping standard dilemma presentation.");
        }
         if (!jogoAtivo) { console.log("<<< proximoTurno END - Game ended during dilemma presentation."); return; }


        // 10. Apply Recurrent Budget Effects & Check Achievements
        aplicarEfeitosOrcamentoRecorrentes();
        checkAllAchievements();
        console.log("Recurrent effects & achievements checked.");

        // --- Add Log Before UI Update ---
        console.log(">>> Preparing to update UI at end of proximoTurno...");
        atualizarUI();
        console.log("<<< proximoTurno END - UI Update Called.");

        // 12. Auto-Save Game
        saveGame();

    } catch (turnError) { // --- Catch errors within proximoTurno ---
        console.error("!!! CRITICAL ERROR during proximoTurno !!!", turnError);
        alert("Ocorreu um erro cr√≠tico durante o processamento do turno. Verifique o console.");
        jogoAtivo = false; // Stop the game loop
        // Optionally display an error message on the screen
        const dilemmaText = document.getElementById('dilema-texto');
        if (dilemmaText) dilemmaText.innerText = "ERRO CR√çTICO - Recarregue a p√°gina ou verifique o console.";
    }
}


    // --- END GAME / RESTART --- (Defined relatively late)
    function avaliarFimDeMandato() {
        console.log(`>>> Avaliando Fim do Mandato ${mandatoAtual} <<<`);
        jogoPausado = true; // Pause game temporarily while showing results

        const popMedia = calcularPopularidadeGeral();
        let resultado = "";
        let continuarJogo = false;
        let tituloModal = `Fim do Mandato ${mandatoAtual}`;

        adicionarNoticia(`Mandato ${mandatoAtual} conclu√≠do! Avaliando desempenho... Pop: ${popMedia}%, Cong: ${congresso}%`, "sistema");
        lider.experiencia += XP_POR_MANDATO; // Grant XP for completing mandate
        checkLevelUp(); // Check if this XP causes a level up
        checkAchievement('mandato_completo'); // Check this specific achievement

        // --- Check 1: Max Mandates Reached? ---
        if (mandatoAtual >= MAX_MANDATOS) {
            console.log("M√°ximo de mandatos atingido.");
            checkAchievement('tres_mandatos'); // Check final mandate achievement
            if (popMedia >= 60 && congresso >= 55) { // Higher requirement for "good" ending
                resultado = `üéâ PARAB√âNS! Voc√™ completou o m√°ximo de ${MAX_MANDATOS} mandatos com sucesso, alta aprova√ß√£o (${popMedia}%) e apoio no congresso (${congresso}%)! Seu nome entrou para a hist√≥ria como uma lenda pol√≠tica!`;
                tituloModal = "Legado Consolidado!";
            } else if (popMedia >= 45 && congresso >= 40) {
                 resultado = `üèÅ Voc√™ completou o m√°ximo de ${MAX_MANDATOS} mandatos. Seu governo teve altos e baixos, mas voc√™ conseguiu terminar seu tempo no poder. Seu legado √© misto (Pop: ${popMedia}%, Cong: ${congresso}%).`;
                 tituloModal = "Fim da Linha";
            } else {
                 resultado = `üìâ Voc√™ completou o m√°ximo de ${MAX_MANDATOS} mandatos, mas seu governo termina em baixa (Pop: ${popMedia}%, Cong: ${congresso}%). A hist√≥ria pode n√£o ser gentil com seu legado.`;
                 tituloModal = "Mandato Conclu√≠do com Dificuldades";
            }
            continuarJogo = false; // Game ends after max terms
        }
        // --- Check 2: Attempt Re-election ---
        else {
            console.log("Tentando reelei√ß√£o...");
            // Make re-election harder each time
            const popNecessaria = 50 + (mandatoAtual * 4); // Example: +4% pop needed per mandate
            const congNecessario = 48 + (mandatoAtual * 3); // Example: +3% cong needed per mandate

            console.log(`Requisitos para reelei√ß√£o: Pop >= ${popNecessaria}%, Cong >= ${congNecessario}%`);
            console.log(`Valores atuais: Pop = ${popMedia}%, Cong = ${congresso}%`);

            if (popMedia >= popNecessaria && congresso >= congNecessario) {
                resultado = `üó≥Ô∏è REELEITO! O povo confia em voc√™ para mais um mandato! Sua performance (Pop: ${popMedia}%, Cong: ${congresso}%) superou os requisitos (Pop: ${popNecessaria}%, Cong: ${congNecessario}%). Prepare-se para os pr√≥ximos desafios!`;
                tituloModal = "Reeleito!";
                continuarJogo = true;
                checkAchievement('reeleito'); // Check re-election achievement

                // Prepare for next mandate
                mandatoAtual++;
                rodada = 0; // Reset round counter for new term

                // Apply small difficulty increase for the new term
                console.log("Aplicando dificuldade aumentada para novo mandato...");
                for(const pid in relacoesPartidos) {
                     // Decrease relations slightly more each mandate
                     relacoesPartidos[pid] = clamp(relacoesPartidos[pid] - (3 * mandatoAtual), 0, 100);
                }
                // Small budget hit increases with mandates
                const budgetHit = 50 * mandatoAtual;
                tesouro = Math.max(0, tesouro - budgetHit); // Ensure doesn't go negative just from this
                adicionarNoticia(`Novo mandato se inicia com ${formatCurrency(budgetHit)} em custos adicionais de transi√ß√£o e rela√ß√µes partid√°rias mais tensas.`, "sistema", "aviso");

                calcularApoioCongresso(); // Recalculate congress with new relations

            } else {
                resultado = `üíî Fim da linha. Voc√™ n√£o conseguiu a reelei√ß√£o para o mandato ${mandatoAtual + 1}. Sua performance (Pop: ${popMedia}%, Cong: ${congresso}%) n√£o atingiu os requisitos (Pop: ${popNecessaria}%, Cong: ${congNecessario}%). Seu tempo no poder chegou ao fim.`;
                tituloModal = "N√£o Reeleito";
                continuarJogo = false;
            }
        }

        // --- Check Final Budget Achievement ---
        if (!continuarJogo && tesouro > 0) {
             checkAchievement('sem_divida');
        }

        // --- Show Result ---
        if (continuarJogo) {
            // Show result in narrative modal, game will resume when closed
            mostrarModalNarrativa(tituloModal, resultado);
            // Note: proximoTurno() is called by fecharModalNarrativa()
        } else {
            // Game Over - Show final result and end game state
            gameOver(resultado, tituloModal);
        }
        console.log(`<<< Avalia√ß√£o Fim do Mandato ${mandatoAtual - (continuarJogo ? 1: 0)} Conclu√≠da <<<`);
    }

function gameOver(mensagem, titulo = "Game Over") {
        console.log(`--- GAME OVER --- Triggered. T√≠tulo: ${titulo}, Mensagem: ${mensagem}`);

        // --- 1. Set Game State to Inactive ---
        jogoAtivo = false;
        jogoPausado = true; // Ensure loop stops completely

        // --- 2. Prepare Final Message & Score ---
        const finalScore = calculateScore(); // Calculate score based on final state
        const finalMessage = `${mensagem}\n\n--- Estat√≠sticas Finais ---\nPontua√ß√£o Final: ${finalScore.toLocaleString('pt-BR')}\nMandatos Completos: ${mandatoAtual - 1}\nPopularidade M√©dia: ${calcularPopularidadeGeral()}%\nApoio Congresso: ${congresso}%\nTesouro: ${formatCurrency(tesouro)}`;

        // --- 3. Update & Display End Game UI ---
        const fimTituloEl = document.getElementById("fim-titulo");
        const fimMensagemEl = document.getElementById("fim-mensagem");
        const fimJogoEl = document.getElementById("fim-jogo");
        const jogoEl = document.getElementById("jogo");

        if (fimTituloEl) fimTituloEl.innerText = titulo;
        if (fimMensagemEl) fimMensagemEl.innerText = finalMessage;

        // Hide main game area, show end game area
        if (jogoEl) jogoEl.style.display = "none";
        if (fimJogoEl) fimJogoEl.style.display = "block";

        // --- 4. Attempt to Save High Score ---
        // This function internally checks if the score qualifies and prompts the user
        saveHighScore();

        // --- 5. Clear Auto-Save ---
        try {
            localStorage.removeItem(SAVE_KEY);
            console.log("Auto-save data cleared on Game Over.");
        } catch (e) {
            console.error("Error clearing auto-save data:", e);
        }

        // --- 6. Ensure Event Listeners for End Game Buttons are Active ---
        // (These should ideally be attached once in DOMContentLoaded)
        // Re-attaching here can cause issues if not handled carefully.
        // Let's rely on the initial attachment in DOMContentLoaded.
        // If buttons don't work, the issue is likely in the initial attachment.

        console.log("Game Over sequence complete.");
    }
    function reiniciarJogo() {
        console.log("--- Reiniciando o Jogo ---");

        // --- 1. Reset ALL Game State Variables ---
        // Call the dedicated reset function
        resetGameVariables(); // This function MUST exist and reset everything listed below

        /*
        // **Manual Reset (Alternative if resetGameVariables doesn't exist)**
        // Ensure EVERY variable used by the game is reset here
        congresso = 50;
        tesouro = ORCAMENTO_INICIAL;
        popularidadeGrupos = {}; // Will be repopulated in iniciarJogo
        apoioRegional = {}; // Will be repopulated in iniciarJogo
        indicadoresSociaisEconomicos = {}; // Will be repopulated in iniciarJogo
        orcamentoAlocado = {}; // Will be repopulated in iniciarJogo
        despesasFixasPorRodada = DESPESAS_FIXAS_POR_RODADA;
        propostaOrcamento = null;
        eventoOrcamentoAtivo = false;
        liderAtual = null;
        lider = {}; // Will be repopulated in iniciarJogo
        gabinete = {}; // Will be repopulated in escolherLider/iniciarJogo
        ministrosAtivos = {};
        partidos = {}; // Will be repopulated in escolherLider
        relacoesPartidos = {}; // Will be repopulated in escolherLider
        coalizao = [];
        oponentePrincipal = null;
        popularidadeOponente = 0;
        relacoesPaises = {}; // Will be repopulated in iniciarJogo
        blocosAtivos = {};
        tratadosAtivos = [];
        rodada = 0;
        mandatoAtual = 1;
        gameMode = 'standard'; // Default back to standard? Or remember last mode? Resetting is safer.
        campaignState = { chapter: 0, flags: {}, isActive: false };
        eventosAgendados = [];
        dilemaAtual = null;
        emendaSugerida = false;
        cooldownViagem = 0;
        fakeNewsAtivas = [];
        debateAtual = null;
        pandemiaAtiva = false;
        regiaoEmRevolta = null;
        jogoAtivo = false; // Ensure game is not active
        jogoPausado = false;
        historico = {}; // Will be repopulated in iniciarJogo
        achievementsState = {}; // Will be repopulated in iniciarJogo
        localHighScores = []; // Clear loaded scores (will reload if needed)
        notificacaoTimeout = null; // Should be cleared if active
        // --- End Manual Reset ---
        */

        // --- 2. Clear UI Elements That Persist ---
        console.log("Limpando UI...");
        const listaManchetes = document.getElementById("lista-manchetes");
        if (listaManchetes) listaManchetes.innerHTML = '<li>Aguardando not√≠cias...</li>';

        const dilemaTexto = document.getElementById("dilema-texto");
        if (dilemaTexto) dilemaTexto.innerText = 'Aguardando in√≠cio...';
        const painelOpcoes = document.getElementById("painel-opcoes");
        if (painelOpcoes) painelOpcoes.innerHTML = '';

        // Clear potentially stuck modals (optional, but safer)
        const modals = document.querySelectorAll('.modal');
        modals.forEach(modal => modal.style.display = 'none');

        // Clear achievement notification
        const notificacao = document.getElementById('notificacao-conquista');
        if (notificacao) notificacao.classList.remove('show');
        if (notificacaoTimeout) clearTimeout(notificacaoTimeout);
        notificacaoTimeout = null;

        // Destroy existing Chart instance if it exists
        if (evolucaoChart) {
            evolucaoChart.destroy();
            evolucaoChart = null;
            console.log("Chart destru√≠do.");
        }
        // Clear any specific chart data display if necessary

        // Remove satire mode class if present
        document.body.classList.remove('satire-mode');

        // --- 3. Clear Persistent Storage (Optional but recommended on explicit restart) ---
        try {
            localStorage.removeItem(SAVE_KEY); // Remove auto-save from previous game
            console.log("Auto-save limpo.");
        } catch (e) {
             console.error("Erro ao limpar auto-save:", e);
        }

        // --- 4. Reset UI View to Initial State ---
        console.log("Redefinindo exibi√ß√£o da UI...");
        const screensToHide = ['tela-modo-jogo', 'inicio', 'ministros-inicial', 'jogo', 'fim-jogo'];
        screensToHide.forEach(id => {
            const el = document.getElementById(id);
            if (el) el.style.display = 'none';
        });
        // Show the very first screen (Initial Buttons or Mode Selection?)
        const initialButtonsScreen = document.getElementById('tela-inicial-botoes');
        if (initialButtonsScreen) {
             initialButtonsScreen.style.display = 'block';
              // Re-check if continue button should be shown (it shouldn't after clearing save)
              const continueBtn = document.getElementById('btn-continuar-jogo');
              if (continueBtn) continueBtn.style.display = 'none';
        } else {
             console.error("CRITICAL: #tela-inicial-botoes not found during restart! Cannot show initial screen.");
             alert("Erro cr√≠tico ao reiniciar. Recarregue a p√°gina.");
        }

        console.log("--- Jogo Reiniciado ---");
    }

    // --- Make sure resetGameVariables is defined ---
    // (Copied/Adapted from previous implementation)
    function resetGameVariables() {
        console.log("Resetando vari√°veis de estado do jogo...");
        congresso = 50; tesouro = ORCAMENTO_INICIAL; popularidadeGrupos = {}; apoioRegional = {}; indicadoresSociaisEconomicos = {};
        orcamentoAlocado = {}; despesasFixasPorRodada = DESPESAS_FIXAS_POR_RODADA; propostaOrcamento = null; eventoOrcamentoAtivo = false;
        liderAtual = null; lider = {}; gabinete = {}; ministrosAtivos = {}; partidos = {}; relacoesPartidos = {}; coalizao = [];
        oponentePrincipal = null; popularidadeOponente = 0; relacoesPaises = {}; blocosAtivos = {}; tratadosAtivos = [];
        rodada = 0; mandatoAtual = 1; gameMode = 'standard'; campaignState = { chapter: 0, flags: {}, isActive: false };
        eventosAgendados = []; dilemaAtual = null; emendaSugerida = false; cooldownViagem = 0; fakeNewsAtivas = []; debateAtual = null;
        pandemiaAtiva = false; regiaoEmRevolta = null; jogoAtivo = false;
        jogoPausado = false; historico = {}; achievementsState = {}; localHighScores = [];
        if (notificacaoTimeout) { clearTimeout(notificacaoTimeout); notificacaoTimeout = null; }
        // Don't destroy chart here, handled in reiniciarJogo UI cleanup
        console.log("Vari√°veis resetadas.");
    }

    // --- Initialization (`iniciarJogo`, etc.) --- (Defined after helpers)
    // Moved setupChart definition here, before it's called in init/load
    function setupChart() {
        const ctx = document.getElementById('evolucaoChart');
        if (!ctx) { console.error("Canvas element not found for chart."); return; }
        const context = ctx.getContext('2d');
        if (evolucaoChart) { evolucaoChart.destroy(); } // Destroy previous chart

        const datasets = [
            { label: 'Congresso', data: historico?.congresso || [], borderColor: 'gold', tension: 0.1, fill: false, yAxisID: 'ySupport' },
            { label: 'Pop: Trab.', data: historico?.popularidadeGrupos?.[getGrupoKey("Trabalhadores")] || [], borderColor: 'lightcoral', tension: 0.1, fill: false, hidden: false, yAxisID: 'ySupport' },
            { label: 'Pop: Emp.', data: historico?.popularidadeGrupos?.[getGrupoKey("Empres√°rios")] || [], borderColor: 'lightblue', tension: 0.1, fill: false, hidden: false, yAxisID: 'ySupport' },
            { label: 'Tesouro (M)', data: historico?.tesouro || [], borderColor: 'lightgreen', tension: 0.1, fill: false, hidden: false, yAxisID: 'yBudget' },
            { label: 'Infla√ß√£o (%)', data: historico?.indicadores?.inflacao || [], borderColor: '#ff6384', tension: 0.1, fill: false, hidden: true, yAxisID: 'yPercent' },
            { label: 'Desemprego (%)', data: historico?.indicadores?.desemprego || [], borderColor: '#ff9f40', tension: 0.1, fill: false, hidden: true, yAxisID: 'yPercent' },
            { label: 'Cresc. PIB (%)', data: historico?.indicadores?.crescimentoPIB || [], borderColor: '#4bc0c0', tension: 0.1, fill: false, hidden: true, yAxisID: 'yPercent' },
        ];

        evolucaoChart = new Chart(context, {
            type: 'line', data: { labels: historico?.rodadas || [], datasets: datasets },
            options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: 'top', labels: { color: '#fff' } }, title: { display: true, text: 'Evolu√ß√£o do Mandato', color: '#fff' } },
                scales: { x: { ticks: { color: '#ccc' }, grid: { color: '#555' } }, ySupport: { type: 'linear', position: 'left', ticks: { color: '#ccc' }, grid: { color: '#555' }, min: 0, max: 100, title: { display: true, text: 'Apoio (%)', color: '#fff'} }, yPercent: { type: 'linear', position: 'right', ticks: { color: '#ccc' }, grid: { drawOnChartArea: false }, title: { display: true, text: 'Indicador (%)', color: '#fff'} }, yBudget: { type: 'linear', position: 'right', ticks: { color: '#ccc', callback: function(value) { return 'R$'+value+'M'; } }, grid: { drawOnChartArea: false }, title: { display: true, text: 'Tesouro (M)', color: '#fff'} } }
            }
        });
        if (historico?.rodadas?.length > 0) { evolucaoChart.update(); }
    }
    // Functions called during setup
    function mostrarSelecaoModo() { const el1 = document.getElementById('tela-inicial-botoes'); if(el1) el1.style.display = 'none'; const el2 = document.getElementById('tela-modo-jogo'); if(el2) el2.style.display = 'block'; }

    function selecionarModoJogo(modo) {
     console.log("Modo selecionado:", modo); // <-- Check if this logs
     gameMode = modo;
     if (gameMode === 'campaign') {
         campaignState = { chapter: 0, flags: {}, isActive: true };
         console.log("Campaign state initialized.");
     } else {
         campaignState = { chapter: 0, flags: {}, isActive: false };
     }
     if (gameMode === 'satire') {
          document.body.classList.add('satire-mode');
          console.log("Satire mode class added.");
     } else {
          document.body.classList.remove('satire-mode');
     }

     // --- The Problem is Likely Here ---
     const elModo = document.getElementById('tela-modo-jogo');
     const elInicio = document.getElementById('inicio');

     if (elModo) {
         elModo.style.display = 'none';
          console.log("#tela-modo-jogo hidden.");
     } else {
         console.error("#tela-modo-jogo not found in selecionarModoJogo!"); // Add error check
     }

     if (elInicio) {
         elInicio.style.display = 'block';
          console.log("#inicio shown.");
     } else {
         console.error("#inicio not found in selecionarModoJogo!"); // Add error check
     } 
    }



    function escolherLider(tipo) {
     console.log("L√≠der escolhido:", tipo); // <-- Check if this logs

     // --- Logic for setting up party/relations ---
     partidos = JSON.parse(JSON.stringify(partidosBase));
     const basePartidoId = `partido_${tipo.toLowerCase().replace('-', '_')}`;
     if (!partidos[basePartidoId]) {
         partidos[basePartidoId] = { nome: `Partido ${tipo}`, ideologia: tipo, forcaBaseCongresso: 20, relacaoInicial: {} };
     }
     partidos[basePartidoId].nome += " (Seu)";
     liderAtual = { tipo: tipo, partidoId: basePartidoId };
     relacoesPartidos = {};
     for (const pid1 in partidos) {
         if(pid1 === liderAtual.partidoId) continue;
         let initialRelation = 50;
         const otherPartyDef = partidosBase[pid1];
         if(otherPartyDef && otherPartyDef.relacaoInicial) {
             initialRelation = otherPartyDef.relacaoInicial[liderAtual.partidoId] ?? otherPartyDef.relacaoInicial[liderAtual.tipo] ?? 50;
         }
         relacoesPartidos[pid1] = clamp(initialRelation, 0, 100);
     }
     // --- End Party Logic ---

     gabinete = {}; // <-- ADD THIS LINE TO ENSURE IT'S AN OBJECT
     console.log("Gabinete object initialized.");

     // --- UI Update and Transition ---
     const elTipoLider = document.getElementById("tipoLider");
     const elInicio = document.getElementById("inicio");
     const elMinistros = document.getElementById("ministros-inicial");

     if (elTipoLider) { // Update the leader display in the main game area (even though it's hidden)
          elTipoLider.innerText = `L√≠der: ${tipo} (${partidos[liderAtual.partidoId].nome})`;
          console.log("Leader type display updated.");
     } else {
         console.error("#tipoLider element not found in escolherLider!");
     }

     if (elInicio) {
         elInicio.style.display = "none";
          console.log("#inicio hidden.");
     } else {
         console.error("#inicio not found in escolherLider!"); // Add error check
     }

     // Call function to populate minister choices
     prepararEscolhaMinistros(); // Make sure this function exists and runs without errors

     if (elMinistros) {
         elMinistros.style.display = "block";
          console.log("#ministros-inicial shown.");
     } else {
         console.error("#ministros-inicial not found in escolherLider!"); // Add error check
     }
     // --- End UI Transition ---
 }




 function prepararEscolhaMinistros() {
        const container = document.getElementById("escolha-ministros-container");
        // --- Check 1: Does the container exist? ---
        if (!container) {
            console.error("CRITICAL: #escolha-ministros-container not found! Cannot prepare minister selection.");
            alert("Erro cr√≠tico: N√£o foi poss√≠vel exibir a sele√ß√£o de ministros.");
            return; // Stop if container is missing
        }
        console.log("Container #escolha-ministros-container found. Clearing and preparing...");
        container.innerHTML = ''; // Clear previous content

        const areas = ["economia", "social", "defesa"]; // Core areas

        areas.forEach(area => {
            console.log("Preparing area:", area); // <-- Log for each area
            const div = document.createElement("div");
            div.className = 'ministro-escolha modal-section'; // Using modal-section style
            div.innerHTML = `<h4 style="margin-bottom: 5px; text-align: center;">${capitalize(area)}:</h4>`;

            // --- Check 2: Filtering candidates ---
            const candidatos = poolMinistros.filter(m => m.area === area);
            console.log(`Found ${candidatos.length} candidates for ${area}.`); // <-- Log candidate count

            if (candidatos.length === 0) {
                div.innerHTML += '<p>Nenhum candidato dispon√≠vel!</p>';
            } else {
                const optionsDiv = document.createElement("div");
                optionsDiv.className = 'painel-escolhas'; // Buttons in flex row

                // --- Check 3: Button creation loop ---
                candidatos.slice(0, 3).forEach(candidato => { // Show limited options initially
                     try { // Add try-catch around button creation
                        console.log(`Creating button for ${candidato.nome} in ${area}`); // <-- Log button creation
                        const button = document.createElement("button");
                        button.className = 'botao';
                        const partidoNome = partidos[candidato.partidoId]?.nome?.replace(" (Seu)", "") || 'Ind.';
                        button.innerHTML = `${candidato.nome}<br><small>(${partidoNome} - ${candidato.personalidade[0]})</small>`;
                        // Add data attributes for listener
                        button.dataset.area = area;
                        button.dataset.ministroId = candidato.id;
                        // Attach listener directly here
                        button.addEventListener('click', function() {
                            selecionarMinistroInicial(this.dataset.area, this.dataset.ministroId);
                        });
                        optionsDiv.appendChild(button);
                     } catch (buttonError) {
                         console.error(`Error creating button for ${candidato?.nome || 'UNKNOWN'} in ${area}:`, buttonError); // <-- Log errors inside loop
                     }
                }); // End forEach candidate
                div.appendChild(optionsDiv);
            } // End if candidates found
            container.appendChild(div);
            console.log(`Finished preparing area: ${area}`); // <-- Log after adding area div
        }); // End forEach area

        console.log("Finished preparing all minister choices.");
    }


    function selecionarMinistroInicial(area, ministroId) {
     // --- Add Log HERE ---
     console.log(`Attempting to select minister: Area=${area}, ID=${ministroId}`);

     if (!area || !ministroId) {
          console.error("selecionarMinistroInicial called with invalid parameters:", area, ministroId);
          return;
     }

     gabinete[area] = ministroId; // Store the selected minister ID
     console.log("Gabinete state updated:", gabinete); // Log the updated cabinet

     // --- Check Visual Feedback Logic ---
     try { // Add try-catch for safety
         const allButtonsInArea = document.querySelectorAll(`.ministro-escolha button[data-area="${area}"]`);
         console.log(`Found ${allButtonsInArea.length} buttons for area ${area} to update style.`); // Check if buttons are found

         allButtonsInArea.forEach(btn => {
             const isSelected = (btn.dataset.ministroId === ministroId);
             btn.style.backgroundColor = isSelected ? '#265ecf' : '#3a86ff'; // Highlight/Reset
             btn.style.fontWeight = isSelected ? 'bold' : 'normal';
             btn.disabled = isSelected; // Disable the selected one, enable others in the same area
              // console.log(`Button ${btn.dataset.ministroId} - Selected: ${isSelected}, Disabled: ${btn.disabled}`); // Verbose logging if needed
         });
          console.log(`Visual feedback applied for area ${area}.`);
     } catch (styleError) {
         console.error(`Error applying visual feedback in selecionarMinistroInicial for area ${area}:`, styleError);
     }
     // --- End Visual Feedback Logic ---

      // Check if all required ministers are now selected (needed for iniciarJogo validation)
      const allSelected = gabinete.economia && gabinete.social && gabinete.defesa;
      console.log("All required ministers selected:", allSelected);
      // Optionally enable the 'Iniciar Mandato' button here if all selected?
      // const startButton = document.querySelector('#ministros-inicial .botao.sucesso');
      // if (startButton) startButton.disabled = !allSelected;
 }




 function iniciarJogo() {
        console.log("--- Iniciar Jogo Button Clicked ---");
        // ... (valida√ß√£o inicial) ...
        if (!gabinete.economia || !gabinete.social || !gabinete.defesa) { /* ... validation fail ... */ return; }
        console.log("Validation passed. Proceeding to initialize game state...");

        try {
            jogoAtivo = true;
            mandatoAtual = 1;
            rodada = 0;

            // --- Initialize ALL state variables ---
            console.log("Initializing achievements...");
            initializeAchievements();

            console.log("Initializing core stats...");
            // --- FIX: Inicializa√ß√µes que precisam estar aqui ---
            popularidadeGrupos = {};
            GRUPOS_POPULACAO.forEach(g => popularidadeGrupos[getGrupoKey(g)] = 50);
            apoioRegional = {};
            REGIOES.forEach(r => apoioRegional[getRegiaoKey(r)] = 50);
            indicadoresSociaisEconomicos = {};
            indicadoresSociaisEconomicos = { inflacao: 5.0, desemprego: 8.0, criminalidade: 60, educacao: 55, saude: 60, dividaPublica: 45, crescimentoPIB: 1.5 };
            tesouro = ORCAMENTO_INICIAL;
            orcamentoAlocado = {};
            const initialAlloc = Math.round(150 / AREAS_ORCAMENTO.length);
            AREAS_ORCAMENTO.forEach(area => { orcamentoAlocado[area] = initialAlloc; });
            despesasFixasPorRodada = DESPESAS_FIXAS_POR_RODADA;
            propostaOrcamento = null; eventoOrcamentoAtivo = false;

            // --- REMOVA ESTAS LINHAS ---
            // partidos = {}; // <--- REMOVER
            // relacoesPartidos = {}; // <--- REMOVER
            // --- FIM DAS LINHAS REMOVIDAS ---

            coalizao = []; // Inicializa coaliz√£o vazia (pode ser preenchida depois)
            relacoesPaises = {};
            blocosAtivos = {};
            tratadosAtivos = [];
            eventosAgendados = [];
            fakeNewsAtivas = [];

            console.log("Initializing leader state...");
            initializeLeaderState(); // Assumes liderAtual is set correctly

            console.log("Initializing active ministers...");
            ministrosAtivos = {}; // Garante que est√° limpo antes de popular
            for (const area in gabinete) { initializeMinistroAtivo(gabinete[area]); }

            console.log("Initializing politics...");
            // A coaliz√£o inicial geralmente inclui apenas o partido do l√≠der
            if (liderAtual && liderAtual.partidoId) {
                 coalizao = [liderAtual.partidoId];
            }
            oponentePrincipal = selectOpponent(); // Agora deve funcionar pois 'partidos' est√° correto
            popularidadeOponente = oponentePrincipal?.popularidadeBase || 0;

            console.log("Initializing foreign relations...");
            initializeForeignRelations();

            console.log("Initializing event/narrative state...");
            dilemaAtual = null; emendaSugerida = false;
            cooldownViagem = 0; debateAtual = null;
            pandemiaAtiva = false; regiaoEmRevolta = null;
            if (gameMode === 'campaign') campaignState = { chapter: 0, flags: {}, isActive: true };
            else campaignState = { chapter: 0, flags: {}, isActive: false };

            console.log("Initializing history...");
            historico = {};
            historico = { rodadas: [], congresso: [], tesouro: [], liderNivel: [],
                popularidadeGrupos: Object.keys(popularidadeGrupos).reduce((acc, key) => { acc[key] = []; return acc; }, {}),
                indicadores: Object.keys(indicadoresSociaisEconomicos).reduce((acc, key) => { acc[key] = []; return acc; }, {}) };

            console.log("Setting up chart...");
            setupChart();

            // --- Switch UI ---
            document.getElementById("ministros-inicial").style.display = "none";
            document.getElementById("jogo").style.display = "block";
            document.getElementById("fim-jogo").style.display = "none";


            adicionarNoticia("Mandato iniciado! Boa sorte, Presidente!", "sistema");
            console.log("Calculating initial congress support...");
            calcularApoioCongresso(); // Agora deve calcular corretamente com dados dos partidos

            console.log("Starting first turn...");
            proximoTurno();

            console.log("--- iniciarJogo finished ---");

        } catch (initError) {
             console.error("CRITICAL ERROR during iniciarJogo:", initError);
             alert("Ocorreu um erro cr√≠tico ao iniciar o jogo. Verifique o console.");
             jogoAtivo = false;
        }
    }




    // --- `DOMContentLoaded` --- (Defined LAST, attaches initial listeners)
    document.addEventListener('DOMContentLoaded', function() {
        console.log("DOM Loaded. Initializing...");
        try {
            // Check for save game
            const continueBtn = document.getElementById('btn-continuar-jogo');
            if (localStorage.getItem(SAVE_KEY)) {
                if (continueBtn) continueBtn.style.display = 'inline-block';
                else console.warn("#btn-continuar-jogo not found for showing.");
                console.log("Save data found.");
            } else {
                 if (continueBtn) continueBtn.style.display = 'none';
                 else console.warn("#btn-continuar-jogo not found for hiding.");
                 console.log("No save data found.");
            }
        } catch (e) {
            console.error("Error accessing localStorage on load:", e);
            const btn = document.getElementById('btn-continuar-jogo');
            if (btn) btn.style.display = 'none';
        }

        // Hide screens safely
        const screensToHide = ['tela-modo-jogo', 'inicio', 'ministros-inicial', 'jogo', 'fim-jogo'];
        screensToHide.forEach(id => {
            const el = document.getElementById(id);
            if (el) el.style.display = 'none';
            // else console.warn(`Element with ID ${id} not found during initial hide.`); // Reduce console noise unless debugging
        });

        // Show initial buttons screen safely
        const initialButtonsScreen = document.getElementById('tela-inicial-botoes');
        if (initialButtonsScreen) {
            initialButtonsScreen.style.display = 'block';
        } else {
            console.error("CRITICAL: Element #tela-inicial-botoes not found! Cannot start game.");
            alert("Erro cr√≠tico: Tela inicial n√£o encontrada.");
            return; // Stop further execution if essential element is missing
        }

        // --- Attach Event Listeners ---
        console.log("Attaching event listeners...");
        try {
            // Safely attach listeners only if elements exist
            const continueBtn = document.getElementById('btn-continuar-jogo');
            if (continueBtn) continueBtn.addEventListener('click', loadGameWrapper);

            const newGameBtn = document.getElementById('btn-novo-jogo');
            if (newGameBtn) newGameBtn.addEventListener('click', mostrarSelecaoModo);
            else console.error("#btn-novo-jogo not found!");


            const modeButtons = document.querySelectorAll('#tela-modo-jogo .botao');
     if (modeButtons.length > 0) {
         modeButtons.forEach(button => {
             button.addEventListener('click', function() {
                 // Determine mode based on button text
                 const mode = this.textContent.includes('Padr√£o') ? 'standard'
                            : this.textContent.includes('Campanha') ? 'campaign'
                            : this.textContent.includes('S√°tira') ? 'satire' // Check spelling "S√°tira" vs "Satire"
                            : null; // Fallback

                 console.log("Mode button clicked, detected mode:", mode); // Add log HERE

                 if (mode && typeof selecionarModoJogo === 'function') {
                      selecionarModoJogo(mode);
                 } else if (!mode) {
                      console.error("Could not determine game mode from button text:", this.textContent);
                      alert("Erro ao selecionar modo.");
                 } else {
                      console.error('selecionarModoJogo function not defined (within listener)');
                      alert('Erro interno [MD_FNF]. Verifique o console.');
                 }
             });
         });
     } else console.warn("#tela-modo-jogo buttons not found.");


     const leaderButtons = document.querySelectorAll('#inicio .botao');
      if (leaderButtons.length > 0) {
           leaderButtons.forEach(button => {
               button.addEventListener('click', function() {
                   // Map button text content to the type expected by a function
                   const leaderTypeMap = {
                       'Centro-Esquerda': 'CentroEsquerda', // Ensure these match button text EXACTLY
                       'Liberal': 'Liberal',
                       'Conservador': 'Conservador',
                       'Populista': 'Populista'
                   };
                   const leaderType = leaderTypeMap[this.textContent]; // Get type from button text

                   console.log("Leader button clicked, detected type:", leaderType); // Add log HERE

                   if (leaderType && typeof escolherLider === 'function') {
                        escolherLider(leaderType);
                   } else if (!leaderType) {
                        console.error('Could not map button text to leader type:', this.textContent);
                        alert("Erro ao selecionar tipo de l√≠der.");
                   } else {
                        console.error('escolherLider function not defined (within listener)');
                        alert('Erro interno [LDR_FNF_2]. Verifique o console.');
                   }
               });
           });
       } else console.warn("#inicio buttons not found.");


               const startGameButton = document.querySelector('#ministros-inicial .botao.sucesso');
    if (startGameButton) {
                // No need to remove onclick if we aren't using it in HTML
                startGameButton.addEventListener('click', iniciarJogo);
        console.log("Listener attached to Start Game button."); // <-- Add log
    } else console.warn("#ministros-inicial start button not found."); //

            // --- Attach other listeners safely ---
            const btnSave = document.querySelector('#jogo .botao.info[onclick*="saveGame"]'); if(btnSave) btnSave.addEventListener('click', saveGame);
            const btnAchieve = document.querySelector('#jogo .botao.aviso[onclick*="mostrarModalConquistas"]'); if(btnAchieve) btnAchieve.addEventListener('click', mostrarModalConquistas);
            const btnEmendar = document.getElementById('botao-emendar'); if(btnEmendar) btnEmendar.addEventListener('click', tentarEmendar);
            const btnViagem = document.getElementById('botao-viagem'); if(btnViagem) btnViagem.addEventListener('click', iniciarViagemPresidencial);
            const btnOrcamento = document.getElementById('botao-orcamento'); if(btnOrcamento) btnOrcamento.addEventListener('click', iniciarEventoOrcamentoAnual);
            const btnGabinete = document.getElementById('botao-gabinete'); if(btnGabinete) btnGabinete.addEventListener('click', mostrarModalGabinete);
            const btnPartidos = document.getElementById('botao-partidos'); if(btnPartidos) btnPartidos.addEventListener('click', mostrarModalPartidos);
            const btnDiplomacia = document.querySelector('#painel-mundo .botao'); if(btnDiplomacia) btnDiplomacia.addEventListener('click', mostrarModalDiplomacia);

            document.querySelectorAll('.modal .close-button').forEach(btn => { btn.addEventListener('click', function() { const modal = this.closest('.modal'); if(modal) fecharModal(modal.id); }); });
            // Note: The querySelectorAll for '.modal button[onclick*="fecharModal"]' might be redundant if close buttons handle all closures.

            const btnNomear = document.querySelector('#modal-gabinete .botao.info'); if(btnNomear) btnNomear.addEventListener('click', iniciarNomeacao);

            const btnRestart = document.querySelector('#fim-jogo .botao.sucesso'); if(btnRestart) btnRestart.addEventListener('click', reiniciarJogo);
            const btnPDF = document.querySelector('#fim-jogo .botao.info'); if(btnPDF) btnPDF.addEventListener('click', generatePDFReport);
            const btnHS = document.querySelector('#fim-jogo .botao:not(.sucesso):not(.info)'); if(btnHS) btnHS.addEventListener('click', mostrarModalHighScores);


            console.log("Event listeners attached.");
        } catch(e) { console.error("Error attaching event listeners:", e); alert("Erro cr√≠tico ao inicializar os bot√µes. Recarregue a p√°gina ou verifique o console."); }
    }); // End DOMContentLoaded listener

    console.log("End of script execution. Type of escolherLider:", typeof escolherLider); // Final check

</script>










    </script>

</body>
</html>
