<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Confirmação de Disponibilidade</title>
  <style>
  /* --- CSS Completo (Ajustes Mobile - 100% Largura Ecrã) --- */
  /* --- CSS Completo (Desktop + Ajustes Mobile) --- */
  * { box-sizing: border-box; }

  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    margin: 0;
    padding: 0;
    background: linear-gradient(to right, #e0eafc, #cfdef3);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding-bottom: 40px;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    text-rendering: optimizeLegibility;
  }

  header {
    background: #2d89ef;
    color: white;
    width: 100%;
    padding: 20px 0;
    text-align: center;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  }
  h1 { margin: 0; font-size: 2em; font-weight: 600; }

  #selecao-container, #cards-container {
    margin-top: 40px;
    width: 100%;
    max-width: 900px; /* Adjusted for consistency */
    padding: 0 20px;
    display: flex;
    flex-direction: column;
    align-items: center; /* Center items in selecao-container */
  }
  #cards-container { align-items: stretch; } /* Keep cards stretching */

  #selecao-container h2 {
    color: #333;
    margin-bottom: 15px;
    text-align: center; /* Center heading */
    width: 100%;
  }

  /* --- Input + Suggestions Styles --- */
  .nome-input-wrapper {
    position: relative; /* Needed for positioning suggestions */
    width: 100%;
    max-width: 350px; /* Match old select width */
    margin-bottom: 20px;
  }

  input#nomeInput {
    padding: 12px 15px;
    border-radius: 8px;
    border: 1px solid #ccc;
    font-size: 1em;
    width: 100%;
    background-color: white;
    cursor: pointer; /* Indicate it's clickable */
    /* Remove default appearance */
    appearance: none;
    -webkit-appearance: none;
    -moz-appearance: none;
  }

  input#nomeInput:disabled {
    background-color: #e9ecef;
    cursor: not-allowed;
    opacity: 0.7;
  }

  input#nomeInput::placeholder {
      color: #999;
  }

  .suggestions-list {
    position: absolute;
    top: 100%; /* Position below input */
    left: 0;
    right: 0;
    background-color: white;
    border: 1px solid #ccc;
    border-top: none; /* Avoid double border */
    border-radius: 0 0 8px 8px;
    max-height: 200px; /* Limit height */
    overflow-y: auto; /* Add scroll if needed */
    z-index: 10; /* Ensure it's above other content */
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
  }

  .suggestion-item {
    padding: 10px 15px;
    font-size: 1em;
    cursor: pointer;
    transition: background-color 0.15s ease;
  }

  .suggestion-item:hover,
  .suggestion-item.active { /* For potential keyboard nav */
    background-color: #f0f0f0;
  }
  /* --- End Input Styles --- */

  .grupo-semana {
    margin-bottom: 40px;
    width: 100%;
  }
  .semana-titulo {
    font-size: 1.2em;
    font-weight: 600;
    margin-bottom: 20px;
    color: #1a4a7a;
    border-bottom: 2px solid #a0c4f0;
    padding-bottom: 8px;
    text-align: left;
  }

  .cards-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 25px;
  }

  .dia-agrupado {
    display: flex;
    flex-wrap: nowrap;
    gap: 15px;
    width: 100%;
  }

  .dia-agrupado > .card {
    flex: 1 1 auto;
    min-width: 0;
    width: auto;
    margin: 0;
    padding: 15px;
    box-shadow: 0 4px 10px rgba(45, 137, 239, 0.1);
    background: white;
    border-radius: 16px;
    border: 2px solid transparent;
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
    transition: transform 0.25s ease, box-shadow 0.25s ease, background-color 0.3s ease, border-color 0.3s ease, opacity 0.3s ease; /* Added transitions */
  }
  .dia-agrupado > .card .dia-semana {
    font-size: 1.25em;
    margin-bottom: 12px;
    line-height: 1.25;
    transition: color 0.3s ease;
  }
  .dia-agrupado > .card .dia-semana .hora-texto {
    font-size: 0.85em;
    font-weight: normal;
    color: #555;
    transition: color 0.3s ease;
  }
  .dia-agrupado > .card .data-pequena {
    font-size: 0.8em;
    margin-bottom: 5px;
    transition: color 0.3s ease;
  }
  .dia-agrupado > .card .btn-confirmar {
    padding: 10px 15px;
    font-size: 0.9em;
  }

  .cards-grid > .card {
    background: white;
    border-radius: 16px;
    padding: 25px;
    box-shadow: 0 8px 20px rgba(45, 137, 239, 0.15);
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
    transition: transform 0.25s ease, box-shadow 0.25s ease, background-color 0.3s ease, border-color 0.3s ease, opacity 0.3s ease; /* Added transitions */
    border: 2px solid transparent;
    position: relative;
  }
  .cards-grid > .card .dia-semana {
    font-size: 1.45em;
    transition: color 0.3s ease;
  }

  .card:hover:not(.canceled) { /* Don't apply hover effect to canceled cards */
    transform: translateY(-5px);
    box-shadow: 0 12px 25px rgba(45, 137, 239, 0.2);
  }
  .card.confirmado {
    background-color: #e0f8e7;
    border: 2px solid #28a745;
  }
  .card.confirmado .dia-semana {
    color: #1c7430;
  }
  .card.confirmado .dia-semana .hora-texto {
    color: #208139;
  }
  .card.confirmado .btn-confirmar {
    background-color: #6c757d;
    cursor: pointer;
    opacity: 0.9;
  }
  .card.confirmado .btn-confirmar:hover {
    background-color: #5a6268;
  }

  /* --- START: Styles for Canceled Cards --- */
  .card.canceled {
    background-color: #ffebee !important; /* Light red background */
    border-color: #e57373 !important; /* Darker red border */
    box-shadow: 0 4px 10px rgba(200, 0, 0, 0.1); /* Reddish shadow */
    opacity: 0.8; /* Slightly faded */
  }

  .card.canceled .dia-semana,
  .card.canceled .data-pequena,
  .card.canceled .hora-texto {
    color: #c62828 !important; /* Dark red text */
    /* Optional: text-decoration: line-through; */
  }

  .card.canceled .btn-confirmar {
    background-color: #bdbdbd !important; /* Gray background */
    color: #757575 !important; /* Darker gray text */
    cursor: not-allowed !important;
    opacity: 0.7 !important;
    transform: none !important; /* Disable hover/active effects */
    pointer-events: none; /* Further ensure no interaction */
  }
  /* --- END: Canceled Card Styles --- */

  .data-pequena {
    font-size: 0.9em;
    color: #555;
    margin-bottom: 8px;
    transition: color 0.3s ease;
  }
  .dia-semana {
    font-weight: bold;
    color: #2d89ef;
    text-transform: capitalize;
    margin-bottom: 20px;
    line-height: 1.3;
    transition: color 0.3s ease;
  }
  .dia-semana .hora-texto {
    font-size: 0.8em;
    font-weight: normal;
    color: #555;
    display: block;
    margin-top: 4px;
    transition: color 0.3s ease;
  }

  .btn-confirmar, .btn-continuar, .btn-voltar {
    padding: 12px 25px;
    background: #2d89ef;
    color: white;
    border: none;
    border-radius: 10px;
    font-size: 1em;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s ease, transform 0.1s ease, opacity 0.2s ease;
    margin-top: auto; /* Pushes button down in card */
  }
  .btn-continuar {
      margin-top: 0; /* Overwrite auto margin for this button */
  }
  .btn-confirmar:hover:not(:disabled), /* Apply hover only if not disabled */
  .btn-continuar:hover:not(:disabled),
  .btn-voltar:hover {
    background-color: #1b5dbf;
  }
  .btn-confirmar:active:not(:disabled), /* Apply active only if not disabled */
  .btn-continuar:active:not(:disabled),
  .btn-voltar:active {
    transform: scale(0.98);
  }
  .btn-confirmar:disabled, .btn-continuar:disabled { /* Apply disabled style to Continuar too */
    cursor: not-allowed;
    opacity: 0.6;
    background-color: #8abbee; /* Lighter blue when disabled */
    /* Ensure specific canceled button style overrides this if needed */
  }
  .btn-voltar {
    background-color: #6c757d;
    margin-bottom: 30px;
    align-self: flex-start;
  }
  .btn-voltar:hover {
    background-color: #5a6268;
  }

  #boasVindas {
    width: 100%;
    text-align: left;
    font-size: 1.5em;
    color: #333;
    margin-bottom: 30px;
  }
  .hidden { display: none !important; }

  .emoji-burst {
    position: absolute;
    font-size: 24px;
    pointer-events: none;
    z-index: 1000;
  }
  .loading-spinner {
    position: absolute;
    top: 10px;
    right: 10px;
    width: 20px;
    height: 20px;
    border: 3px solid rgba(45, 137, 239, 0.3);
    border-radius: 50%;
    border-top-color: #2d89ef;
    animation: spin 1s ease-in-out infinite;
    z-index: 5;
  }
  @keyframes spin { to { transform: rotate(360deg); } }

  /* --- AJUSTES ESPECÍFICOS PARA MOBILE --- */
  @media (max-width: 700px) {
    body {
      font-size: 18px; /* Adjusted base font size */
    }

    .cards-grid {
      grid-template-columns: 1fr; /* Stack cards */
      gap: 25px; /* Keep gap between stacked items */
    }
    .dia-agrupado {
      flex-wrap: wrap; /* Allow grouped cards to wrap if needed */
    }

    /* Make containers take full width minus some padding */
    #selecao-container, #cards-container {
      padding: 0 15px !important; /* Add side padding */
      margin: 20px 0 0 0 !important; /* Adjust top margin */
      width: 100% !important;
      max-width: 100% !important; /* Ensure full width */
    }

    #selecao-container h2 {
      font-size: 1.5em; /* Slightly smaller */
      padding-left: 0;
      padding-right: 0;
    }

    /* Adjust Input and Suggestions for Mobile */
    .nome-input-wrapper {
       max-width: none; /* Allow full width */
       width: 100%;
       margin-bottom: 20px; /* Keep spacing */
    }

    input#nomeInput {
      padding: 18px 20px; /* Larger padding for easier tapping */
      font-size: 1.2em; /* Larger font */
      width: 100%;
      border-radius: 8px; /* Keep some radius */
    }

    .suggestions-list {
       font-size: 1.1em;
       max-height: 250px; /* Slightly more height */
       border-radius: 0 0 8px 8px;
    }
    .suggestion-item {
        padding: 12px 20px;
    }

    .btn-continuar {
      width: 100%; /* Full width */
      max-width: none;
      padding: 18px 0; /* Taller button */
      font-size: 1.3em;
      border-radius: 8px; /* Match input radius */
      margin-top: 0; /* Align with wrapper */
    }

    /* Adjust Card Styles for Mobile */
    .cards-grid > .card,
    .dia-agrupado > .card {
      padding: 30px 20px; /* Adjust padding */
      width: 100%; /* Take full width */
      max-width: none;
      margin-bottom: 20px; /* Space between cards */
      border-radius: 12px; /* Consistent radius */
    }
    .cards-grid > .card:last-child,
    .dia-agrupado > .card:last-child {
       margin-bottom: 0;
    }

    .card .data-pequena {
      font-size: 1.0em; /* Adjust size */
      margin-bottom: 10px;
    }
    .card .dia-semana {
      font-size: 1.6em; /* Adjust size */
      line-height: 1.3;
      margin-bottom: 25px;
    }
    .card .dia-semana .hora-texto {
      font-size: 0.9em; /* Adjust size */
      margin-top: 5px;
    }
    .card .btn-confirmar {
      padding: 15px 25px;
      font-size: 1.1em;
      width: auto; /* Don't force width */
      max-width: 250px; /* Limit max width */
      min-width: 120px; /* Ensure minimum tap area */
    }

    /* Grouped card adjustments (might be redundant now) */
    .dia-agrupado > .card { padding: 25px 15px; }
    .dia-agrupado > .card .dia-semana { font-size: 1.5em; }
    .dia-agrupado > .card .dia-semana .hora-texto { font-size: 0.85em; }
    .dia-agrupado > .card .data-pequena { font-size: 1.0em; }
    .dia-agrupado > .card .btn-confirmar { padding: 12px 20px; font-size: 1.0em; }

    #boasVindas {
      font-size: 1.2em; /* Adjust size */
      margin-bottom: 30px;
      padding-left: 0;
      padding-right: 0;
    }
    .semana-titulo {
      font-size: 1.3em;
      margin-bottom: 20px;
      padding-bottom: 8px;
      padding-left: 0;
      padding-right: 0;
    }
    .btn-voltar {
      padding: 12px 25px;
      font-size: 1.1em;
      margin-bottom: 30px;
      margin-left: 0; /* Align left */
      margin-right: 0;
      border-radius: 8px;
    }
  }
  /* --- Fim do CSS --- */
  </style>
</head>
<body>

<header>
  <h1>Confirme sua disponibilidade</h1>
</header>

<!-- Seleção de nome -->
<div id="selecao-container">
  <h2>Escolha seu nome:</h2>
  <div class="nome-input-wrapper">
    <input type="text" id="nomeInput" placeholder="Clique ou digite para filtrar..." autocomplete="off" disabled>
    <div id="nomeSuggestions" class="suggestions-list hidden"></div>
  </div>
  <button class="btn-continuar" onclick="continuar()" disabled>Continuar</button>
</div>

<!-- Cards de disponibilidade -->
<div id="cards-container" class="hidden">
  <button class="btn-voltar" onclick="voltar()">⬅️ Trocar nome</button>
  <h2 id="boasVindas"></h2>
  <div id="cards-grupos">
    <!-- Conteúdo carregado via JS -->
  </div>
</div>

<!-- Add Firebase SDKs using Modules -->
<script type="module">
  // Firebase Imports...
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
  import { getFirestore, collection, addDoc, serverTimestamp, query, where, getDocs, limit, deleteDoc, doc, orderBy } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
  // ** REPLACE WITH YOUR ACTUAL FIREBASE CONFIG **
  const firebaseConfig = {
    apiKey: "AIzaSyCxUQTIg1cebw6FSzIH2w05ETgi9sj6dcU",
  authDomain: "daytime-a0fa5.firebaseapp.com",
  projectId: "daytime-a0fa5",
  storageBucket: "daytime-a0fa5.firebasestorage.app",
  messagingSenderId: "217848316066",
  appId: "1:217848316066:web:fad68b3fd59ece761997fb"
  };

  // Initialize Firebase
  let app;
  let db;
  const nomeInput = document.getElementById("nomeInput");
  const suggestionsDiv = document.getElementById("nomeSuggestions");
  const continuarBtn = document.querySelector(".btn-continuar");

  try {
      // Basic check if config seems like placeholders
      if (!firebaseConfig.apiKey || firebaseConfig.apiKey === "YOUR_API_KEY" || firebaseConfig.apiKey.length < 10 ||
          !firebaseConfig.projectId || firebaseConfig.projectId === "YOUR_PROJECT_ID") {
           throw new Error("Firebase config not provided or seems like placeholder values.");
      }
      app = initializeApp(firebaseConfig);
      db = getFirestore(app);
      console.log("Firebase initialized successfully.");
      nomeInput.placeholder = "Carregando nomes...";
  } catch (error) {
      console.error("Firebase initialization failed:", error);
      alert(`Erro ao conectar com a base de dados: ${error.message}`);
      if(nomeInput) { nomeInput.placeholder = '-- Erro de Conexão --'; nomeInput.disabled = true; }
      if(continuarBtn) continuarBtn.disabled = true;
  }

  // --- Global Variables ---
  let usuarioAtual = null;
  let userConfirmations = new Set(); // Stores session confirmations as "YYYY-MM-DD|HH:MM" or "YYYY-MM-DD|null"
  let availableEventos = []; // Stores fetched & processed future events {..., data: Date, estado: string}
  let allNames = []; // Array to store all fetched names
  let selectedNameValid = false; // Track if input holds a valid selected name

  // --- Date Formatting/Grouping Helpers ---
  function parseStartHour(horarioString) {
        if (!horarioString || typeof horarioString !== 'string') { return 99; } // Default high number for sorting
        const match = horarioString.match(/^(\d+)/); // Match digits at the beginning
        if (match && match[1]) {
            const hour = parseInt(match[1], 10);
            return isNaN(hour) ? 99 : hour;
        }
        return 99; // Return high number if no digits found
    }
    function processEventDateData(eventoDataFromFirestore) {
         // Expects an object like { dataOriginal: 'YYYY-MM-DD', horario: 'HH:MM', diasemana: '...', estado: 'ativo/cancelado', ... }
         if (!eventoDataFromFirestore?.dataOriginal) return null;
         const dataStr = eventoDataFromFirestore.dataOriginal;
         const parts = dataStr.split('-');
         if (parts.length !== 3) return null; // Invalid format

          try {
             // Use UTC to avoid timezone issues when comparing dates
             const dateObjectUTC = new Date(Date.UTC(parts[0], parts[1] - 1, parts[2])); // Month is 0-indexed

             // Format for display (adjust locale as needed)
             const optionsDataExtenso = { day: 'numeric', month: 'long', year: 'numeric', timeZone: 'UTC' };
             const dataExtenso = dateObjectUTC.toLocaleDateString('pt-PT', optionsDataExtenso);

             // Extract start hour for potential sorting within a day
             const startHour = parseStartHour(eventoDataFromFirestore.horario);

             // Return enriched object including the Date object and state
             return {
                ...eventoDataFromFirestore, // Keep all original fields (like id, estado, etc.)
                data: dateObjectUTC,        // Add the actual Date object (UTC)
                dataExtenso: dataExtenso,   // Add formatted date string
                startHour: startHour        // Add parsed start hour
             };
          } catch (e) {
             console.error(`Error processing date ${dataStr}:`, e);
             return null;
          }
      }
     function getSemanaRange(data) {
       // Expects a Date object
       if (!(data instanceof Date) || isNaN(data)) return { display: "Semana inválida", key: "invalid-" + Date.now() };

       // Calculate start of the week (Monday) based on UTC day
       const diaDaSemana = data.getUTCDay(); // 0 (Sun) to 6 (Sat)
       const diff = diaDaSemana === 0 ? -6 : 1 - diaDaSemana; // Calculate difference to Monday
       const inicioSemana = new Date(data);
       inicioSemana.setUTCDate(data.getUTCDate() + diff);

       // Calculate end of the week (Sunday)
       const fimSemana = new Date(inicioSemana);
       fimSemana.setUTCDate(inicioSemana.getUTCDate() + 6);

       // Format the display string
       const iDia = inicioSemana.getUTCDate();
       const fDia = fimSemana.getUTCDate();
       const opts = { month: 'long', timeZone: 'UTC' };
       const mInicio = inicioSemana.toLocaleDateString('pt-PT', opts);
       const mFim = fimSemana.toLocaleDateString('pt-PT', opts);
       const aInicio = inicioSemana.getUTCFullYear();
       const aFim = fimSemana.getUTCFullYear();

       let range = `Semana de ${iDia}`;
       if (mInicio !== mFim || aInicio !== aFim) range += ` de ${mInicio}`; // Add month if different or year is different
       if (aInicio !== aFim) range += ` de ${aInicio}`; // Add year if different
       range += ` a ${fDia} de ${mFim}`; // Always add end day and month
       // Add end year only if different from start year OR if months were different (to avoid ambiguity)
       if (aInicio !== aFim || mInicio !== mFim) range += ` de ${aFim}`;

       // Create a sortable key (YYYY-MM-DD of the start date)
       const sortK = `${aInicio}-${String(inicioSemana.getUTCMonth() + 1).padStart(2, '0')}-${String(iDia).padStart(2, '0')}`;

       return { display: range, key: sortK };
     }

  // --- Fetch Event Dates ---
  async function fetchAndFilterEventosData() {
        if (!db) { console.error("DB not initialized."); return []; }
        console.log("Fetching 'eventosData'...");
        availableEventos = []; // Reset global list

        // Get today's date at the beginning (00:00:00) in UTC
        const today = new Date();
        const todayUTC = new Date(Date.UTC(today.getUTCFullYear(), today.getUTCMonth(), today.getUTCDate()));
        console.log(`Comparing against future/today date: ${todayUTC.toISOString().split('T')[0]}`);

        try {
            const qSnapshot = await getDocs(collection(db, "eventosData"));
            console.log(`Fetched ${qSnapshot.size} total events from Firestore.`);

            const fetchedAndProcessed = [];
            qSnapshot.forEach((doc) => {
                // Process each event (parse date, add helpers)
                const pData = processEventDateData(doc.data());
                // Filter: Check if processed data is valid AND date is today or in the future
                if (pData && pData.data >= todayUTC) {
                     // Keep all fields including the 'estado'
                    fetchedAndProcessed.push(pData);
                }
            });

            // Sort the valid future events by date, then by start hour
            fetchedAndProcessed.sort((a, b) => {
                const dateDiff = a.data - b.data;
                if (dateDiff !== 0) return dateDiff;
                return (a.startHour ?? 99) - (b.startHour ?? 99); // Sort by parsed hour
            });

            availableEventos = fetchedAndProcessed; // Update global list
            console.log(`Found ${availableEventos.length} valid future/today events after processing and filtering.`);

        } catch (error) {
            console.error("ERROR fetching or processing events:", error);
            alert("Erro ao carregar as datas dos eventos.");
            availableEventos = []; // Ensure list is empty on error
        }
        return availableEventos;
    }

  // --- CORE APPLICATION LOGIC ---

  // Fetch Names from Firestore
  async function preencherNomes() {
      nomeInput.placeholder = '-- Carregando... --';
      nomeInput.disabled = true;
      continuarBtn.disabled = true;
      allNames = [];
      console.log("[preencherNomes] Starting.");
      if (!db) { console.error("DB not initialized."); return; }
      try {
          const qSnapshot = await getDocs(query(collection(db, "pessoas"), orderBy("nome"))); // Order by name in Firestore
          const nomesTemp = [];
          qSnapshot.forEach((doc) => {
              // Trim whitespace just in case
              if (doc.data()?.nome) nomesTemp.push(doc.data().nome.trim());
          });
          allNames = nomesTemp; // Already sorted by Firestore

          if (allNames.length > 0) {
              nomeInput.placeholder = 'Clique ou digite para escolher...';
              nomeInput.disabled = false;
              console.log("Names loaded:", allNames.length);
          } else {
              nomeInput.placeholder = '-- Nenhum nome encontrado --';
              console.warn("No names found in 'pessoas' collection.");
          }
      } catch (error) {
          console.error("Error fetching names:", error);
          nomeInput.placeholder = '-- Erro ao carregar nomes --';
          alert("Não foi possível carregar a lista de nomes.");
      }
      finally {
          console.log("[preencherNomes] Finished.");
          // Ensure button state is correct after loading finishes or fails
          continuarBtn.disabled = !selectedNameValid;
      }
  }

  // --- Suggestion Display Logic ---

  function displaySuggestions(namesToShow) {
      suggestionsDiv.innerHTML = ''; // Clear previous
      if (!namesToShow || namesToShow.length === 0) {
          suggestionsDiv.classList.add('hidden');
          return;
      }
      namesToShow.forEach(name => {
          const item = document.createElement('div');
          item.classList.add('suggestion-item');
          item.textContent = name;
          item.addEventListener('click', () => selectName(name));
          suggestionsDiv.appendChild(item);
      });
      suggestionsDiv.classList.remove('hidden'); // Show the list
  }

  function selectName(name) {
      // Check against the fetched list `allNames`
      if (allNames.includes(name)) {
        nomeInput.value = name;
        suggestionsDiv.classList.add('hidden');
        usuarioAtual = name;
        selectedNameValid = true;
        continuarBtn.disabled = false;
        console.log("Name selected:", usuarioAtual);
      } else {
        console.warn("Attempted to select an invalid name:", name);
        // Keep button disabled, maybe clear input?
        // nomeInput.value = ""; // Optional: Clear if invalid selection somehow occurs
        usuarioAtual = null;
        selectedNameValid = false;
        continuarBtn.disabled = true;
      }
  }

  function handleNameInput() {
      const inputText = nomeInput.value.trim();
      const inputTextLower = inputText.toLowerCase();

      selectedNameValid = false;
      continuarBtn.disabled = true;
      usuarioAtual = null;

      let filteredNames = [];
      if (inputText.length > 0) {
          filteredNames = allNames.filter(name =>
              name.toLowerCase().includes(inputTextLower)
          );
           displaySuggestions(filteredNames); // Show filtered list
      } else {
          // If input is empty, show all names (triggered by focus/click)
          displaySuggestions(allNames);
          // Don't automatically enable continue button if input is empty
          return;
      }

      // Check if the current typed text is an exact match to a valid name
      if (allNames.includes(inputText)) {
          selectedNameValid = true;
          continuarBtn.disabled = false;
          usuarioAtual = inputText; // Set global name if it's a perfect match
          console.log("Input matches valid name:", usuarioAtual);
      }
  }

  // --- Event Listeners for Input ---
  nomeInput.addEventListener('input', handleNameInput);
  nomeInput.addEventListener('focus', () => {
      // Show suggestions on focus: all if empty, filtered otherwise
      handleNameInput(); // Re-run logic which handles empty/non-empty cases
  });
  nomeInput.addEventListener('click', () => {
      // Re-run logic on click as well for mobile/etc.
      handleNameInput();
  });
  document.addEventListener('click', (event) => {
      // Hide suggestions if click is outside the input AND outside the suggestions list
      if (!nomeInput.contains(event.target) && !suggestionsDiv.contains(event.target)) {
          suggestionsDiv.classList.add('hidden');
      }
  });
   // Add Enter key listener in window.onload after names are loaded


  // --- Button Actions ---
  async function continuar() {
    if (!selectedNameValid || !usuarioAtual) {
        // Final validation check
        const currentInputText = nomeInput.value.trim();
        if (allNames.includes(currentInputText)) {
            selectName(currentInputText); // Explicitly select if valid
        } else {
            alert("Por favor, selecione um nome válido da lista ou digite um nome completo existente.");
            nomeInput.focus();
            displaySuggestions(allNames);
            return;
        }
    }
    if (!db) { alert("Erro DB."); return; }

    userConfirmations.clear(); // Clear previous session confirmations
    document.getElementById("selecao-container").classList.add("hidden");
    document.getElementById("cards-container").classList.remove("hidden");
    document.getElementById("boasVindas").textContent = `Olá, ${usuarioAtual}! Carregando datas...`;
    document.getElementById("cards-grupos").innerHTML = '<div style="text-align:center; padding: 20px;">A carregar disponibilidades...</div>';

    // Fetch the events again (or use cached if implementing caching)
    const eventosParaMostrar = await fetchAndFilterEventosData();

    document.getElementById("boasVindas").textContent = `Olá, ${usuarioAtual}! Selecione os dias em que pode:`;
    if (eventosParaMostrar.length > 0) {
        // Render cards based on the fetched events
        renderCardsAgrupados(eventosParaMostrar);
        // Pre-load user's existing confirmations for these events in the background
        preloadUserConfirmations(eventosParaMostrar);
    } else {
        document.getElementById("cards-grupos").innerHTML = '<div style="text-align:center; padding: 20px;">Nenhuma data futura disponível para confirmação.</div>';
    }
  }

  function voltar() {
    usuarioAtual = null;
    selectedNameValid = false;
    userConfirmations.clear();
    availableEventos = [];
    document.getElementById("cards-container").classList.add("hidden");
    document.getElementById("selecao-container").classList.remove("hidden");
    nomeInput.value = "";
    suggestionsDiv.classList.add('hidden');
    continuarBtn.disabled = true;
    document.getElementById("cards-grupos").innerHTML = "";
    // Optionally call preencherNomes again if list might have changed?
    // For now, assume the initial list is static for the session.
  }

  // --- Preload User Confirmations ---
   async function preloadUserConfirmations(eventos) {
        if (!usuarioAtual || !db || eventos.length === 0) return;
        console.log(`Preloading confirmations for ${usuarioAtual}...`);
        userConfirmations.clear(); // Start fresh for this view

        // Create a list of unique date strings from the displayed events
        const dateStrings = [...new Set(eventos.map(ev => ev.dataOriginal))];
        if (dateStrings.length === 0) return;

        // Query Firestore for confirmations matching the user and the relevant dates
        // Note: Firestore 'in' query limit is 30 items as of now. If more dates, split into multiple queries.
        const MAX_IN_QUERY = 30;
        const dateChunks = [];
        for (let i = 0; i < dateStrings.length; i += MAX_IN_QUERY) {
            dateChunks.push(dateStrings.slice(i, i + MAX_IN_QUERY));
        }

        let foundConfirmations = 0;
        try {
            for (const chunk of dateChunks) {
                 const q = query(
                     collection(db, "disponibilidade"),
                     where("nome", "==", usuarioAtual),
                     where("dataOriginal", "in", chunk)
                 );
                 const querySnapshot = await getDocs(q);
                 querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    const sessionKey = `${data.dataOriginal}|${data.horario === null ? 'null' : data.horario}`;
                    userConfirmations.add(sessionKey);
                    foundConfirmations++;
                    // Update the specific card visually *now* that we know it's confirmed
                    const cardElement = findCardElement(data.dataOriginal, data.horario);
                    if (cardElement && !cardElement.classList.contains('canceled')) { // Only update if not canceled
                       cardElement.classList.add('confirmado');
                       const button = cardElement.querySelector('.btn-confirmar');
                       if (button) button.textContent = 'Confirmado!';
                    }
                 });
            }
            console.log(`Preloaded ${foundConfirmations} existing confirmations. Session cache:`, Array.from(userConfirmations));
        } catch (error) {
            console.error("Error preloading user confirmations:", error);
            // Don't alert the user, but log the error
        }
    }

     // Helper to find a card based on data and horario
     function findCardElement(dataOriginal, horario) {
        const cards = document.querySelectorAll('#cards-grupos .card');
        for (const card of cards) {
            // Find the hidden data needed for matching (could store as data attributes)
            // For now, let's try matching based on displayed text (less robust)
            const dataPequena = card.querySelector('.data-pequena');
            const horaTextoSpan = card.querySelector('.dia-semana .hora-texto');
            const displayedHorario = horaTextoSpan ? horaTextoSpan.textContent.trim() : null;

            // Need a way to reliably get the 'dataOriginal' back from the element.
            // Let's add it as a data attribute in createCardElement.
            if (card.dataset.originalDate === dataOriginal && card.dataset.horario === (horario === null ? 'null' : horario)) {
                return card;
            }
        }
        return null; // Not found
     }


  // --- Card Creation / Rendering ---
   function createCardElement(ev) {
       const isCanceled = ev.estado === 'cancelado'; // Check the canceled status
       const sessionKey = `${ev.dataOriginal}|${ev.horario || 'null'}`;
       // Confirmation status is irrelevant if event is canceled
       const confirmadoNaSessao = !isCanceled && userConfirmations.has(sessionKey);

       const card = document.createElement("div");
       card.className = "card";
       // Add data attributes for easier lookup later
       card.dataset.originalDate = ev.dataOriginal;
       card.dataset.horario = ev.horario === null ? 'null' : ev.horario;

       if (isCanceled) {
           card.classList.add('canceled'); // Add canceled class
       } else if (confirmadoNaSessao) {
           // Note: Preload confirms might add this class later too
           card.classList.add('confirmado');
       }

       const dataPequenaDiv = document.createElement("div");
       dataPequenaDiv.className = "data-pequena";
       dataPequenaDiv.textContent = ev.dataExtenso;

       const diaSemanaDiv = document.createElement("div");
       diaSemanaDiv.className = "dia-semana";
       const diaTexto = ev.diasemana;
       const horarioTexto = (ev.horario?.trim()) ? ` ${ev.horario.trim()}` : '';
       diaSemanaDiv.innerHTML = `${diaTexto}${horarioTexto ? '<br><span class="hora-texto">' + horarioTexto + '</span>' : ''}`;

       const btnConfirmar = document.createElement("button");
       btnConfirmar.className = "btn-confirmar";

       if (isCanceled) {
           btnConfirmar.textContent = "Cancelado";
           btnConfirmar.disabled = true; // Disable button
       } else {
           // Initial state based on session cache, preload might update later
           btnConfirmar.textContent = confirmadoNaSessao ? "Confirmado!" : "Eu posso";
           btnConfirmar.onclick = () => confirmar(ev, btnConfirmar); // Add handler only if not canceled
       }

       card.appendChild(dataPequenaDiv);
       card.appendChild(diaSemanaDiv);
       card.appendChild(btnConfirmar);

       return card;
   }
   function renderCardsAgrupados(eventos) {
        const container = document.getElementById("cards-grupos");
        container.innerHTML = ""; // Clear previous cards
        console.log(`Rendering ${eventos.length} events. Initial session confirmations:`, Array.from(userConfirmations));

        if (eventos.length === 0) {
            container.innerHTML = '<div style="text-align:center; padding: 20px;">Nenhuma data futura disponível para confirmação.</div>';
            return;
        }

        // Group events by week
        const gruposPorSemana = {};
        eventos.forEach(ev => {
            if (!ev?.data) return; // Skip if date object is missing
            try {
                const si = getSemanaRange(ev.data); // Get week info { display: "...", key: "YYYY-MM-DD" }
                if (!gruposPorSemana[si.key]) {
                    gruposPorSemana[si.key] = { display: si.display, eventos: [] };
                }
                gruposPorSemana[si.key].eventos.push(ev);
            } catch (e) {
                console.error("Error grouping event by week", ev, e);
            }
        });

        // Sort weeks by their key (YYYY-MM-DD)
        const semanasOrdenadas = Object.keys(gruposPorSemana).sort();

        // Render each week
        semanasOrdenadas.forEach(semanaKey => {
            const semanaGrupo = gruposPorSemana[semanaKey];
            const grupoDiv = document.createElement("div");
            grupoDiv.className = "grupo-semana";

            // Add week title
            const titulo = document.createElement("div");
            titulo.className = "semana-titulo";
            titulo.textContent = semanaGrupo.display;
            grupoDiv.appendChild(titulo);

            // Create grid for the week's cards
            const gridSemana = document.createElement("div");
            gridSemana.className = "cards-grid";

            // Group events within the week by day
            const eventosPorDiaNaSemana = {};
            semanaGrupo.eventos.forEach(ev => {
                const dk = ev.dataOriginal; // Group by YYYY-MM-DD string
                if (!eventosPorDiaNaSemana[dk]) {
                    eventosPorDiaNaSemana[dk] = [];
                }
                eventosPorDiaNaSemana[dk].push(ev);
            });

            // Sort days within the week
            const diasOrdenadosNaSemana = Object.keys(eventosPorDiaNaSemana).sort();

            // Render cards for each day
            diasOrdenadosNaSemana.forEach(dataDia => {
                const eventosDoDia = eventosPorDiaNaSemana[dataDia];
                // Sort events within the same day by start hour
                eventosDoDia.sort((a, b) => (a.startHour ?? 99) - (b.startHour ?? 99));

                if (eventosDoDia.length === 1) {
                    // If only one event for the day, add card directly to grid
                    gridSemana.appendChild(createCardElement(eventosDoDia[0]));
                } else if (eventosDoDia.length > 1) {
                    // If multiple events, group them horizontally
                    const diaAgrupadoWrapper = document.createElement("div");
                    diaAgrupadoWrapper.className = "dia-agrupado";
                    eventosDoDia.forEach(ev => diaAgrupadoWrapper.appendChild(createCardElement(ev)));
                    gridSemana.appendChild(diaAgrupadoWrapper); // Add the group to the grid
                }
            });

            grupoDiv.appendChild(gridSemana); // Add the grid to the week group
            container.appendChild(grupoDiv); // Add the week group to the main container
        });
        console.log("[renderCardsAgrupados] Finished rendering.");
    }

  // --- Confirmation/Deletion Logic ---
  async function deleteConfirmation(dataOriginal, horario = null) {
        if (!usuarioAtual || !dataOriginal || !db) { console.error("deleteConfirmation missing data"); return false; }
        const horarioValue = horario === null ? null : horario; // Use actual null for query if needed
        console.log(`Deleting for ${usuarioAtual} on ${dataOriginal} ${horarioValue !== null ? `at ${horarioValue}` : '(no specific time)'}...`);

        // Construct the query based on whether horario is null or a string
        const q = query(
             collection(db, "disponibilidade"),
             where("nome", "==", usuarioAtual),
             where("dataOriginal", "==", dataOriginal),
             where("horario", "==", horarioValue), // Query for null or specific time string
             limit(1)
         );

        try {
            const qSnapshot = await getDocs(q);
            if (qSnapshot.empty) {
                 console.warn(`Confirmation doc not found in Firestore for ${usuarioAtual} on ${dataOriginal} at ${horarioValue}. Assuming deleted.`);
                 return true; // Treat as success if already gone
            }
            const docToDelete = qSnapshot.docs[0];
            await deleteDoc(doc(db, "disponibilidade", docToDelete.id));
            console.log(`Doc ${docToDelete.id} deleted from Firestore.`);
            return true;
        } catch (error) {
            console.error(`Error deleting confirmation for ${usuarioAtual} on ${dataOriginal} at ${horarioValue}:`, error);
            alert(`Erro ao remover confirmação para ${dataOriginal}. Tente novamente.`);
            return false;
        }
    }
  async function confirmar(eventoData, button) {
       // --- Prevent action on canceled event ---
       if (eventoData.estado === 'cancelado') {
           console.warn("Attempted action on a canceled event:", eventoData.dataOriginal, eventoData.horario);
           return; // Stop execution
       }
       // --- End Canceled Check ---

       if (!db) { console.error("DB not available."); alert("Erro conexão."); return; }
       const card = button.closest('.card');
       const dataOriginal = eventoData.dataOriginal;
       const horarioEvento = eventoData.horario || null; // Use null if horario is empty/null/undefined
       if (!dataOriginal) { console.error("Missing dataOriginal in eventoData"); alert("Erro interno: dados do evento inválidos."); return; }
       if (button.disabled) { console.log("Action already in progress for this card."); return; }

       const sessionKey = `${dataOriginal}|${horarioEvento === null ? 'null' : horarioEvento}`;
       const logPrefix = `[confirmar | User: ${usuarioAtual} | ${sessionKey}]`;
       console.log(`${logPrefix} --- START ---`);

       const isConfirmedInSession = userConfirmations.has(sessionKey);
       console.log(`${logPrefix} Status in session cache: ${isConfirmedInSession}`);

       button.disabled = true;
       const spinner = document.createElement('div'); spinner.className = 'loading-spinner'; card.appendChild(spinner); // Add spinner

       try {
           if (isConfirmedInSession) { // --- REMOVE CONFIRMATION ---
               button.textContent = 'A remover...';
               console.log(`${logPrefix} Attempting to REMOVE confirmation.`);
               const deleteSuccess = await deleteConfirmation(dataOriginal, horarioEvento);

               if (deleteSuccess) {
                   userConfirmations.delete(sessionKey); // Remove from session cache
                   card.classList.remove('confirmado');
                   button.textContent = 'Eu posso'; // Update button text
                   console.log(`${logPrefix} REMOVE successful.`);
               } else {
                   // Deletion failed, revert button text (card state remains 'confirmado' visually for now)
                   button.textContent = 'Confirmado!';
                   console.error(`${logPrefix} REMOVE failed.`);
               }

           } else { // --- ADD CONFIRMATION ---
               button.textContent = 'A guardar...';
               console.log(`${logPrefix} Attempting to ADD confirmation.`);

               // Optional: Check Firestore again just before adding, though preload helps avoid this.
               // const checkQuery = query( ... );
               // const existingDocsSnapshot = await getDocs(checkQuery);
               // if (!existingDocsSnapshot.empty) { ... handle already exists ... }

               console.log(`${logPrefix} Saving to Firestore...`);
               // Prepare data, ensuring all necessary fields are present
               const semanaInfo = getSemanaRange(eventoData.data); // Recalculate just in case
               const dados = {
                  nome: usuarioAtual,
                  ano: String(eventoData.data.getUTCFullYear()), // Ensure string if needed by DB/rules
                  mes: String(eventoData.data.getUTCMonth() + 1).padStart(2,'0'), // Ensure string/padding
                  semana: semanaInfo.display, // Use calculated week display string
                  dia: String(eventoData.data.getUTCDate()).padStart(2,'0'), // Ensure string/padding
                  diasemana: eventoData.diasemana,
                  dataOriginal: dataOriginal, // YYYY-MM-DD
                  horario: horarioEvento, // Specific time string or null
                  timestamp: serverTimestamp() // Use Firestore server timestamp
               };

                // Basic validation before sending
               if (!dados.nome || !dados.dataOriginal) {
                   throw new Error("Dados essenciais (nome, dataOriginal) em falta para guardar.");
               }

               await addDoc(collection(db, "disponibilidade"), dados);
               console.log(`${logPrefix} ADD successful in Firestore.`);

               userConfirmations.add(sessionKey); // Add to session cache
               card.classList.add('confirmado');
               button.textContent = "Confirmado!";
               triggerEmojiBurst(button); // Visual feedback

           }
       } catch (e) {
           console.error(`${logPrefix} ERROR during confirm/remove: `, e);
           alert(`Ocorreu um erro ao ${isConfirmedInSession ? 'remover' : 'adicionar'} a confirmação para ${dataOriginal}. Tente novamente. (${e.message})`);
           // Revert button text based on the intended action before the error
           button.textContent = isConfirmedInSession ? 'Confirmado!' : 'Eu posso';
           // Optional: Revert visual card state if error occurred during ADD?
           // if (!isConfirmedInSession) card.classList.remove('confirmado');
       } finally {
           if(spinner) spinner.remove(); // Remove spinner regardless of outcome
           // Re-enable button only if it wasn't for a canceled event initially
           if (eventoData.estado !== 'cancelado') {
               button.disabled = false;
           }
           console.log(`${logPrefix} --- END --- Session cache:`, Array.from(userConfirmations));
       }
     }

  // --- Visual Effects ---
  function triggerEmojiBurst(button) {
        if (!button || !document.body) return;
        const buttonRect = button.getBoundingClientRect();
        // Calculate center relative to viewport, then add scroll offsets for absolute positioning
        const startX = buttonRect.left + buttonRect.width / 2 + window.scrollX;
        const startY = buttonRect.top + buttonRect.height / 2 + window.scrollY;
        const emojiChar = '👍'; // Choose your emoji

        for (let i = 0; i < 15; i++) { // Number of emojis
            const emoji = document.createElement('span');
            emoji.textContent = emojiChar;
            emoji.className = 'emoji-burst'; // Use class for styling if needed
            emoji.style.position = 'absolute'; // Ensure absolute positioning
            emoji.style.left = `${startX}px`;
            emoji.style.top = `${startY}px`;
            emoji.style.fontSize = `${18 + Math.random() * 12}px`; // Random size
            document.body.appendChild(emoji);

            const angle = Math.random() * Math.PI * 2; // Random direction
            const distance = 60 + Math.random() * 50; // Random distance
            const duration = 700 + Math.random() * 300; // Random duration

            // Animate position and fade out
            const x = Math.cos(angle) * distance;
            const y = Math.sin(angle) * distance - distance * 0.5; // Slight upward bias

            const animation = emoji.animate([
                { transform: `translate(0, 0) scale(1)`, opacity: 1 },
                { transform: `translate(${x}px, ${y}px) scale(0.5)`, opacity: 0 }
            ], {
                duration: duration,
                easing: 'cubic-bezier(0.1, 0.8, 0.7, 1.0)' // Ease out effect
            });

            // Remove emoji from DOM after animation finishes
            animation.finished.then(() => emoji.remove());
        }
    }

  // --- Expose functions needed by HTML ---
  window.continuar = continuar;
  window.voltar = voltar;
  // Note: confirmar is called internally by createCardElement, no need to expose unless called elsewhere

  // --- INITIALIZATION ---
  window.onload = async () => {
      console.log("[window.onload] Page loading...");
      if (db) { // Proceed only if Firebase initialized
        console.log("[window.onload] Calling preencherNomes()...");
        await preencherNomes(); // Fetch names and populate input logic
        console.log("[window.onload] preencherNomes() finished.");

        // Add Enter key listener only if input is enabled (names loaded successfully)
        if (!nomeInput.disabled) {
            console.log("[window.onload] Adding Enter listener to nomeInput.");
            nomeInput.addEventListener('keypress', function(event) {
                if (event.key === 'Enter') {
                    event.preventDefault(); // Prevent default form submission if applicable
                    // Try to continue if button is enabled OR if current text is valid
                    if (!continuarBtn.disabled || allNames.includes(nomeInput.value.trim())) {
                        continuar();
                    } else {
                         // Maybe shake the input or provide visual feedback?
                         console.log("Enter pressed but name invalid or button disabled.");
                         nomeInput.focus(); // Keep focus on input
                    }
                }
            });
             console.log("[window.onload] Enter listener added.");
        } else {
             console.log("[window.onload] Skipping Enter listener because name input is disabled.");
        }
      } else {
          console.error("[window.onload] Skipping setup because DB is not initialized.");
      }
      console.log("[window.onload] Page load script finished.");
  };

</script>

</body>
</html>
